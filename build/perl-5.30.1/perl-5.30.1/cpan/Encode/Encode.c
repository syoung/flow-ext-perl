/*
 * This file was generated automatically by ExtUtils::ParseXS version 3.40 from the
 * contents of Encode.xs. Do not edit this file, edit Encode.xs instead.
 *
 *    ANY CHANGES MADE HERE WILL BE LOST!
 *
 */

#line 1 "Encode.xs"
/*
 $Id: Encode.xs,v 2.47 2019/03/13 00:26:18 dankogai Exp dankogai $
 */

#define PERL_NO_GET_CONTEXT
#define IN_ENCODE_XS
#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "encode.h"
#include "def_t.h"

# define PERLIO_MODNAME  "PerlIO::encoding"
# define PERLIO_FILENAME "PerlIO/encoding.pm"

/* set 1 or more to profile.  t/encoding.t dumps core because of
   Perl_warner and PerlIO don't work well */
#define ENCODE_XS_PROFILE 0

/* set 0 to disable floating point to calculate buffer size for
   encode_method().  1 is recommended. 2 restores NI-S original */
#define ENCODE_XS_USEFP   1

#ifndef SvIV_nomg
#define SvIV_nomg SvIV
#endif

#ifndef SvTRUE_nomg
#define SvTRUE_nomg SvTRUE
#endif

#ifndef SVfARG
#define SVfARG(p) ((void*)(p))
#endif

static void
Encode_XSEncoding(pTHX_ encode_t * enc)
{
    dSP;
    HV *stash = gv_stashpv("Encode::XS", TRUE);
    SV *iv    = newSViv(PTR2IV(enc));
    SV *sv    = sv_bless(newRV_noinc(iv),stash);
    int i = 0;
    /* with the SvLEN() == 0 hack, PVX won't be freed. We cast away name's
    constness, in the hope that perl won't mess with it. */
    assert(SvTYPE(iv) >= SVt_PV); assert(SvLEN(iv) == 0);
    SvFLAGS(iv) |= SVp_POK;
    SvPVX(iv) = (char*) enc->name[0];
    PUSHMARK(sp);
    XPUSHs(sv);
    while (enc->name[i]) {
    const char *name = enc->name[i++];
    XPUSHs(sv_2mortal(newSVpvn(name, strlen(name))));
    }
    PUTBACK;
    call_pv("Encode::define_encoding", G_DISCARD);
    SvREFCNT_dec(sv);
}

static void
utf8_safe_downgrade(pTHX_ SV ** src, U8 ** s, STRLEN * slen, bool modify)
{
    if (!modify) {
        SV *tmp = sv_2mortal(newSVpvn((char *)*s, *slen));
        SvUTF8_on(tmp);
        if (SvTAINTED(*src))
            SvTAINTED_on(tmp);
        *src = tmp;
        *s = (U8 *)SvPVX(*src);
    }
    if (*slen) {
        if (!utf8_to_bytes(*s, slen))
            croak("Wide character");
        SvCUR_set(*src, *slen);
    }
    SvUTF8_off(*src);
}

static void
utf8_safe_upgrade(pTHX_ SV ** src, U8 ** s, STRLEN * slen, bool modify)
{
    if (!modify) {
        SV *tmp = sv_2mortal(newSVpvn((char *)*s, *slen));
        if (SvTAINTED(*src))
            SvTAINTED_on(tmp);
        *src = tmp;
    }
    sv_utf8_upgrade_nomg(*src);
    *s = (U8 *)SvPV_nomg(*src, *slen);
}

#define ERR_ENCODE_NOMAP "\"\\x{%04" UVxf "}\" does not map to %s"
#define ERR_DECODE_NOMAP "%s \"\\x%02" UVXf "\" does not map to Unicode"
#define ERR_DECODE_STR_NOMAP "%s \"%s\" does not map to Unicode"

static SV *
do_fallback_cb(pTHX_ UV ch, SV *fallback_cb)
{
    dSP;
    int argc;
    SV *retval;
    ENTER;
    SAVETMPS;
    PUSHMARK(sp);
    XPUSHs(sv_2mortal(newSVuv(ch)));
    PUTBACK;
    argc = call_sv(fallback_cb, G_SCALAR);
    SPAGAIN;
    if (argc != 1){
	croak("fallback sub must return scalar!");
    }
    retval = POPs;
    SvREFCNT_inc(retval);
    PUTBACK;
    FREETMPS;
    LEAVE;
    return retval;
}

static SV *
do_bytes_fallback_cb(pTHX_ U8 *s, STRLEN slen, SV *fallback_cb)
{
    dSP;
    int argc;
    STRLEN i;
    SV *retval;
    ENTER;
    SAVETMPS;
    PUSHMARK(sp);
    for (i=0; i<slen; ++i)
        XPUSHs(sv_2mortal(newSVuv(s[i])));
    PUTBACK;
    argc = call_sv(fallback_cb, G_SCALAR);
    SPAGAIN;
    if (argc != 1){
        croak("fallback sub must return scalar!");
    }
    retval = POPs;
    SvREFCNT_inc(retval);
    PUTBACK;
    FREETMPS;
    LEAVE;
    return retval;
}

static SV *
encode_method(pTHX_ const encode_t * enc, const encpage_t * dir, SV * src, U8 * s, STRLEN slen,
	      IV check, STRLEN * offset, SV * term, int * retcode, 
	      SV *fallback_cb)
{
    U8 *sorig    = s;
    STRLEN tlen  = slen;
    STRLEN ddone = 0;
    STRLEN sdone = 0;
    /* We allocate slen+1.
       PerlIO dumps core if this value is smaller than this. */
    SV *dst = newSV(slen+1);
    U8 *d = (U8 *)SvPVX(dst);
    STRLEN dlen = SvLEN(dst)-1;
    int code = 0;
    STRLEN trmlen = 0;
    U8 *trm = term ? (U8*) SvPV(term, trmlen) : NULL;

    if (SvTAINTED(src)) SvTAINTED_on(dst); /* propagate taintedness */

    if (offset) {
      s += *offset;
      if (slen > *offset){ /* safeguard against slen overflow */
          slen -= *offset;
      }else{
          slen = 0;
      }
      tlen = slen;
    }

    if (slen == 0){
        SvCUR_set(dst, 0);
        SvPOK_only(dst);
        goto ENCODE_END;
    }

    while( (code = do_encode(dir, s, &slen, d, dlen, &dlen, !check,
                 trm, trmlen)) )
    {
        SvCUR_set(dst, dlen+ddone);
        SvPOK_only(dst);

        if (code == ENCODE_FALLBACK || code == ENCODE_PARTIAL ||
            code == ENCODE_FOUND_TERM) {
            break;
        }
        switch (code) {
        case ENCODE_NOSPACE:
        {
            STRLEN more = 0; /* make sure you initialize! */
            STRLEN sleft;
            sdone += slen;
            ddone += dlen;
            sleft = tlen - sdone;
#if ENCODE_XS_PROFILE >= 2
            Perl_warn(aTHX_
                  "more=%d, sdone=%d, sleft=%d, SvLEN(dst)=%d\n",
                  more, sdone, sleft, SvLEN(dst));
#endif
            if (sdone != 0) { /* has src ever been processed ? */
#if   ENCODE_XS_USEFP == 2
                more = (1.0*tlen*SvLEN(dst)+sdone-1)/sdone
                    - SvLEN(dst);
#elif ENCODE_XS_USEFP
                more = (STRLEN)((1.0*SvLEN(dst)+1)/sdone * sleft);
#else
            /* safe until SvLEN(dst) == MAX_INT/16 */
                more = (16*SvLEN(dst)+1)/sdone/16 * sleft;
#endif
            }
            more += UTF8_MAXLEN; /* insurance policy */
            d = (U8 *) SvGROW(dst, SvLEN(dst) + more);
            /* dst need to grow need MORE bytes! */
            if (ddone >= SvLEN(dst)) {
                Perl_croak(aTHX_ "Destination couldn't be grown.");
            }
            dlen = SvLEN(dst)-ddone-1;
            d   += ddone;
            s   += slen;
            slen = tlen-sdone;
            continue;
        }

    case ENCODE_NOREP:
        /* encoding */	
        if (dir == enc->f_utf8) {
        STRLEN clen;
        UV ch =
            utf8n_to_uvuni(s+slen, (tlen-sdone-slen),
                   &clen, UTF8_ALLOW_ANY|UTF8_CHECK_ONLY);
        /* if non-representable multibyte prefix at end of current buffer - break*/
        if (clen > tlen - sdone - slen) break;
        if (check & ENCODE_DIE_ON_ERR) {
            Perl_croak(aTHX_ ERR_ENCODE_NOMAP,
                   (UV)ch, enc->name[0]);
            return &PL_sv_undef; /* never reaches but be safe */
        }
        if (encode_ckWARN(check, WARN_UTF8)) {
            Perl_warner(aTHX_ packWARN(WARN_UTF8),
                ERR_ENCODE_NOMAP, (UV)ch, enc->name[0]);
        }
        if (check & ENCODE_RETURN_ON_ERR){
            goto ENCODE_SET_SRC;
        }
        if (check & (ENCODE_PERLQQ|ENCODE_HTMLCREF|ENCODE_XMLCREF)){
            STRLEN sublen;
            char *substr;
            SV* subchar = 
            (fallback_cb != &PL_sv_undef)
		? do_fallback_cb(aTHX_ ch, fallback_cb)
		: newSVpvf(check & ENCODE_PERLQQ ? "\\x{%04" UVxf "}" :
                 check & ENCODE_HTMLCREF ? "&#%" UVuf ";" :
                 "&#x%" UVxf ";", (UV)ch);
            substr = SvPV(subchar, sublen);
            if (SvUTF8(subchar) && sublen && !utf8_to_bytes((U8 *)substr, &sublen)) { /* make sure no decoded string gets in */
                SvREFCNT_dec(subchar);
                croak("Wide character");
            }
            sdone += slen + clen;
            ddone += dlen + sublen;
            sv_catpvn(dst, substr, sublen);
            SvREFCNT_dec(subchar);
        } else {
            /* fallback char */
            sdone += slen + clen;
            ddone += dlen + enc->replen;
            sv_catpvn(dst, (char*)enc->rep, enc->replen);
        }
        }
        /* decoding */
        else {
        if (check & ENCODE_DIE_ON_ERR){
            Perl_croak(aTHX_ ERR_DECODE_NOMAP,
                              enc->name[0], (UV)s[slen]);
            return &PL_sv_undef; /* never reaches but be safe */
        }
        if (encode_ckWARN(check, WARN_UTF8)) {
            Perl_warner(
            aTHX_ packWARN(WARN_UTF8),
            ERR_DECODE_NOMAP,
               	        enc->name[0], (UV)s[slen]);
        }
        if (check & ENCODE_RETURN_ON_ERR){
            goto ENCODE_SET_SRC;
        }
        if (check &
            (ENCODE_PERLQQ|ENCODE_HTMLCREF|ENCODE_XMLCREF)){
            STRLEN sublen;
            char *substr;
            SV* subchar = 
            (fallback_cb != &PL_sv_undef)
		? do_fallback_cb(aTHX_ (UV)s[slen], fallback_cb) 
		: newSVpvf("\\x%02" UVXf, (UV)s[slen]);
            substr = SvPVutf8(subchar, sublen);
            sdone += slen + 1;
            ddone += dlen + sublen;
            sv_catpvn(dst, substr, sublen);
            SvREFCNT_dec(subchar);
        } else {
            sdone += slen + 1;
            ddone += dlen + strlen(FBCHAR_UTF8);
            sv_catpvn(dst, FBCHAR_UTF8, strlen(FBCHAR_UTF8));
        }
        }
        /* settle variables when fallback */
        d    = (U8 *)SvEND(dst);
        dlen = SvLEN(dst) - ddone - 1;
        s    = sorig + sdone;
        slen = tlen - sdone;
        break;

        default:
            Perl_croak(aTHX_ "Unexpected code %d converting %s %s",
                   code, (dir == enc->f_utf8) ? "to" : "from",
                   enc->name[0]);
            return &PL_sv_undef;
        }
    }   /* End of looping through the string */
 ENCODE_SET_SRC:
    if (check && !(check & ENCODE_LEAVE_SRC)){
        sdone = tlen - (slen+sdone);
        sv_setpvn(src, (char*)s+slen, sdone);
        SvSETMAGIC(src);
    }
    /* warn("check = 0x%X, code = 0x%d\n", check, code); */

    SvCUR_set(dst, dlen+ddone);
    SvPOK_only(dst);

#if ENCODE_XS_PROFILE
    if (SvCUR(dst) > tlen){
    Perl_warn(aTHX_
          "SvLEN(dst)=%d, SvCUR(dst)=%d. %d bytes unused(%f %%)\n",
          SvLEN(dst), SvCUR(dst), SvLEN(dst) - SvCUR(dst),
          (SvLEN(dst) - SvCUR(dst))*1.0/SvLEN(dst)*100.0);
    }
#endif

    if (offset)
      *offset += sdone + slen;

 ENCODE_END:
    *SvEND(dst) = '\0';
    if (retcode) *retcode = code;
    return dst;
}

static bool
strict_utf8(pTHX_ SV* sv)
{
    HV* hv;
    SV** svp;
    sv = SvRV(sv);
    if (!sv || SvTYPE(sv) != SVt_PVHV)
        return 0;
    hv = (HV*)sv;
    svp = hv_fetch(hv, "strict_utf8", 11, 0);
    if (!svp)
        return 0;
    return SvTRUE(*svp);
}

static U8*
process_utf8(pTHX_ SV* dst, U8* s, U8* e, SV *check_sv,
             bool encode, bool strict, bool stop_at_partial)
{
    /* Copies the purportedly UTF-8 encoded string starting at 's' and ending
     * at 'e' - 1 to 'dst', checking as it goes along that the string actually
     * is valid UTF-8.  There are two levels of strictness checking.  If
     * 'strict' is FALSE, the string is checked for being well-formed UTF-8, as
     * extended by Perl.  Additionally, if 'strict' is TRUE, above-Unicode code
     * points, surrogates, and non-character code points are checked for.  When
     * invalid input is encountered, some action is taken, exactly what depends
     * on the flags in 'check_sv'.  'encode' gives if this is from an encode
     * operation (if TRUE), or a decode one.  This function returns the
     * position in 's' of the start of the next character beyond where it got
     * to.  If there were no problems, that will be 'e'.  If 'stop_at_partial'
     * is TRUE, if the final character before 'e' is incomplete, but valid as
     * far as is available, no action will be taken on that partial character,
     * and the return value will point to its first byte */

    UV uv;
    STRLEN ulen;
    SV *fallback_cb;
    IV check;
    U8 *d;
    STRLEN dlen;
    char esc[UTF8_MAXLEN * 6 + 1];
    STRLEN i;
    const U32 flags = (strict)
                    ? UTF8_DISALLOW_ILLEGAL_INTERCHANGE
                    : 0;

    if (!SvOK(check_sv)) {
	fallback_cb = &PL_sv_undef;
	check = 0;
    }
    else if (SvROK(check_sv)) {
	/* croak("UTF-8 decoder doesn't support callback CHECK"); */
	fallback_cb = check_sv;
	check = ENCODE_PERLQQ|ENCODE_LEAVE_SRC; /* same as perlqq */
    }
    else {
	fallback_cb = &PL_sv_undef;
	check = SvIV_nomg(check_sv);
    }

    SvPOK_only(dst);
    SvCUR_set(dst,0);

    dlen = (s && e && s < e) ? e-s+1 : 1;
    d = (U8 *) SvGROW(dst, dlen);

    stop_at_partial = stop_at_partial || (check & ENCODE_STOP_AT_PARTIAL);

    while (s < e) {

        /* If there were no errors, this will be 'e'; otherwise it will point
         * to the first byte of the erroneous input */
        const U8* e_or_where_failed;
        bool valid = is_utf8_string_loc_flags(s, e - s, &e_or_where_failed, flags);
        STRLEN len = e_or_where_failed - s;

        /* Copy as far as was successful */
        Move(s, d, len, U8);
        d += len;
        s = (U8 *) e_or_where_failed;

        /* Are done if it was valid, or we are accepting partial characters and
         * the only error is that the final bytes form a partial character */
        if (    LIKELY(valid)
            || (   stop_at_partial
                && is_utf8_valid_partial_char_flags(s, e, flags)))
        {
            break;
        }

        /* Here, was not valid.  If is 'strict', and is legal extended UTF-8,
         * we know it is a code point whose value we can calculate, just not
         * one accepted under strict.  Otherwise, it is malformed in some way.
         * In either case, the system function can calculate either the code
         * point, or the best substitution for it */
        uv = utf8n_to_uvchr(s, e - s, &ulen, UTF8_ALLOW_ANY);

        /*
         * Here, we are looping through the input and found an error.
         * 'uv' is the code point in error if calculable, or the REPLACEMENT
         *      CHARACTER if not.
         * 'ulen' is how many bytes of input this iteration of the loop
         *        consumes */

        if (!encode && (check & (ENCODE_DIE_ON_ERR|ENCODE_WARN_ON_ERR|ENCODE_PERLQQ)))
            for (i=0; i<ulen; ++i) sprintf(esc+4*i, "\\x%02X", s[i]);
        if (check & ENCODE_DIE_ON_ERR){
            if (encode)
                Perl_croak(aTHX_ ERR_ENCODE_NOMAP, uv, (strict ? "UTF-8" : "utf8"));
            else
                Perl_croak(aTHX_ ERR_DECODE_STR_NOMAP, (strict ? "UTF-8" : "utf8"), esc);
        }
        if (encode_ckWARN(check, WARN_UTF8)) {
            if (encode)
                Perl_warner(aTHX_ packWARN(WARN_UTF8),
                            ERR_ENCODE_NOMAP, uv, (strict ? "UTF-8" : "utf8"));
            else
                Perl_warner(aTHX_ packWARN(WARN_UTF8),
                            ERR_DECODE_STR_NOMAP, (strict ? "UTF-8" : "utf8"), esc);
        }
        if (check & ENCODE_RETURN_ON_ERR) {
                break;
        }
        if (check & (ENCODE_PERLQQ|ENCODE_HTMLCREF|ENCODE_XMLCREF)){
            STRLEN sublen;
            char *substr;
            SV* subchar;
            if (encode) {
                subchar =
                    (fallback_cb != &PL_sv_undef)
                    ? do_fallback_cb(aTHX_ uv, fallback_cb)
                    : newSVpvf(check & ENCODE_PERLQQ
                        ? (ulen == 1 ? "\\x%02" UVXf : "\\x{%04" UVXf "}")
                        :  check & ENCODE_HTMLCREF ? "&#%" UVuf ";"
                        : "&#x%" UVxf ";", uv);
                substr = SvPV(subchar, sublen);
                if (SvUTF8(subchar) && sublen && !utf8_to_bytes((U8 *)substr, &sublen)) { /* make sure no decoded string gets in */
                    SvREFCNT_dec(subchar);
                    croak("Wide character");
                }
            } else {
                if (fallback_cb != &PL_sv_undef) {
                    /* in decode mode we have sequence of wrong bytes */
                    subchar = do_bytes_fallback_cb(aTHX_ s, ulen, fallback_cb);
                } else {
                    char *ptr = esc;
                    /* ENCODE_PERLQQ is already stored in esc */
                    if (check & (ENCODE_HTMLCREF|ENCODE_XMLCREF))
                        for (i=0; i<ulen; ++i) ptr += sprintf(ptr, ((check & ENCODE_HTMLCREF) ? "&#%u;" : "&#x%02X;"), s[i]);
                    subchar = newSVpvn(esc, strlen(esc));
                }
                substr = SvPVutf8(subchar, sublen);
            }
            dlen += sublen - ulen;
            SvCUR_set(dst, d-(U8 *)SvPVX(dst));
            *SvEND(dst) = '\0';
            sv_catpvn(dst, substr, sublen);
            SvREFCNT_dec(subchar);
            d = (U8 *) SvGROW(dst, dlen) + SvCUR(dst);
        } else {
            STRLEN fbcharlen = strlen(FBCHAR_UTF8);
            dlen += fbcharlen - ulen;
            if (SvLEN(dst) < dlen) {
                SvCUR_set(dst, d-(U8 *)SvPVX(dst));
                d = (U8 *) sv_grow(dst, dlen) + SvCUR(dst);
            }
            memcpy(d, FBCHAR_UTF8, fbcharlen);
            d += fbcharlen;
        }
        s += ulen;
    }
    SvCUR_set(dst, d-(U8 *)SvPVX(dst));
    *SvEND(dst) = '\0';

    return s;
}

static SV *
find_encoding(pTHX_ SV *enc)
{
    dSP;
    I32 count;
    SV *m_enc;
    SV *obj = &PL_sv_undef;
#ifndef SV_NOSTEAL
    U32 tmp;
#endif

    ENTER;
    SAVETMPS;
    PUSHMARK(sp);

    m_enc = sv_newmortal();
#ifndef SV_NOSTEAL
    tmp = SvFLAGS(enc) & SVs_TEMP;
    SvTEMP_off(enc);
    sv_setsv_flags(m_enc, enc, 0);
    SvFLAGS(enc) |= tmp;
#else
#if SV_NOSTEAL == 0
    #error You have broken SV_NOSTEAL which cause memory corruption in sv_setsv_flags()
    #error Most probably broken SV_NOSTEAL was defined by buggy version of ppport.h
#else
    sv_setsv_flags(m_enc, enc, SV_NOSTEAL);
#endif
#endif
    XPUSHs(m_enc);

    PUTBACK;

    count = call_pv("Encode::find_encoding", G_SCALAR);

    SPAGAIN;

    if (count > 0) {
        obj = POPs;
        SvREFCNT_inc(obj);
    }

    PUTBACK;
    FREETMPS;
    LEAVE;
    return sv_2mortal(obj);
}

static SV *
call_encoding(pTHX_ const char *method, SV *obj, SV *src, SV *check)
{
    dSP;
    I32 count;
    SV *dst = &PL_sv_undef;

    PUSHMARK(sp);

    if (check)
        check = sv_2mortal(newSVsv(check));

    if (!check || SvROK(check) || !SvTRUE_nomg(check) || (SvIV_nomg(check) & ENCODE_LEAVE_SRC))
        src = sv_2mortal(newSVsv(src));

    XPUSHs(obj);
    XPUSHs(src);
    XPUSHs(check ? check : &PL_sv_no);

    PUTBACK;

    count = call_method(method, G_SCALAR);

    SPAGAIN;

    if (count > 0) {
        dst = POPs;
        SvREFCNT_inc(dst);
    }

    PUTBACK;
    return dst;
}


#line 623 "Encode.c"
#ifndef PERL_UNUSED_VAR
#  define PERL_UNUSED_VAR(var) if (0) var = var
#endif

#ifndef dVAR
#  define dVAR		dNOOP
#endif


/* This stuff is not part of the API! You have been warned. */
#ifndef PERL_VERSION_DECIMAL
#  define PERL_VERSION_DECIMAL(r,v,s) (r*1000000 + v*1000 + s)
#endif
#ifndef PERL_DECIMAL_VERSION
#  define PERL_DECIMAL_VERSION \
	  PERL_VERSION_DECIMAL(PERL_REVISION,PERL_VERSION,PERL_SUBVERSION)
#endif
#ifndef PERL_VERSION_GE
#  define PERL_VERSION_GE(r,v,s) \
	  (PERL_DECIMAL_VERSION >= PERL_VERSION_DECIMAL(r,v,s))
#endif
#ifndef PERL_VERSION_LE
#  define PERL_VERSION_LE(r,v,s) \
	  (PERL_DECIMAL_VERSION <= PERL_VERSION_DECIMAL(r,v,s))
#endif

/* XS_INTERNAL is the explicit static-linkage variant of the default
 * XS macro.
 *
 * XS_EXTERNAL is the same as XS_INTERNAL except it does not include
 * "STATIC", ie. it exports XSUB symbols. You probably don't want that
 * for anything but the BOOT XSUB.
 *
 * See XSUB.h in core!
 */


/* TODO: This might be compatible further back than 5.10.0. */
#if PERL_VERSION_GE(5, 10, 0) && PERL_VERSION_LE(5, 15, 1)
#  undef XS_EXTERNAL
#  undef XS_INTERNAL
#  if defined(__CYGWIN__) && defined(USE_DYNAMIC_LOADING)
#    define XS_EXTERNAL(name) __declspec(dllexport) XSPROTO(name)
#    define XS_INTERNAL(name) STATIC XSPROTO(name)
#  endif
#  if defined(__SYMBIAN32__)
#    define XS_EXTERNAL(name) EXPORT_C XSPROTO(name)
#    define XS_INTERNAL(name) EXPORT_C STATIC XSPROTO(name)
#  endif
#  ifndef XS_EXTERNAL
#    if defined(HASATTRIBUTE_UNUSED) && !defined(__cplusplus)
#      define XS_EXTERNAL(name) void name(pTHX_ CV* cv __attribute__unused__)
#      define XS_INTERNAL(name) STATIC void name(pTHX_ CV* cv __attribute__unused__)
#    else
#      ifdef __cplusplus
#        define XS_EXTERNAL(name) extern "C" XSPROTO(name)
#        define XS_INTERNAL(name) static XSPROTO(name)
#      else
#        define XS_EXTERNAL(name) XSPROTO(name)
#        define XS_INTERNAL(name) STATIC XSPROTO(name)
#      endif
#    endif
#  endif
#endif

/* perl >= 5.10.0 && perl <= 5.15.1 */


/* The XS_EXTERNAL macro is used for functions that must not be static
 * like the boot XSUB of a module. If perl didn't have an XS_EXTERNAL
 * macro defined, the best we can do is assume XS is the same.
 * Dito for XS_INTERNAL.
 */
#ifndef XS_EXTERNAL
#  define XS_EXTERNAL(name) XS(name)
#endif
#ifndef XS_INTERNAL
#  define XS_INTERNAL(name) XS(name)
#endif

/* Now, finally, after all this mess, we want an ExtUtils::ParseXS
 * internal macro that we're free to redefine for varying linkage due
 * to the EXPORT_XSUB_SYMBOLS XS keyword. This is internal, use
 * XS_EXTERNAL(name) or XS_INTERNAL(name) in your code if you need to!
 */

#undef XS_EUPXS
#if defined(PERL_EUPXS_ALWAYS_EXPORT)
#  define XS_EUPXS(name) XS_EXTERNAL(name)
#else
   /* default to internal */
#  define XS_EUPXS(name) XS_INTERNAL(name)
#endif

#ifndef PERL_ARGS_ASSERT_CROAK_XS_USAGE
#define PERL_ARGS_ASSERT_CROAK_XS_USAGE assert(cv); assert(params)

/* prototype to pass -Wmissing-prototypes */
STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params);

STATIC void
S_croak_xs_usage(const CV *const cv, const char *const params)
{
    const GV *const gv = CvGV(cv);

    PERL_ARGS_ASSERT_CROAK_XS_USAGE;

    if (gv) {
        const char *const gvname = GvNAME(gv);
        const HV *const stash = GvSTASH(gv);
        const char *const hvname = stash ? HvNAME(stash) : NULL;

        if (hvname)
	    Perl_croak_nocontext("Usage: %s::%s(%s)", hvname, gvname, params);
        else
	    Perl_croak_nocontext("Usage: %s(%s)", gvname, params);
    } else {
        /* Pants. I don't think that it should be possible to get here. */
	Perl_croak_nocontext("Usage: CODE(0x%" UVxf ")(%s)", PTR2UV(cv), params);
    }
}
#undef  PERL_ARGS_ASSERT_CROAK_XS_USAGE

#define croak_xs_usage        S_croak_xs_usage

#endif

/* NOTE: the prototype of newXSproto() is different in versions of perls,
 * so we define a portable version of newXSproto()
 */
#ifdef newXS_flags
#define newXSproto_portable(name, c_impl, file, proto) newXS_flags(name, c_impl, file, proto, 0)
#else
#define newXSproto_portable(name, c_impl, file, proto) (PL_Sv=(SV*)newXS(name, c_impl, file), sv_setpv(PL_Sv, proto), (CV*)PL_Sv)
#endif /* !defined(newXS_flags) */

#if PERL_VERSION_LE(5, 21, 5)
#  define newXS_deffile(a,b) Perl_newXS(aTHX_ a,b,file)
#else
#  define newXS_deffile(a,b) Perl_newXS_deffile(aTHX_ a,b)
#endif

#line 767 "Encode.c"

XS_EUPXS(XS_Encode__utf8_decode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode__utf8_decode)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "obj, src, check_sv = &PL_sv_no");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	obj = ST(0)
;
	SV *	src = ST(1)
;
	SV *	check_sv;
#line 623 "Encode.xs"
    STRLEN slen;
    U8 *s;
    U8 *e;
    SV *dst;
    bool renewed = 0;
    IV check;
    bool modify;
    dSP;
#line 792 "Encode.c"

	if (items < 3)
	    check_sv = &PL_sv_no;
	else {
	    check_sv = ST(2)
;
	}
#line 632 "Encode.xs"
    SvGETMAGIC(src);
    SvGETMAGIC(check_sv);
    check = SvROK(check_sv) ? ENCODE_PERLQQ|ENCODE_LEAVE_SRC : SvOK(check_sv) ? SvIV_nomg(check_sv) : 0;
    modify = (check && !(check & ENCODE_LEAVE_SRC));
#line 805 "Encode.c"
#line 637 "Encode.xs"
    if (!SvOK(src))
        XSRETURN_UNDEF;
    s = modify ? (U8 *)SvPV_force_nomg(src, slen) : (U8 *)SvPV_nomg(src, slen);
    if (SvUTF8(src))
        utf8_safe_downgrade(aTHX_ &src, &s, &slen, modify);
    e = s+slen;

    /*
     * PerlIO check -- we assume the object is of PerlIO if renewed
     */
    ENTER; SAVETMPS;
    PUSHMARK(sp);
    XPUSHs(obj);
    PUTBACK;
    if (call_method("renewed",G_SCALAR) == 1) {
    SPAGAIN;
    renewed = (bool)POPi;
    PUTBACK;
#if 0
    fprintf(stderr, "renewed == %d\n", renewed);
#endif
    }
    FREETMPS; LEAVE;
    /* end PerlIO check */

    dst = sv_2mortal(newSV(slen>0?slen:1)); /* newSV() abhors 0 -- inaba */
    s = process_utf8(aTHX_ dst, s, e, check_sv, 0, strict_utf8(aTHX_ obj), renewed);

    /* Clear out translated part of source unless asked not to */
    if (modify) {
        slen = e-s;
        sv_setpvn(src, (char*)s, slen);
        SvSETMAGIC(src);
    }
    SvUTF8_on(dst);
    if (SvTAINTED(src)) SvTAINTED_on(dst); /* propagate taintedness */
    ST(0) = dst;
    XSRETURN(1);
#line 845 "Encode.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Encode__utf8_encode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode__utf8_encode)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "obj, src, check_sv = &PL_sv_no");
    PERL_UNUSED_VAR(ax); /* -Wall */
    SP -= items;
    {
	SV *	obj = ST(0)
;
	SV *	src = ST(1)
;
	SV *	check_sv;
#line 682 "Encode.xs"
    STRLEN slen;
    U8 *s;
    U8 *e;
    SV *dst;
    IV check;
    bool modify;
#line 873 "Encode.c"

	if (items < 3)
	    check_sv = &PL_sv_no;
	else {
	    check_sv = ST(2)
;
	}
#line 689 "Encode.xs"
    SvGETMAGIC(src);
    SvGETMAGIC(check_sv);
    check = SvROK(check_sv) ? ENCODE_PERLQQ|ENCODE_LEAVE_SRC : SvOK(check_sv) ? SvIV_nomg(check_sv) : 0;
    modify = (check && !(check & ENCODE_LEAVE_SRC));
#line 886 "Encode.c"
#line 694 "Encode.xs"
    if (!SvOK(src))
        XSRETURN_UNDEF;
    s = modify ? (U8 *)SvPV_force_nomg(src, slen) : (U8 *)SvPV_nomg(src, slen);
    e = s+slen;
    dst = sv_2mortal(newSV(slen>0?slen:1)); /* newSV() abhors 0 -- inaba */
    if (SvUTF8(src)) {
    /* Already encoded */
    if (strict_utf8(aTHX_ obj)) {
        s = process_utf8(aTHX_ dst, s, e, check_sv, 1, 1, 0);
    }
        else {
            /* trust it and just copy the octets */
    	    sv_setpvn(dst,(char *)s,(e-s));
        s = e;
        }
    }
    else {
        /* Native bytes - can always encode */
        U8 *d = (U8 *) SvGROW(dst, 2*slen+1); /* +1 or assertion will botch */
        while (s < e) {
#ifdef append_utf8_from_native_byte
            append_utf8_from_native_byte(*s, &d);
            s++;
#else
            UV uv = NATIVE_TO_UNI((UV) *s);
            s++; /* Above expansion of NATIVE_TO_UNI() is safer this way. */
            if (UNI_IS_INVARIANT(uv))
                *d++ = (U8)UTF_TO_NATIVE(uv);
            else {
                *d++ = (U8)UTF8_EIGHT_BIT_HI(uv);
                *d++ = (U8)UTF8_EIGHT_BIT_LO(uv);
            }
#endif
        }
        SvCUR_set(dst, d- (U8 *)SvPVX(dst));
        *SvEND(dst) = '\0';
    }

    /* Clear out translated part of source unless asked not to */
    if (modify) {
        slen = e-s;
        sv_setpvn(src, (char*)s, slen);
        SvSETMAGIC(src);
    }
    SvPOK_only(dst);
    SvUTF8_off(dst);
    if (SvTAINTED(src)) SvTAINTED_on(dst); /* propagate taintedness */
    ST(0) = dst;
    XSRETURN(1);
#line 937 "Encode.c"
	PUTBACK;
	return;
    }
}


XS_EUPXS(XS_Encode__XS_renew); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode__XS_renew)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	obj = ST(0)
;
	SV *	RETVAL;
#line 752 "Encode.xs"
    PERL_UNUSED_VAR(obj);
    RETVAL = newSVsv(obj);
#line 957 "Encode.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode__XS_renewed); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode__XS_renewed)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	obj = ST(0)
;
	int	RETVAL;
	dXSTARG;
#line 761 "Encode.xs"
    RETVAL = 0;
    PERL_UNUSED_VAR(obj);
#line 979 "Encode.c"
	XSprePUSH; PUSHi((IV)RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode__XS_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode__XS_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	obj = ST(0)
;
#line 770 "Encode.xs"
    encode_t *enc;
#line 997 "Encode.c"
	SV *	RETVAL;
#line 772 "Encode.xs"
    enc = INT2PTR(encode_t *, SvIV(SvRV(obj)));
#line 1001 "Encode.c"
#line 774 "Encode.xs"
    RETVAL = newSVpvn(enc->name[0], strlen(enc->name[0]));
#line 1004 "Encode.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode__XS_cat_decode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode__XS_cat_decode)
{
    dVAR; dXSARGS;
    if (items < 5 || items > 6)
       croak_xs_usage(cv,  "obj, dst, src, off, term, check_sv = &PL_sv_no");
    {
	SV *	obj = ST(0)
;
	SV *	dst = ST(1)
;
	SV *	src = ST(2)
;
	SV *	off = ST(3)
;
	SV *	term = ST(4)
;
	SV *	check_sv;
#line 787 "Encode.xs"
    IV check;
    SV *fallback_cb;
    bool modify;
    encode_t *enc;
    STRLEN offset;
    int code = 0;
    U8 *s;
    STRLEN slen;
    SV *tmp;
#line 1040 "Encode.c"
	bool	RETVAL;

	if (items < 6)
	    check_sv = &PL_sv_no;
	else {
	    check_sv = ST(5)
;
	}
#line 797 "Encode.xs"
    SvGETMAGIC(src);
    SvGETMAGIC(check_sv);
    check = SvROK(check_sv) ? ENCODE_PERLQQ|ENCODE_LEAVE_SRC : SvOK(check_sv) ? SvIV_nomg(check_sv) : 0;
    fallback_cb = SvROK(check_sv) ? check_sv : &PL_sv_undef;
    modify = (check && !(check & ENCODE_LEAVE_SRC));
    enc = INT2PTR(encode_t *, SvIV(SvRV(obj)));
    offset = (STRLEN)SvIV(off);
#line 1057 "Encode.c"
#line 805 "Encode.xs"
    if (!SvOK(src))
        XSRETURN_NO;
    s = modify ? (U8 *)SvPV_force_nomg(src, slen) : (U8 *)SvPV_nomg(src, slen);
    if (SvUTF8(src))
        utf8_safe_downgrade(aTHX_ &src, &s, &slen, modify);
    tmp = encode_method(aTHX_ enc, enc->t_utf8, src, s, slen, check,
                &offset, term, &code, fallback_cb);
    sv_catsv(dst, tmp);
    SvREFCNT_dec(tmp);
    SvIV_set(off, (IV)offset);
    RETVAL = (code == ENCODE_FOUND_TERM);
#line 1070 "Encode.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode__XS_decode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode__XS_decode)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "obj, src, check_sv = &PL_sv_no");
    {
	SV *	obj = ST(0)
;
	SV *	src = ST(1)
;
	SV *	check_sv;
#line 825 "Encode.xs"
    IV check;
    SV *fallback_cb;
    bool modify;
    encode_t *enc;
    U8 *s;
    STRLEN slen;
#line 1096 "Encode.c"
	SV *	RETVAL;

	if (items < 3)
	    check_sv = &PL_sv_no;
	else {
	    check_sv = ST(2)
;
	}
#line 832 "Encode.xs"
    SvGETMAGIC(src);
    SvGETMAGIC(check_sv);
    check = SvROK(check_sv) ? ENCODE_PERLQQ|ENCODE_LEAVE_SRC : SvOK(check_sv) ? SvIV_nomg(check_sv) : 0;
    fallback_cb = SvROK(check_sv) ? check_sv : &PL_sv_undef;
    modify = (check && !(check & ENCODE_LEAVE_SRC));
    enc = INT2PTR(encode_t *, SvIV(SvRV(obj)));
#line 1112 "Encode.c"
#line 839 "Encode.xs"
    if (!SvOK(src))
        XSRETURN_UNDEF;
    s = modify ? (U8 *)SvPV_force_nomg(src, slen) : (U8 *)SvPV_nomg(src, slen);
    if (SvUTF8(src))
        utf8_safe_downgrade(aTHX_ &src, &s, &slen, modify);
    RETVAL = encode_method(aTHX_ enc, enc->t_utf8, src, s, slen, check,
              NULL, Nullsv, NULL, fallback_cb);
    SvUTF8_on(RETVAL);
#line 1122 "Encode.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode__XS_encode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode__XS_encode)
{
    dVAR; dXSARGS;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "obj, src, check_sv = &PL_sv_no");
    {
	SV *	obj = ST(0)
;
	SV *	src = ST(1)
;
	SV *	check_sv;
#line 856 "Encode.xs"
    IV check;
    SV *fallback_cb;
    bool modify;
    encode_t *enc;
    U8 *s;
    STRLEN slen;
#line 1149 "Encode.c"
	SV *	RETVAL;

	if (items < 3)
	    check_sv = &PL_sv_no;
	else {
	    check_sv = ST(2)
;
	}
#line 863 "Encode.xs"
    SvGETMAGIC(src);
    SvGETMAGIC(check_sv);
    check = SvROK(check_sv) ? ENCODE_PERLQQ|ENCODE_LEAVE_SRC : SvOK(check_sv) ? SvIV_nomg(check_sv) : 0;
    fallback_cb = SvROK(check_sv) ? check_sv : &PL_sv_undef;
    modify = (check && !(check & ENCODE_LEAVE_SRC));
    enc = INT2PTR(encode_t *, SvIV(SvRV(obj)));
#line 1165 "Encode.c"
#line 870 "Encode.xs"
    if (!SvOK(src))
        XSRETURN_UNDEF;
    s = modify ? (U8 *)SvPV_force_nomg(src, slen) : (U8 *)SvPV_nomg(src, slen);
    if (!SvUTF8(src))
        utf8_safe_upgrade(aTHX_ &src, &s, &slen, modify);
    RETVAL = encode_method(aTHX_ enc, enc->f_utf8, src, s, slen, check,
              NULL, Nullsv, NULL, fallback_cb);
#line 1174 "Encode.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode__XS_needs_lines); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode__XS_needs_lines)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	obj = ST(0)
;
	bool	RETVAL;
#line 884 "Encode.xs"
    PERL_UNUSED_VAR(obj);
    RETVAL = FALSE;
#line 1195 "Encode.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode__XS_perlio_ok); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode__XS_perlio_ok)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	obj = ST(0)
;
#line 893 "Encode.xs"
    SV *sv;
#line 1213 "Encode.c"
	bool	RETVAL;
#line 895 "Encode.xs"
    PERL_UNUSED_VAR(obj);
    sv = eval_pv("require PerlIO::encoding", 0);
    RETVAL = SvTRUE(sv);
#line 1219 "Encode.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode__XS_mime_name); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode__XS_mime_name)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "obj");
    {
	SV *	obj = ST(0)
;
#line 905 "Encode.xs"
    encode_t *enc;
#line 1237 "Encode.c"
	SV *	RETVAL;
#line 907 "Encode.xs"
    enc = INT2PTR(encode_t *, SvIV(SvRV(obj)));
#line 1241 "Encode.c"
#line 909 "Encode.xs"
    ENTER;
    SAVETMPS;
    PUSHMARK(sp);
    XPUSHs(sv_2mortal(newSVpvn(enc->name[0], strlen(enc->name[0]))));
    PUTBACK;
    call_pv("Encode::MIME::Name::get_mime_name", G_SCALAR);
    SPAGAIN;
    RETVAL = newSVsv(POPs);
    PUTBACK;
    FREETMPS;
    LEAVE;
#line 1254 "Encode.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode_is_utf8); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode_is_utf8)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "sv, check = 0");
    {
	SV *	sv = ST(0)
;
	int	check;
#line 932 "Encode.xs"
    char *str;
    STRLEN len;
#line 1275 "Encode.c"
	bool	RETVAL;

	if (items < 2)
	    check = 0;
	else {
	    check = (int)SvIV(ST(1))
;
	}
#line 935 "Encode.xs"
    SvGETMAGIC(sv); /* SvGETMAGIC() can modify SvOK flag */
    str = SvOK(sv) ? SvPV_nomg(sv, len) : NULL; /* SvPV() can modify SvUTF8 flag */
    RETVAL = SvUTF8(sv) ? TRUE : FALSE;
    if (RETVAL && check && (!str || !is_utf8_string((U8 *)str, len)))
        RETVAL = FALSE;
#line 1290 "Encode.c"
	ST(0) = boolSV(RETVAL);
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode__utf8_on); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode__utf8_on)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0)
;
	SV *	RETVAL;
#line 947 "Encode.xs"
    SvGETMAGIC(sv);
    if (!SvTAINTED(sv) && SvPOKp(sv)) {
        if (SvTHINKFIRST(sv)) sv_force_normal(sv);
        RETVAL = boolSV(SvUTF8(sv));
        SvUTF8_on(sv);
        SvSETMAGIC(sv);
    } else {
        RETVAL = &PL_sv_undef;
    }
#line 1317 "Encode.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode__utf8_off); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode__utf8_off)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "sv");
    {
	SV *	sv = ST(0)
;
	SV *	RETVAL;
#line 963 "Encode.xs"
    SvGETMAGIC(sv);
    if (!SvTAINTED(sv) && SvPOKp(sv)) {
        if (SvTHINKFIRST(sv)) sv_force_normal(sv);
        RETVAL = boolSV(SvUTF8(sv));
        SvUTF8_off(sv);
        SvSETMAGIC(sv);
    } else {
        RETVAL = &PL_sv_undef;
    }
#line 1345 "Encode.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode_decode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode_decode)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "encoding, octets, check = NULL");
    {
	SV *	encoding = ST(0)
;
	SV *	octets = ST(1)
;
	SV *	check;
#line 983 "Encode.xs"
    SV *obj;
#line 1368 "Encode.c"
	SV *	RETVAL;

	if (items < 3)
	    check = NULL;
	else {
	    check = ST(2)
;
	}
#line 985 "Encode.xs"
    SvGETMAGIC(encoding);
#line 1379 "Encode.c"
#line 987 "Encode.xs"
    if (!SvOK(encoding))
        croak("Encoding name should not be undef");
    obj = find_encoding(aTHX_ encoding);
    if (!SvOK(obj))
        croak("Unknown encoding '%" SVf "'", SVfARG(encoding));
    RETVAL = call_encoding(aTHX_ "decode", obj, octets, check);
#line 1387 "Encode.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode_encode); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode_encode)
{
    dVAR; dXSARGS;
    dXSI32;
    if (items < 2 || items > 3)
       croak_xs_usage(cv,  "encoding, string, check = NULL");
    {
	SV *	encoding = ST(0)
;
	SV *	string = ST(1)
;
	SV *	check;
#line 1004 "Encode.xs"
    SV *obj;
#line 1410 "Encode.c"
	SV *	RETVAL;

	if (items < 3)
	    check = NULL;
	else {
	    check = ST(2)
;
	}
#line 1006 "Encode.xs"
    SvGETMAGIC(encoding);
#line 1421 "Encode.c"
#line 1008 "Encode.xs"
    if (!SvOK(encoding))
        croak("Encoding name should not be undef");
    obj = find_encoding(aTHX_ encoding);
    if (!SvOK(obj))
        croak("Unknown encoding '%" SVf "'", SVfARG(encoding));
    RETVAL = call_encoding(aTHX_ "encode", obj, string, check);
#line 1429 "Encode.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode_decode_utf8); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode_decode_utf8)
{
    dVAR; dXSARGS;
    if (items < 1 || items > 2)
       croak_xs_usage(cv,  "octets, check = NULL");
    {
	SV *	octets = ST(0)
;
	SV *	check;
#line 1022 "Encode.xs"
    HV *hv;
    SV **sv;
#line 1450 "Encode.c"
	SV *	RETVAL;

	if (items < 2)
	    check = NULL;
	else {
	    check = ST(1)
;
	}
#line 1025 "Encode.xs"
    hv = get_hv("Encode::Encoding", 0);
    if (!hv)
        croak("utf8 encoding was not found");
    sv = hv_fetch(hv, "utf8", 4, 0);
    if (!sv || !*sv || !SvOK(*sv))
        croak("utf8 encoding was not found");
    RETVAL = call_encoding(aTHX_ "decode", *sv, octets, check);
#line 1467 "Encode.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode_encode_utf8); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode_encode_utf8)
{
    dVAR; dXSARGS;
    if (items != 1)
       croak_xs_usage(cv,  "string");
    {
	SV *	string = ST(0)
;
	SV *	RETVAL;
#line 1039 "Encode.xs"
    RETVAL = newSVsv(string);
    if (SvOK(RETVAL))
        sv_utf8_encode(RETVAL);
#line 1489 "Encode.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode_from_to); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode_from_to)
{
    dVAR; dXSARGS;
    if (items < 3 || items > 4)
       croak_xs_usage(cv,  "octets, from, to, check = NULL");
    {
	SV *	octets = ST(0)
;
	SV *	from = ST(1)
;
	SV *	to = ST(2)
;
	SV *	check;
#line 1052 "Encode.xs"
    SV *from_obj;
    SV *to_obj;
    SV *string;
    SV *new_octets;
    U8 *ptr;
    STRLEN len;
#line 1518 "Encode.c"
	SV *	RETVAL;

	if (items < 4)
	    check = NULL;
	else {
	    check = ST(3)
;
	}
#line 1059 "Encode.xs"
    SvGETMAGIC(from);
    SvGETMAGIC(to);
#line 1530 "Encode.c"
#line 1062 "Encode.xs"
    if (!SvOK(from) || !SvOK(to))
        croak("Encoding name should not be undef");
    from_obj = find_encoding(aTHX_ from);
    if (!SvOK(from_obj))
        croak("Unknown encoding '%" SVf "'", SVfARG(from));
    to_obj = find_encoding(aTHX_ to);
    if (!SvOK(to_obj))
        croak("Unknown encoding '%" SVf "'", SVfARG(to));
    string = sv_2mortal(call_encoding(aTHX_ "decode", from_obj, octets, NULL));
    new_octets = sv_2mortal(call_encoding(aTHX_ "encode", to_obj, string, check));
    SvGETMAGIC(new_octets);
    if (SvOK(new_octets) && (!check || SvROK(check) || !SvTRUE_nomg(check) || sv_len(string) == 0)) {
        ptr = (U8 *)SvPV_nomg(new_octets, len);
        if (SvUTF8(new_octets))
            len = utf8_length(ptr, ptr+len);
        RETVAL = newSVuv(len);
    } else {
        RETVAL = &PL_sv_undef;
    }
    sv_setsv_nomg(octets, new_octets);
    SvSETMAGIC(octets);
#line 1553 "Encode.c"
	RETVAL = sv_2mortal(RETVAL);
	ST(0) = RETVAL;
    }
    XSRETURN(1);
}


XS_EUPXS(XS_Encode_onBOOT); /* prototype to pass -Wmissing-prototypes */
XS_EUPXS(XS_Encode_onBOOT)
{
    dVAR; dXSARGS;
    if (items != 0)
       croak_xs_usage(cv,  "");
    {
#line 1089 "Encode.xs"
{
#include "def_t.exh"
}
#line 1572 "Encode.c"
    }
    XSRETURN_EMPTY;
}

#ifdef __cplusplus
extern "C"
#endif
XS_EXTERNAL(boot_Encode); /* prototype to pass -Wmissing-prototypes */
XS_EXTERNAL(boot_Encode)
{
#if PERL_VERSION_LE(5, 21, 5)
    dVAR; dXSARGS;
#else
    dVAR; dXSBOOTARGSXSAPIVERCHK;
#endif
#if (PERL_REVISION == 5 && PERL_VERSION < 9)
    char* file = __FILE__;
#else
    const char* file = __FILE__;
#endif

    PERL_UNUSED_VAR(file);

    PERL_UNUSED_VAR(cv); /* -W */
    PERL_UNUSED_VAR(items); /* -W */
#if PERL_VERSION_LE(5, 21, 5)
    XS_VERSION_BOOTCHECK;
#  ifdef XS_APIVERSION_BOOTCHECK
    XS_APIVERSION_BOOTCHECK;
#  endif
#endif

        newXS_deffile("Encode::utf8::decode", XS_Encode__utf8_decode);
        newXS_deffile("Encode::utf8::encode", XS_Encode__utf8_encode);
        newXS_deffile("Encode::XS::renew", XS_Encode__XS_renew);
        newXS_deffile("Encode::XS::renewed", XS_Encode__XS_renewed);
        newXS_deffile("Encode::XS::name", XS_Encode__XS_name);
        newXS_deffile("Encode::XS::cat_decode", XS_Encode__XS_cat_decode);
        newXS_deffile("Encode::XS::decode", XS_Encode__XS_decode);
        newXS_deffile("Encode::XS::encode", XS_Encode__XS_encode);
        newXS_deffile("Encode::XS::needs_lines", XS_Encode__XS_needs_lines);
        newXS_deffile("Encode::XS::perlio_ok", XS_Encode__XS_perlio_ok);
        newXS_deffile("Encode::XS::mime_name", XS_Encode__XS_mime_name);
        (void)newXSproto_portable("Encode::is_utf8", XS_Encode_is_utf8, file, "$;$");
        (void)newXSproto_portable("Encode::_utf8_on", XS_Encode__utf8_on, file, "$");
        (void)newXSproto_portable("Encode::_utf8_off", XS_Encode__utf8_off, file, "$");
        cv = newXSproto_portable("Encode::bytes2str", XS_Encode_decode, file, "$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("Encode::decode", XS_Encode_decode, file, "$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("Encode::encode", XS_Encode_encode, file, "$$;$");
        XSANY.any_i32 = 0;
        cv = newXSproto_portable("Encode::str2bytes", XS_Encode_encode, file, "$$;$");
        XSANY.any_i32 = 0;
        (void)newXSproto_portable("Encode::decode_utf8", XS_Encode_decode_utf8, file, "$;$");
        (void)newXSproto_portable("Encode::encode_utf8", XS_Encode_encode_utf8, file, "$");
        (void)newXSproto_portable("Encode::from_to", XS_Encode_from_to, file, "$$$;$");
        (void)newXSproto_portable("Encode::onBOOT", XS_Encode_onBOOT, file, "");

    /* Initialisation Section */

#line 1094 "Encode.xs"
{
    HV *stash = gv_stashpvn("Encode", (U32)strlen("Encode"), GV_ADD);
    newCONSTSUB(stash, "DIE_ON_ERR", newSViv(ENCODE_DIE_ON_ERR));
    newCONSTSUB(stash, "WARN_ON_ERR", newSViv(ENCODE_WARN_ON_ERR));
    newCONSTSUB(stash, "RETURN_ON_ERR", newSViv(ENCODE_RETURN_ON_ERR));
    newCONSTSUB(stash, "LEAVE_SRC", newSViv(ENCODE_LEAVE_SRC));
    newCONSTSUB(stash, "ONLY_PRAGMA_WARNINGS", newSViv(ENCODE_ONLY_PRAGMA_WARNINGS));
    newCONSTSUB(stash, "PERLQQ", newSViv(ENCODE_PERLQQ));
    newCONSTSUB(stash, "HTMLCREF", newSViv(ENCODE_HTMLCREF));
    newCONSTSUB(stash, "XMLCREF", newSViv(ENCODE_XMLCREF));
    newCONSTSUB(stash, "STOP_AT_PARTIAL", newSViv(ENCODE_STOP_AT_PARTIAL));
    newCONSTSUB(stash, "FB_DEFAULT", newSViv(ENCODE_FB_DEFAULT));
    newCONSTSUB(stash, "FB_CROAK", newSViv(ENCODE_FB_CROAK));
    newCONSTSUB(stash, "FB_QUIET", newSViv(ENCODE_FB_QUIET));
    newCONSTSUB(stash, "FB_WARN", newSViv(ENCODE_FB_WARN));
    newCONSTSUB(stash, "FB_PERLQQ", newSViv(ENCODE_FB_PERLQQ));
    newCONSTSUB(stash, "FB_HTMLCREF", newSViv(ENCODE_FB_HTMLCREF));
    newCONSTSUB(stash, "FB_XMLCREF", newSViv(ENCODE_FB_XMLCREF));
}

#line 1655 "Encode.c"

    /* End of Initialisation Section */

#if PERL_VERSION_LE(5, 21, 5)
#  if PERL_VERSION_GE(5, 9, 0)
    if (PL_unitcheckav)
        call_list(PL_scopestack_ix, PL_unitcheckav);
#  endif
    XSRETURN_YES;
#else
    Perl_xs_boot_epilog(aTHX_ ax);
#endif
}

