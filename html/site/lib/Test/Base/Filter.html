<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../tocTab.js"></script>
<title></title>
<link rel="stylesheet" href="../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#FILTERS">FILTERS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Test::Base::Filter - Default Filter Class for Test::Base</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>      package MyTestSuite;
      use Test::Base -Base;

      ... reusable testing code ...

      package MyTestSuite::Filter;
      use Test::Base::Filter -Base;

      sub my_filter1 {
          ...
      }</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>Filters are the key to writing effective data driven tests with Test::Base. Test::Base::Filter is a class containing a large default set of generic filters. You can easily subclass it to add/override functionality.</p>

<h1 id="FILTERS">FILTERS</h1>

<p>This is a list of the default stock filters (in alphabetic order):</p>

<dl>

<dt id="append"><code>append</code></dt>
<dd>

<p>list =&gt; list</p>

<p>Append a string to each element of a list.</p>

<pre><code>    --- numbers lines chomp append=-#\n join
    one
    two
    three</code></pre>

</dd>
<dt id="array"><code>array</code></dt>
<dd>

<p>list =&gt; scalar</p>

<p>Turn a list of values into an anonymous array reference.</p>

</dd>
<dt id="base64_decode"><code>base64_decode</code></dt>
<dd>

<p>scalar =&gt; scalar</p>

<p>Decode base64 data. Useful for binary tests.</p>

</dd>
<dt id="base64_encode"><code>base64_encode</code></dt>
<dd>

<p>scalar =&gt; scalar</p>

<p>Encode base64 data. Useful for binary tests.</p>

</dd>
<dt id="chomp"><code>chomp</code></dt>
<dd>

<p>list =&gt; list</p>

<p>Remove the final newline from each string value in a list.</p>

</dd>
<dt id="chop"><code>chop</code></dt>
<dd>

</dd>
</dl>

<p>list =&gt; list</p>

<pre><code>    Remove the final char from each string value in a list.</code></pre>

<dl>

<dt id="dumper"><code>dumper</code></dt>
<dd>

<p>scalar =&gt; list</p>

<p>Take a data structure (presumably from another filter like eval) and use Data::Dumper to dump it in a canonical fashion.</p>

</dd>
<dt id="escape"><code>escape</code></dt>
<dd>

<p>scalar =&gt; scalar</p>

<p>Unescape all backslash escaped chars.</p>

</dd>
<dt id="eval"><code>eval</code></dt>
<dd>

<p>scalar =&gt; list</p>

<p>Run Perl&#39;s <code>eval</code> command against the data and use the returned value as the data.</p>

</dd>
<dt id="eval_all"><code>eval_all</code></dt>
<dd>

<p>scalar =&gt; list</p>

<p>Run Perl&#39;s <code>eval</code> command against the data and return a list of 4 values:</p>

<pre><code>    1) The return value
    2) The error in $@
    3) Captured STDOUT
    4) Captured STDERR</code></pre>

</dd>
<dt id="eval_stderr"><code>eval_stderr</code></dt>
<dd>

<p>scalar =&gt; scalar</p>

<p>Run Perl&#39;s <code>eval</code> command against the data and return the captured STDERR.</p>

</dd>
<dt id="eval_stdout"><code>eval_stdout</code></dt>
<dd>

<p>scalar =&gt; scalar</p>

<p>Run Perl&#39;s <code>eval</code> command against the data and return the captured STDOUT.</p>

</dd>
<dt id="exec_perl_stdout"><code>exec_perl_stdout</code></dt>
<dd>

<p>list =&gt; scalar</p>

<p>Input Perl code is written to a temp file and run. STDOUT is captured and returned.</p>

</dd>
<dt id="flatten"><code>flatten</code></dt>
<dd>

<p>scalar =&gt; list</p>

<p>Takes a hash or array ref and flattens it to a list.</p>

</dd>
<dt id="get_url"><code>get_url</code></dt>
<dd>

<p>scalar =&gt; scalar</p>

<p>The text is chomped and considered to be a url. Then LWP::Simple::get is used to fetch the contents of the url.</p>

</dd>
<dt id="hash"><code>hash</code></dt>
<dd>

<p>list =&gt; scalar</p>

<p>Turn a list of key/value pairs into an anonymous hash reference.</p>

</dd>
<dt id="head-number"><code>head[=number]</code></dt>
<dd>

<p>list =&gt; list</p>

<p>Takes a list and returns a number of the elements from the front of it. The default number is one.</p>

</dd>
<dt id="join"><code>join</code></dt>
<dd>

<p>list =&gt; scalar</p>

<p>Join a list of strings into a scalar.</p>

</dd>
<dt id="Join"><code>Join</code></dt>
<dd>

<p>Join the list of strings inside a list of array refs and return the strings in place of the array refs.</p>

</dd>
<dt id="lines"><code>lines</code></dt>
<dd>

<p>scalar =&gt; list</p>

<p>Break the data into an anonymous array of lines. Each line (except possibly the last one if the <code>chomp</code> filter came first) will have a newline at the end.</p>

</dd>
<dt id="norm"><code>norm</code></dt>
<dd>

<p>scalar =&gt; scalar</p>

<p>Normalize the data. Change non-Unix line endings to Unix line endings.</p>

</dd>
<dt id="prepend-string"><code>prepend=string</code></dt>
<dd>

<p>list =&gt; list</p>

<p>Prepend a string onto each of a list of strings.</p>

</dd>
<dt id="read_file"><code>read_file</code></dt>
<dd>

<p>scalar =&gt; scalar</p>

<p>Read the file named by the current content and return the file&#39;s content.</p>

</dd>
<dt id="regexp-xism"><code>regexp[=xism]</code></dt>
<dd>

<p>scalar =&gt; scalar</p>

<p>The <code>regexp</code> filter will turn your data section into a regular expression object. You can pass in extra flags after an equals sign.</p>

<p>If the text contains more than one line and no flags are specified, then the &#39;xism&#39; flags are assumed.</p>

</dd>
<dt id="reverse"><code>reverse</code></dt>
<dd>

<p>list =&gt; list</p>

<p>Reverse the elements of a list.</p>

</dd>
<dt id="Reverse"><code>Reverse</code></dt>
<dd>

<p>list =&gt; list</p>

<p>Reverse the list of strings inside a list of array refs.</p>

</dd>
<dt id="slice-x-y"><code>slice=x[,y]</code></dt>
<dd>

<p>list =&gt; list</p>

<p>Returns the element number x through element number y of a list.</p>

</dd>
<dt id="sort"><code>sort</code></dt>
<dd>

<p>list =&gt; list</p>

<p>Sorts the elements of a list in character sort order.</p>

</dd>
<dt id="Sort"><code>Sort</code></dt>
<dd>

<p>list =&gt; list</p>

<p>Sort the list of strings inside a list of array refs.</p>

</dd>
<dt id="split-string-pattern"><code>split[=string|pattern]</code></dt>
<dd>

<p>scalar =&gt; list</p>

<p>Split a string in into a list. Takes a optional string or regexp as a parameter. Defaults to <i>s+</i>. Same as Perl <code>split</code>.</p>

</dd>
<dt id="Split-string-pattern"><code>Split[=string|pattern]</code></dt>
<dd>

<p>list =&gt; list</p>

<p>Split each of a list of strings and turn them into array refs.</p>

</dd>
<dt id="strict"><code>strict</code></dt>
<dd>

<p>scalar =&gt; scalar</p>

<p>Prepend the string:</p>

<pre><code>    use strict;
    use warnings;</code></pre>

<p>to the block&#39;s text.</p>

</dd>
<dt id="tail-number"><code>tail[=number]</code></dt>
<dd>

<p>list =&gt; list</p>

<p>Return a number of elements from the end of a list. The default number is one.</p>

</dd>
<dt id="trim"><code>trim</code></dt>
<dd>

<p>list =&gt; list</p>

<p>Remove extra blank lines from the beginning and end of the data. This allows you to visually separate your test data with blank lines.</p>

</dd>
<dt id="unchomp"><code>unchomp</code></dt>
<dd>

<p>list =&gt; list</p>

<p>Add a newline to each string value in a list.</p>

</dd>
<dt id="write_file-filename"><code>write_file[=filename]</code></dt>
<dd>

<p>scalar =&gt; scalar</p>

<p>Write the content of the section to the named file. Return the filename.</p>

</dd>
<dt id="yaml"><code>yaml</code></dt>
<dd>

<p>scalar =&gt; list</p>

<p>Apply the YAML::Load function to the data block and use the resultant structure. Requires YAML.pm.</p>

</dd>
</dl>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Ingy d&ouml;t Net &lt;ingy@cpan.org&gt;</p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright 2005-2018. Ingy d&ouml;t Net. All rights reserved.</p>

<p>This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<p>See <a href="http://www.perl.com/perl/misc/Artistic.html">http://www.perl.com/perl/misc/Artistic.html</a></p>


</body>

</html>


