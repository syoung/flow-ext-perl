<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#Introduction-to-Coro">Introduction to Coro</a></li>
  <li><a href="#What-is-Coro">What is Coro?</a></li>
  <li><a href="#Cooperative-Threads">Cooperative Threads</a>
    <ul>
      <li><a href="#Semaphores-and-other-locks">Semaphores and other locks</a></li>
      <li><a href="#Channels">Channels</a></li>
      <li><a href="#What-is-mine-what-is-ours">What is mine, what is ours?</a></li>
      <li><a href="#Debugging">Debugging</a></li>
    </ul>
  </li>
  <li><a href="#The-Real-World---Event-Loops">The Real World - Event Loops</a>
    <ul>
      <li><a href="#The-Real-World---File-I-O">The Real World - File I/O</a></li>
      <li><a href="#Inversion-of-control---rouse-functions">Inversion of control - rouse functions</a></li>
    </ul>
  </li>
  <li><a href="#Other-Modules">Other Modules</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="Introduction-to-Coro">Introduction to Coro</h1>

<p>This tutorial will introduce you to the main features of the Coro module family.</p>

<p>It first introduces some basic concepts, and later gives a short overview of the module family.</p>

<h1 id="What-is-Coro">What is Coro?</h1>

<p>Coro started as a simple module that implemented a specific form of first class continuations called Coroutines. These basically allow you to capture the current point execution and jump to another point, while allowing you to return at any time, as kind of non-local jump, not unlike C&#39;s <code>setjmp</code>/<code>longjmp</code>. This is nowadays known as a <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/State.html">Coro::State</a>.</p>

<p>One natural application for these is to include a scheduler, resulting in cooperative threads, which is the main use case for Coro today. Still, much of the documentation and custom refers to these threads as &quot;coroutines&quot; or often just &quot;coros&quot;.</p>

<p>A thread is very much like a stripped-down perl interpreter, or a process: Unlike a full interpreter process, a thread doesn&#39;t have its own variable or code namespaces - everything is shared. That means that when one thread modifies a variable (or any value, e.g. through a reference), then other threads immediately see this change when they look at the same variable or location.</p>

<p>Cooperative means that these threads must cooperate with each other, when it comes to CPU usage - only one thread ever has the CPU, and if another thread wants the CPU, the running thread has to give it up. The latter is either explicitly, by calling a function to do so, or implicitly, when waiting on a resource (such as a Semaphore, or the completion of some I/O request). This threading model is popular in scripting languages (such as python or ruby), and this implementation is typically far more efficient than threads implemented in other languages.</p>

<p>Perl itself uses rather confusing terminilogy - what perl calls a &quot;thread&quot; (or &quot;ithread&quot;) is actually called a &quot;process&quot; everywhere else: The so-called &quot;perl threads&quot; are actually artifacts of the unix process emulation code used on Windows, which is consequently why they are actually processes and not threads. The biggest difference is that neither variables (nor code) are shared between processes or ithreads.</p>

<h1 id="Cooperative-Threads">Cooperative Threads</h1>

<p>Cooperative threads is what the Coro module gives you. Obviously, you have to <code>use</code> it first:</p>

<pre><code>   use Coro;</code></pre>

<p>To create a thread, you can use the <code>async</code> function that automatically gets exported from that module:</p>

<pre><code>   async {
      print &quot;hello\n&quot;;
   };</code></pre>

<p>Async expects a code block as first argument (in indirect object notation). You can actually pass it extra arguments, and these will end up in <code>@_</code> when executing the codeblock, but since it is a closure, you can also just refer to any lexical variables that are currently visible.</p>

<p>The above lines create a thread, but if you save them in a file and execute it as a perl program, you will not get any output.</p>

<p>The reasons is that, although you created a thread, and the thread is ready to execute (because <code>async</code> puts it into the so-called <i>ready queue</i>), it never gets any CPU time to actually execute, as the main program - which also is a thread almost like any other - never gives up the CPU but instead exits the whole program, by running off the end of the file. Since Coro threads are cooperative, the main thread has to cooperate, and give up the CPU.</p>

<p>To explicitly give up the CPU, use the <code>cede</code> function (which is often called <code>yield</code> in other thread implementations):</p>

<pre><code>   use Coro;

   async {
      print &quot;hello\n&quot;;
   };

   cede;</code></pre>

<p>Running the above prints <code>hello</code> and exits.</p>

<p>Now, this is not very interesting, so let&#39;s try a slightly more interesting program:</p>

<pre><code>   use Coro;

   async {
      print &quot;async 1\n&quot;;
      cede;
      print &quot;async 2\n&quot;;
   };

   print &quot;main 1\n&quot;;
   cede;
   print &quot;main 2\n&quot;;
   cede;</code></pre>

<p>Running this program prints:</p>

<pre><code>   main 1
   async 1
   main 2
   async 2</code></pre>

<p>This nicely illustrates the non-local jump ability: the main program prints the first line, and then yields the CPU to whatever other threads there are. And there is one other, which runs and prints &quot;async 1&quot;, and itself yields the CPU. Since the only other thread available is the main program, it continues running and so on.</p>

<p>Let&#39;s look at the example in more detail: <code>async</code> first creates a new thread. All new threads start in a suspended state. To make them run, they need to be put into the ready queue, which is the second thing that <code>async</code> does. Each time a thread gives up the CPU, Coro runs a so-called <i>scheduler</i>. The scheduler selects the next thread from the ready queue, removes it from the queue, and runs it.</p>

<p><code>cede</code> also does two things: first it puts the running thread into the ready queue, and then it jumps into the scheduler. This has the effect of giving up the CPU, but also ensures that, eventually, the thread gets run again.</p>

<p>In fact, <code>cede</code> could be implemented like this:</p>

<pre><code>   sub my_cede {
      $Coro::current-&gt;ready;
      schedule;
   }</code></pre>

<p>This works because <code>$Coro::current</code> always contains the currently running thread, and the scheduler itself can be called directly via <code>Coro::schedule</code>.</p>

<p>What is the effect of just calling <code>schedule</code> without putting the current thread into the ready queue first? Simple: the scheduler selects the next ready thread and runs it. And the current thread, as it hasn&#39;t been put into the ready queue, will go to sleep until something wakes it up. If. Ever.</p>

<p>The following example remembers the current thread in a variable, creates a thread and then puts the main program to sleep.</p>

<p>The newly created thread uses rand to wake up the main thread by calling its <code>ready</code> method - or not.</p>

<pre><code>   use Coro;

   my $wakeme = $Coro::current;

   async {
      $wakeme-&gt;ready if 0.5 &gt; rand;
   };

   schedule;</code></pre>

<p>Now, when you run it, one of two things happen: Either the <code>async</code> thread wakes up the main thread again, in which case the program silently exits, or it doesn&#39;t, in which case you get something like this:</p>

<pre><code>   FATAL: deadlock detected.
         PID SC  RSS USES Description              Where
    31976480 -C  19k    0 [main::]                 [program:9]
    32223768 UC  12k    1                          [Coro.pm:691]
    32225088 -- 2068    1 [coro manager]           [Coro.pm:691]
    32225184 N-  216    0 [unblock_sub scheduler]  -</code></pre>

<p>Why is that? Well, when the <code>async</code> thread runs into the end of its block, it will be terminated (via a call to <code>Coro::terminate</code>) and the scheduler is called again. Since the <code>async</code> thread hasn&#39;t woken up the main thread, and there aren&#39;t any other threads, there is nothing to wake up, and the program cannot continue. Since there <i>are</i> threads that <i>could</i> be running (main) but none are <i>ready</i> to do so, Coro signals a <i>deadlock</i> - no progress is possible. Usually you also get a listing of all threads, which might help you track down the problem.</p>

<p>However, there is an important case where progress <i>is</i>, in fact, possible, despite no threads being ready - namely in an event-based program. In such a program, some threads could wait for <i>external</i> events, such as a timeout, or some data to arrive on a socket.</p>

<p>Since a deadlock in such a case would not be very useful, there is a module named <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/AnyEvent.html">Coro::AnyEvent</a> that integrates threads into an event loop. It configures Coro in a way that, instead of <code>die</code>ing with an error message, it instead runs the event loop in the hope of receiving an event that will wake up some thread.</p>

<h2 id="Semaphores-and-other-locks">Semaphores and other locks</h2>

<p>Using only <code>ready</code>, <code>cede</code> and <code>schedule</code> to synchronise threads is difficult, especially if many threads are ready at the same time. Coro supports a number of primitives to help synchronising threads in easier ways. The first such primitives is <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/Semaphore.html">Coro::Semaphore</a>, which implements counting semaphores (binary semaphores are available as <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/Signal.html">Coro::Signal</a>, and there are <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/SemaphoreSet.html">Coro::SemaphoreSet</a> and <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/RWLock.html">Coro::RWLock</a> primitives as well).</p>

<p>Counting semaphores, in a sense, store a count of resources. You can remove/allocate/reserve a resource by calling the <code>-&gt;down</code> method, which decrements the counter, and you can add or free a resource by calling the <code>-&gt;up</code> method, which increments the counter. If the counter is <code>0</code>, then <code>-&gt;down</code> cannot decrement the semaphore - it is locked - and the thread will wait until a count becomes available again.</p>

<p>Here is an example:</p>

<pre><code>   use Coro;

   my $sem = new Coro::Semaphore 0; # a locked semaphore

   async {
      print &quot;unlocking semaphore\n&quot;;
      $sem-&gt;up;
   };

   print &quot;trying to lock semaphore\n&quot;;
   $sem-&gt;down;
   print &quot;we got it!\n&quot;;</code></pre>

<p>This program creates a <i>locked</i> semaphore (a semaphore with count <code>0</code>) and tries to lock it (by trying to decrement it&#39;s counter in the <code>down</code> method). Since the semaphore count is already exhausted, this will block the main thread until the semaphore becomes available.</p>

<p>This yields the CPU to the only other read thread in the process,t he one created with <code>async</code>, which unlocks the semaphore (and instantly terminates itself by returning).</p>

<p>Since the semaphore is now available, the main program locks it and continues: &quot;we got it!&quot;.</p>

<p>Counting semaphores are most often used to lock resources, or to exclude other threads from accessing or using a resource. For example, consider a very costly function (that temporarily allocates a lot of ram, for example). You wouldn&#39;t want to have many threads calling this function at the same time, so you use a semaphore:</p>

<pre><code>   my $lock = new Coro::Semaphore; # unlocked initially - default is 1

   sub costly_function {
      $lock-&gt;down; # acquire semaphore

      # do costly operation that blocks

      $lock-&gt;up; # unlock it
   }</code></pre>

<p>No matter how many threads call <code>costly_function</code>, only one will run the body of it, all others will wait in the <code>down</code> call. If you want to limit the number of concurrent executions to five, you could create the semaphore with an initial count of <code>5</code>.</p>

<p>Why does the comment mention an &quot;operation the blocks&quot;? Again, that&#39;s because coro&#39;s threads are cooperative: unless <code>costly_function</code> willingly gives up the CPU, other threads of control will simply not run. This makes locking superfluous in cases where the function itself never gives up the CPU, but when dealing with the outside world, this is rare.</p>

<p>Now consider what happens when the code <code>die</code>s after executing <code>down</code>, but before <code>up</code>. This will leave the semaphore in a locked state, which often isn&#39;t what you want - imagine the caller expecting a failure and wrapping the call into an <code>eval {}</code>.</p>

<p>So normally you would want to free the lock again if execution somehow leaves the function, whether &quot;normally&quot; or via an exception. Here the <code>guard</code> method proves useful:</p>

<pre><code>   my $lock = new Coro::Semaphore; # unlocked initially

   sub costly_function {
      my $guard = $lock-&gt;guard; # acquire guard

      # do costly operation that blocks
   }</code></pre>

<p>The <code>guard</code> method <code>down</code>s the semaphore and returns a so-called guard object. Nothing happens as long as there are references to it (i.e. it is in scope somehow), but when all references are gone, for example, when <code>costly_function</code> returns or throws an exception, it will automatically call <code>up</code> on the semaphore, no way to forget it. Even when the thread gets <code>cancel</code>ed by another thread will the guard object ensure that the lock is freed.</p>

<p>This concludes this introduction to semaphores and locks. Apart from <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/Semaphore.html">Coro::Semaphore</a> and <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/Signal.html">Coro::Signal</a>, there is also a reader-writer lock (<a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/RWLock.html">Coro::RWLock</a>) and a semaphore set (<a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/SemaphoreSet.html">Coro::SemaphoreSet</a>). All of these come with their own manpage.</p>

<h2 id="Channels">Channels</h2>

<p>Semaphores are fine, but usually you want to communicate by exchanging data as well. Of course, you can just use some locks, and array of sorts and use that to communicate, but there is a useful abstraction for communicaiton between threads: <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/Channel.html">Coro::Channel</a>. Channels are the Coro equivalent of a unix pipe (and very similar to AmigaOS message ports :) - you can put stuff into it on one side, and read data from it on the other.</p>

<p>Here is a simple example that creates a thread and sends numbers to it. The thread calculates the square of each number and puts that into another channel, which the main thread reads the result from:</p>

<pre><code>   use Coro;

   my $calculate = new Coro::Channel;
   my $result    = new Coro::Channel;

   async {
      # endless loop
      while () {
         my $num = $calculate-&gt;get; # read a number
         $num **= 2; # square it
         $result-&gt;put ($num); # put the result into the result queue
      }
   };

   for (1, 2, 5, 10, 77) {
      $calculate-&gt;put ($_);
      print &quot;$_ ** 2 = &quot;, $result-&gt;get, &quot;\n&quot;;
   }</code></pre>

<p>Gives:</p>

<pre><code>   1 ** 2 = 1
   2 ** 2 = 4
   5 ** 2 = 25
   10 ** 2 = 100
   77 ** 2 = 5929</code></pre>

<p>Both <code>get</code> and <code>put</code> methods can block the current thread: <code>get</code> first checks whether there <i>is</i> some data available, and if not, it block the current thread until some data arrives. <code>put</code> can also block, as each Channel has a &quot;maximum item capacity&quot;, i.e. you cannot store more than a specific number of items, which can be configured when the Channel gets created.</p>

<p>In the above example, <code>put</code> never blocks, as the default capacity of a Channel is very high. So the for loop first puts data into the channel, then tries to <code>get</code> the result. Since the async thread hasn&#39;t put anything in there yet (on the first iteration it hasn&#39;t even run yet), the result Channel is still empty, so the main thread blocks.</p>

<p>Since the only other runnable/ready thread at this point is the squaring thread, it will be woken up, will <code>get</code> the number, square it and put it into the result channel, waking up the main thread again. It will still continue to run, as waking up other threads just puts them into the ready queue, nothing less, nothing more.</p>

<p>Only when the async thread tries to <code>get</code> the next number from the calculate channel will it block (because nothing is there yet) and the main thread will continue running. And so on.</p>

<p>This illustrates a general principle used by Coro: a thread will <i>only ever block</i> when it has to. Neither the Coro module itself nor any of its submodules will ever give up the CPU unless they have to, because they wait for some event to happen.</p>

<p>Be careful, however: when multiple threads put numbers into <code>$calculate</code> and read from <code>$result</code>, they won&#39;t know which result is theirs. The solution for this is to either use a semaphore, or send not just the number, but also your own private result channel.</p>

<h2 id="What-is-mine-what-is-ours">What is mine, what is ours?</h2>

<p>What, exactly, constitutes a thread? Obviously it contains the current point of execution. Not so obviously, it also has to include all lexical variables, that means, every thread has its own set of lexical variables.</p>

<p>To see why this is necessary, consider this program:</p>

<pre><code>   use Coro;

   sub printit {
      my ($string) = @_;

      cede;

      print $string;
   }

   async { printit &quot;Hello, &quot; };
   async { printit &quot;World!\n&quot; };

   cede; cede; # do it</code></pre>

<p>The above prints <code>Hello, World!\n</code>. If <code>printit</code> wouldn&#39;t have its own per-thread <code>$string</code> variable, it would probably print <code>World!\nWorld\n</code>, which is rather unexpected, and would make it very difficult to make good use of threads.</p>

<p>To make things run smoothly, there are quite a number of other things that are per-thread:</p>

<dl>

<dt id="and-the-regex-result-vars-1-2">$_, @_, $@ and the regex result vars, $&amp;, %+, $1, $2, ...</dt>
<dd>

<p><code>$_</code> is used much like a local variable, so it gets localised per-thread. The same is true for regex results (<code>$1</code>, <code>$2</code> and so on).</p>

<p><code>@_</code> contains the arguments, so like lexicals, it also must be per-thread.</p>

<p><code>$@</code> is not obviously required to be per-thread, but it is quite useful.</p>

</dd>
<dt id="and-the-default-output-file-handle">$/ and the default output file handle</dt>
<dd>

<p>Threads most often block when doing I/O. Since <code>$/</code> is used when reading lines, it would be very inconvenient if it were a shared variable, so it is per-thread.</p>

<p>The default output handle (see <code>select</code>) is a difficult case: sometimes being global is preferable, sometimes per-thread is preferable. Since per-thread seems to be more common, it is per-thread.</p>

</dd>
<dt id="SIG-__DIE__-and-SIG-__WARN__">$SIG{__DIE__} and $SIG{__WARN__}</dt>
<dd>

<p>If these weren&#39;t per-thread, then common constructs such as:</p>

<pre><code>   eval {
      local $SIG{__DIE__} = sub { ... };
      ...
   };</code></pre>

<p>Would not allow coroutine switching. Since exception-handling is per-thread, those variables should be per-thread as well.</p>

</dd>
<dt id="Lots-of-other-esoteric-stuff">Lots of other esoteric stuff</dt>
<dd>

<p>For example, <code>$^H</code> is per-thread. Most of the additional per-thread state is not directly visible to Perl, but required to make the interpreter work. You won&#39;t normally notice these.</p>

</dd>
</dl>

<p>Everything else is shared between all threads. For example, the globals <code>$a</code> and <code>$b</code> are shared. When does that matter? When using <code>sort</code>, these variables become special, and therefore, switching threads when sorting might have surprising results.</p>

<p>Other examples are the <code>$!</code>, errno, <code>$.</code>, the current input line number, <code>$,</code>, <code>$\</code>, <code>$&quot;</code> and many other special variables.</p>

<p>While in some cases a good argument could be made for localising them to the thread, they are rarely used, and sometimes hard to localise.</p>

<p>Future versions of Coro might include more per-thread state when it becomes a problem.</p>

<h2 id="Debugging">Debugging</h2>

<p>Sometimes it can be useful to find out what each thread is doing (or which threads exist in the first place). The <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/Debug.html">Coro::Debug</a> module has (among other goodies), a function that allows you to print a &quot;ps&quot;-like listing - you have seen it in action earlier when Coro detected a deadlock.</p>

<p>You use it like this:</p>

<pre><code>   use Coro::Debug;

   Coro::Debug::command &quot;ps&quot;;</code></pre>

<p>Remember the example with the two channels and a worker thread that squared numbers? Running &quot;ps&quot; just after <code>$calculate-&gt;get</code> outputs something similar to this:</p>

<pre><code>        PID SC  RSS USES Description              Where
    8917312 -C  22k    0 [main::]                 [introscript:20]
    8964448 N-  152    0 [coro manager]           -
    8964520 N-  152    0 [unblock_sub scheduler]  -
    8591752 UC  152    1                          [introscript:12]
   11546944 N-  152    0 [EV idle process]        -</code></pre>

<p>Interesting - there is more going on in the background than one would expect. Ignoring the extra threads, the main thread has pid <code>8917312</code>, and the one started by <code>async</code> has pid <code>8591752</code>.</p>

<p>The latter is also the only thread that doesn&#39;t have a description, simply because we haven&#39;t set one. Setting one is easy, just put it into <code>$Coro::current-&gt;{desc}</code>:</p>

<pre><code>   async {
      $Coro::current-&gt;{desc} = &quot;cruncher&quot;;
      ...
   };</code></pre>

<p>This can be rather useful when debugging a program, or when using the interactive debug shell of <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/Debug.html">Coro::Debug</a>.</p>

<h1 id="The-Real-World---Event-Loops">The Real World - Event Loops</h1>

<p>Coro really wants to run in a program using some event loop. In fact, most real-world programs using Coro threads are written with a combination of event-based and thread-based techniques, as it is easy to get the best of both worlds with Coro.</p>

<p>Coro integrates automatically into any event loop supported by <a href="../../../lib/perl5/site_perl/5.26.3/x86_64-linux-thread-multi/AnyEvent.html">AnyEvent</a> (see <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/AnyEvent.html">Coro::AnyEvent</a> for details), but can take special advantage of the <a href="../../../lib/perl5/site_perl/5.26.3/x86_64-linux-thread-multi/AnyEvent/Impl/EV.html">EV</a> and <a href="../../../lib/perl5/site_perl/5.26.3/x86_64-linux-thread-multi/AnyEvent/Impl/Event.html">Event</a> modules.</p>

<p>Here is a simple finger client, using whatever event loop <a href="../../../lib/perl5/site_perl/5.26.3/x86_64-linux-thread-multi/AnyEvent.html">AnyEvent</a> comes up with:</p>

<pre><code>   use Coro;
   use Coro::Socket;

   sub finger {
      my ($user, $host) = @_;

      my $fh = new Coro::Socket PeerHost =&gt; $host, PeerPort =&gt; &quot;finger&quot;
         or die &quot;$user\@$host: $!&quot;;

      print $fh &quot;$user\n&quot;;

      print &quot;$user\@$host: $_&quot; while &lt;$fh&gt;;
      print &quot;$user\@$host: done\n&quot;;
   }

   # now finger a few accounts
   for (
      (async { finger &quot;abc&quot;, &quot;cornell.edu&quot; }),
      (async { finger &quot;sebbo&quot;, &quot;world.std.com&quot; }),
      (async { finger &quot;trouble&quot;, &quot;noc.dfn.de&quot; }),
   ) {
      $_-&gt;join; # wait for the result
   }</code></pre>

<p>There are a few new things here. First of all, there is <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/Socket.html">Coro::Socket</a>. This module works much the same way as <a href="../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/IO/Socket/INET.html">IO::Socket::INET</a>, except that it is coroutine-aware. This means that <a href="../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/IO/Socket/INET.html">IO::Socket::INET</a>, when waiting for the network, will block the whole process - that means all threads, which is clearly undesirable.</p>

<p>On the other hand, <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/Socket.html">Coro::Socket</a> knows how to give up the CPU to other threads when it waits for the network, which makes parallel execution possible.</p>

<p>The other new thing is the <code>join</code> method: All we want to do in this example is start three <code>async</code> threads and only exit when they have done their job. This could be done using a counting semaphore, but it is much simpler to synchronously wait for them to <code>terminate</code>, which is exactly what the <code>join</code> method does.</p>

<p>It doesn&#39;t matter that the three <code>async</code>s will probably finish in a different order then the for loop <code>join</code>s them - when the thread is still running, <code>join</code> simply waits. If the thread has already terminated, it will simply fetch its return status.</p>

<p>If you are experienced in event-based programming, you will see that the above program doesn&#39;t quite follow the normal pattern, where you start some work, and then run the event loop (e.v. <code>EV::loop</code>).</p>

<p>In fact, nontrivial programs follow this pattern even with Coro, so a Coro program that uses EV usually looks like this:</p>

<pre><code>   use EV;
   use Coro;

   # start coroutines or event watchers

   EV::loop; # and loop</code></pre>

<p>And in fact, for debugging, you often do something like this:</p>

<pre><code>   use EV;
   use Coro::Debug;

   my $shell = new_unix_server Coro::Debug &quot;/tmp/myshell&quot;;

   EV::loop; # and loop</code></pre>

<p>This runs your program, but also an interactive shell on the unix domain socket in <i>/tmp/myshell</i>. You can use the <i>socat</i> program to access it:</p>

<pre><code>   # socat readline /tmp/myshell
   coro debug session. use help for more info

   &gt; ps
           PID SC  RSS USES Description              Where
     136672312 RC  19k 177k [main::]                 [myprog:28]
     136710424 -- 1268   48 [coro manager]           [Coro.pm:349]
   &gt; help
   ps [w|v]                show the list of all coroutines (wide, verbose)
   bt &lt;pid&gt;                show a full backtrace of coroutine &lt;pid&gt;
   eval &lt;pid&gt; &lt;perl&gt;       evaluate &lt;perl&gt; expression in context of &lt;pid&gt;
   trace &lt;pid&gt;             enable tracing for this coroutine
   untrace &lt;pid&gt;           disable tracing for this coroutine
   kill &lt;pid&gt; &lt;reason&gt;     throws the given &lt;reason&gt; string in &lt;pid&gt;
   cancel &lt;pid&gt;            cancels this coroutine
   ready &lt;pid&gt;             force &lt;pid&gt; into the ready queue
   &lt;anything else&gt;         evaluate as perl and print results
   &lt;anything else&gt; &amp;       same as above, but evaluate asynchronously
                           you can use (find_coro &lt;pid&gt;) in perl expressions
                           to find the coro with the given pid, e.g.
                           (find_coro 9768720)-&gt;ready
   loglevel &lt;int&gt;          enable logging for messages of level &lt;int&gt; and lower
   exit                    end this session</code></pre>

<p>Microsft victims can of course use the even less secure <code>new_tcp_server</code> constructor.</p>

<h2 id="The-Real-World---File-I-O">The Real World - File I/O</h2>

<p>Disk I/O, while often much faster than the network, nevertheless can take quite a long time in which the CPU could do other things, if one would only be able to do something.</p>

<p>Fortunately, the <a>IO::AIO</a> module on CPAN allows you to move these I/O calls into the background, letting you do useful work in the foreground. It is event-/callback-based, but Coro has a nice wrapper around it, called <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/AIO.html">Coro::AIO</a>, which lets you use its functions naturally from within threads:</p>

<pre><code>   use Fcntl;
   use Coro::AIO;

   my $fh = aio_open &quot;$filename~&quot;, O_WRONLY | O_CREAT, 0600
      or die &quot;$filename~: $!&quot;;

   aio_write $fh, 0, (length $data), $data, 0;
   aio_fsync $fh;
   aio_close $fh;
   aio_rename &quot;$filename~&quot;, &quot;$filename&quot;;</code></pre>

<p>The above creates a new file, writes data into it, syncs the data to disk and atomically replaces a base file with a new copy.</p>

<h2 id="Inversion-of-control---rouse-functions">Inversion of control - rouse functions</h2>

<p>Last not least, me talk about inversion of control. The &quot;control&quot; refers to &quot;who calls whom&quot;, who is in control of the program. In this program, the main program is in control and passes this to all functions it calls:</p>

<pre><code>   use LWP;

   # pass control to get
   my $res = get &quot;http://example.org/&quot;;
   # control returned to us

   print $res;</code></pre>

<p>When switching to event-based programs, instead of &quot;us calling them&quot;, &quot;they call us&quot; - this is the inversion of control form the title:</p>

<pre><code>   use AnyEvent::HTTP;

   # do not pass control for long - http_get immediately returns
   http_get &quot;http://example.org/&quot;, sub {
      print $_[0];
   };

   # we stay in control and can do other things</code></pre>

<p>Event based programming can be nice, but sometimes it&#39;s just easier to write down some processing in &quot;linear&quot; fashion, without callbacks. Coro provides some special functions to reduce typing:</p>

<pre><code>   use AnyEvent::HTTP;

   # do not pass control for long - http_get immediately returns
   http_get &quot;http://example.org/&quot;, Coro::rouse_cb;

   # we stay in control and can do other things...
   # ...such as wait for the result
   my ($res) = Coro::rouse_wait;</code></pre>

<p><code>Coro::rouse_cb</code> creates and returns a special callback. You can pass this callback to any function that would expect a callback.</p>

<p><code>Coro::rouse_wait</code> waits (block the current thread) until the most recently created callback has been called, and returns whatever was passed to it.</p>

<p>These two functions allow you to <i>mechanically</i> invert the control from &quot;callback based style&quot; used by most event-based libraries to &quot;blocking style&quot;, whenever you wish to.</p>

<p>The pattern is simple: instead of...</p>

<pre><code>   some_func ..., sub {
      my @res = @_;
      ...
   };</code></pre>

<p>... you write:</p>

<pre><code>   some_func ..., Coro::rouse_cb;
   my @res = Coro::rouse_wait;
   ...</code></pre>

<p>Callback-based interfaces are plenty, and the rouse functions allow you to use them in an often more convenient way.</p>

<h1 id="Other-Modules">Other Modules</h1>

<p>This introduction only mentions a few methods and modules, Coro has many other functions (see the <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro.html">Coro</a> manpage) and modules (documented in the <code>SEE ALSO</code> section of the <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro.html">Coro</a> manpage).</p>

<p>Noteworthy modules are <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/LWP.html">Coro::LWP</a> (for parallel LWP requests, but see <a>AnyEvent::HTTP</a> for a better HTTP-only alternative), <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/BDB.html">Coro::BDB</a>, for when you need an asynchronous database, <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/Handle.html">Coro::Handle</a>, when you need to use any file handle in a coroutine (popular to access <code>STDIN</code> and <code>STDOUT</code>) and <a>Coro::EV</a>, the optimised interface to <a href="../../../lib/perl5/site_perl/5.26.3/x86_64-linux-thread-multi/AnyEvent/Impl/EV.html">EV</a> (which gets used automatically by <a href="../../../../../root/.cpanm/work/1586168104.26463/Coro-6.55/blib/lib/Coro/AnyEvent.html">Coro::AnyEvent</a>).</p>

<p>There are a number of Coro-related moduels that might be useful for your problem (see <a href="http://search.cpan.org/search?query=Coro&amp;mode=module">http://search.cpan.org/search?query=Coro&amp;mode=module</a>). And since Coro integrates so well into AnyEvent, it&#39;s often easy to adapt existing AnyEvent modules (see <a href="http://search.cpan.org/search?query=AnyEvent&amp;mode=module">http://search.cpan.org/search?query=AnyEvent&amp;mode=module</a>).</p>

<h1 id="AUTHOR">AUTHOR</h1>

<pre><code>   Marc Lehmann &lt;schmorp@schmorp.de&gt;
   http://home.schmorp.de/</code></pre>


</body>

</html>


