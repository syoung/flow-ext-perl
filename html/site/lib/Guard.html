<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../displayToc.js"></script>
<script language="JavaScript" src="../../tocParas.js"></script>
<script language="JavaScript" src="../../tocTab.js"></script>
<title></title>
<link rel="stylesheet" href="../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a></li>
  <li><a href="#EXCEPTIONS">EXCEPTIONS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#THANKS">THANKS</a></li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Guard - safe cleanup blocks</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>   use Guard;
   
   # temporarily chdir to &quot;/etc&quot; directory, but make sure
   # to go back to &quot;/&quot; no matter how myfun exits:
   sub myfun {
      scope_guard { chdir &quot;/&quot; };
      chdir &quot;/etc&quot;;
   
      code_that_might_die_or_does_other_fun_stuff;
   }

   # create an object that, when the last reference to it is gone,
   # invokes the given codeblock:
   my $guard = guard { print &quot;destroyed!\n&quot; };
   undef $guard; # probably destroyed here</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module implements so-called &quot;guards&quot;. A guard is something (usually an object) that &quot;guards&quot; a resource, ensuring that it is cleaned up when expected.</p>

<p>Specifically, this module supports two different types of guards: guard objects, which execute a given code block when destroyed, and scoped guards, which are tied to the scope exit.</p>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<p>This module currently exports the <code>scope_guard</code> and <code>guard</code> functions by default.</p>

<dl>

<dt id="scope_guard-BLOCK">scope_guard BLOCK</dt>
<dd>

</dd>
<dt id="scope_guard-coderef">scope_guard ($coderef)</dt>
<dd>

<p>Registers a block that is executed when the current scope (block, function, method, eval etc.) is exited.</p>

<p>See the EXCEPTIONS section for an explanation of how exceptions (i.e. <code>die</code>) are handled inside guard blocks.</p>

<p>The description below sounds a bit complicated, but that&#39;s just because <code>scope_guard</code> tries to get even corner cases &quot;right&quot;: the goal is to provide you with a rock solid clean up tool.</p>

<p>The behaviour is similar to this code fragment:</p>

<pre><code>   eval ... code following scope_guard ...
   {
      local $@;
      eval BLOCK;
      eval { $Guard::DIED-&gt;() } if $@;
   }
   die if $@;</code></pre>

<p>Except it is much faster, and the whole thing gets executed even when the BLOCK calls <code>exit</code>, <code>goto</code>, <code>last</code> or escapes via other means.</p>

<p>If multiple BLOCKs are registered to the same scope, they will be executed in reverse order. Other scope-related things such as <code>local</code> are managed via the same mechanism, so variables <code>local</code>ised <i>after</i> calling <code>scope_guard</code> will be restored when the guard runs.</p>

<p>Example: temporarily change the timezone for the current process, ensuring it will be reset when the <code>if</code> scope is exited:</p>

<pre><code>   use Guard;
   use POSIX ();

   if ($need_to_switch_tz) {
      # make sure we call tzset after $ENV{TZ} has been restored
      scope_guard { POSIX::tzset };

      # localise after the scope_guard, so it gets undone in time
      local $ENV{TZ} = &quot;Europe/London&quot;;
      POSIX::tzset;

      # do something with the new timezone
   }</code></pre>

</dd>
<dt id="my-guard-guard-BLOCK">my $guard = guard BLOCK</dt>
<dd>

</dd>
<dt id="my-guard-guard-coderef">my $guard = guard ($coderef)</dt>
<dd>

<p>Behaves the same as <code>scope_guard</code>, except that instead of executing the block on scope exit, it returns an object whose lifetime determines when the BLOCK gets executed: when the last reference to the object gets destroyed, the BLOCK gets executed as with <code>scope_guard</code>.</p>

<p>See the EXCEPTIONS section for an explanation of how exceptions (i.e. <code>die</code>) are handled inside guard blocks.</p>

<p>Example: acquire a Coro::Semaphore for a second by registering a timer. The timer callback references the guard used to unlock it again. (Please ignore the fact that <code>Coro::Semaphore</code> has a <code>guard</code> method that does this already):</p>

<pre><code>   use Guard;
   use Coro::AnyEvent;
   use Coro::Semaphore;

   my $sem = new Coro::Semaphore;

   sub lock_for_a_second {
      $sem-&gt;down;
      my $guard = guard { $sem-&gt;up };

      Coro::AnyEvent::sleep 1;

      # $sem-&gt;up gets executed when returning
   }</code></pre>

<p>The advantage of doing this with a guard instead of simply calling <code>$sem-&gt;down</code> in the callback is that you can opt not to create the timer, or your code can throw an exception before it can create the timer (or the thread gets canceled), or you can create multiple timers or other event watchers and only when the last one gets executed will the lock be unlocked. Using the <code>guard</code>, you do not have to worry about catching all the places where you have to unlock the semaphore.</p>

</dd>
<dt id="guard-cancel">$guard-&gt;cancel</dt>
<dd>

<p>Calling this function will &quot;disable&quot; the guard object returned by the <code>guard</code> function, i.e. it will free the BLOCK originally passed to <code>guard </code>and will arrange for the BLOCK not to be executed.</p>

<p>This can be useful when you use <code>guard</code> to create a cleanup handler to be called under fatal conditions and later decide it is no longer needed.</p>

</dd>
</dl>

<h1 id="EXCEPTIONS">EXCEPTIONS</h1>

<p>Guard blocks should not normally throw exceptions (that is, <code>die</code>). After all, they are usually used to clean up after such exceptions. However, if something truly exceptional is happening, a guard block should of course be allowed to die. Also, programming errors are a large source of exceptions, and the programmer certainly wants to know about those.</p>

<p>Since in most cases, the block executing when the guard gets executed does not know or does not care about the guard blocks, it makes little sense to let containing code handle the exception.</p>

<p>Therefore, whenever a guard block throws an exception, it will be caught by Guard, followed by calling the code reference stored in <code>$Guard::DIED</code> (with <code>$@</code> set to the actual exception), which is similar to how most event loops handle this case.</p>

<p>The default for <code>$Guard::DIED</code> is to call <code>warn &quot;$@&quot;</code>, i.e. the error is printed as a warning and the program continues.</p>

<p>The <code>$@</code> variable will be restored to its value before the guard call in all cases, so guards will not disturb <code>$@</code> in any way.</p>

<p>The code reference stored in <code>$Guard::DIED</code> should not die (behaviour is not guaranteed, but right now, the exception will simply be ignored).</p>

<h1 id="AUTHOR">AUTHOR</h1>

<pre><code> Marc Lehmann &lt;schmorp@schmorp.de&gt;
 http://home.schmorp.de/</code></pre>

<h1 id="THANKS">THANKS</h1>

<p>Thanks to Marco Maisenhelder, who reminded me of the <code>$Guard::DIED</code> solution to the problem of exceptions.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a href="../../lib/perl5/5.26.3/Scope/Guard.html">Scope::Guard</a> and <a>Sub::ScopeFinalizer</a>, which actually implement dynamically scoped guards only, not the lexically scoped guards that their documentation promises, and have a lot higher CPU, memory and typing overhead.</p>

<p><a>Hook::Scope</a>, which has apparently never been finished and can corrupt memory when used.</p>

<p><a href="../../lib/perl5/5.26.3/Scope/Guard.html">Scope::Guard</a> seems to have a big SEE ALSO section for even more modules like it.</p>


</body>

</html>


