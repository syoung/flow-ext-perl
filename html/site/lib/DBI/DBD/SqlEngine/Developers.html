<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../../tocTab.js"></script>
<title></title>
<link rel="stylesheet" href="../../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#CLASSES">CLASSES</a>
    <ul>
      <li><a href="#DBI::DBD::SqlEngine">DBI::DBD::SqlEngine</a></li>
      <li><a href="#DBI::DBD::SqlEngine::dr1">DBI::DBD::SqlEngine::dr</a>
        <ul>
          <li><a href="#Methods-provided-by-DBI::DBD::SqlEngine::dr">Methods provided by DBI::DBD::SqlEngine::dr:</a></li>
        </ul>
      </li>
      <li><a href="#DBI::DBD::SqlEngine::db1">DBI::DBD::SqlEngine::db</a>
        <ul>
          <li><a href="#Methods-provided-by-DBI::DBD::SqlEngine::db">Methods provided by DBI::DBD::SqlEngine::db:</a></li>
          <li><a href="#Attributes-used-by-DBI::DBD::SqlEngine::db">Attributes used by DBI::DBD::SqlEngine::db:</a></li>
        </ul>
      </li>
      <li><a href="#DBI::DBD::SqlEngine::st1">DBI::DBD::SqlEngine::st</a></li>
      <li><a href="#DBI::DBD::SqlEngine::TableSource1">DBI::DBD::SqlEngine::TableSource</a></li>
      <li><a href="#DBI::DBD::SqlEngine::DataSource1">DBI::DBD::SqlEngine::DataSource</a></li>
      <li><a href="#DBI::DBD::SqlEngine::Statement1">DBI::DBD::SqlEngine::Statement</a></li>
      <li><a href="#DBI::DBD::SqlEngine::Table1">DBI::DBD::SqlEngine::Table</a></li>
    </ul>
  </li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>DBI::DBD::SqlEngine::Developers - Developers documentation for DBI::DBD::SqlEngine</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    package DBD::myDriver;

    use base qw(DBI::DBD::SqlEngine);

    sub driver
    {
        ...
        my $drh = $proto-&gt;SUPER::driver($attr);
        ...
        return $drh-&gt;{class};
    }

    sub CLONE { ... }

    package DBD::myDriver::dr;

    @ISA = qw(DBI::DBD::SqlEngine::dr);

    sub data_sources { ... }
    ...

    package DBD::myDriver::db;

    @ISA = qw(DBI::DBD::SqlEngine::db);

    sub init_valid_attributes { ... }
    sub init_default_attributes { ... }
    sub set_versions { ... }
    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
    sub get_myd_versions { ... }
    sub get_avail_tables { ... }

    package DBD::myDriver::st;

    @ISA = qw(DBI::DBD::SqlEngine::st);

    sub FETCH { ... }
    sub STORE { ... }

    package DBD::myDriver::Statement;

    @ISA = qw(DBI::DBD::SqlEngine::Statement);

    sub open_table { ... }

    package DBD::myDriver::Table;

    @ISA = qw(DBI::DBD::SqlEngine::Table);

    my %reset_on_modify = (
                            myd_abc =&gt; &quot;myd_foo&quot;,
                            myd_mno =&gt; &quot;myd_bar&quot;,
                          );
    __PACKAGE__-&gt;register_reset_on_modify( \%reset_on_modify );
    my %compat_map = (
                       abc =&gt; &#39;foo_abc&#39;,
                       xyz =&gt; &#39;foo_xyz&#39;,
                     );
    __PACKAGE__-&gt;register_compat_map( \%compat_map );

    sub bootstrap_table_meta { ... }
    sub init_table_meta { ... }
    sub table_meta_attr_changed { ... }
    sub open_data { ... }

    sub new { ... }

    sub fetch_row { ... }
    sub push_row { ... }
    sub push_names { ... }
    sub seek { ... }
    sub truncate { ... }
    sub drop { ... }

    # optimize the SQL engine by add one or more of
    sub update_current_row { ... }
    # or
    sub update_specific_row { ... }
    # or
    sub update_one_row { ... }
    # or
    sub insert_new_row { ... }
    # or
    sub delete_current_row { ... }
    # or
    sub delete_one_row { ... }</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This document describes the interface of DBI::DBD::SqlEngine for DBD developers who write DBI::DBD::SqlEngine based DBI drivers. It supplements <a href="../../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBI/DBD.html">DBI::DBD</a> and <a href="../../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBI/DBD/SqlEngine/HowTo.html">DBI::DBD::SqlEngine::HowTo</a>, which you should read first.</p>

<h1 id="CLASSES">CLASSES</h1>

<p>Each DBI driver must provide a package global <code>driver</code> method and three DBI related classes:</p>

<dl>

<dt id="DBI::DBD::SqlEngine::dr">DBI::DBD::SqlEngine::dr</dt>
<dd>

<p>Driver package, contains the methods DBI calls indirectly via DBI interface:</p>

<pre><code>  DBI-&gt;connect (&#39;DBI:DBM:&#39;, undef, undef, {})

  # invokes
  package DBD::DBM::dr;
  @DBD::DBM::dr::ISA = qw(DBI::DBD::SqlEngine::dr);

  sub connect ($$;$$$)
  {
      ...
  }</code></pre>

<p>Similar for <code>data_sources ()</code> and <code>disconnect_all()</code>.</p>

<p>Pure Perl DBI drivers derived from DBI::DBD::SqlEngine usually don&#39;t need to override any of the methods provided through the DBD::XXX::dr package. However if you need additional initialization not fitting in <code>init_valid_attributes()</code> and <code>init_default_attributes()</code> of you&#39;re ::db class, the connect method might be the final place to be modified.</p>

</dd>
<dt id="DBI::DBD::SqlEngine::db">DBI::DBD::SqlEngine::db</dt>
<dd>

<p>Contains the methods which are called through DBI database handles (<code>$dbh</code>). e.g.,</p>

<pre><code>  $sth = $dbh-&gt;prepare (&quot;select * from foo&quot;);
  # returns the f_encoding setting for table foo
  $dbh-&gt;csv_get_meta (&quot;foo&quot;, &quot;f_encoding&quot;);</code></pre>

<p>DBI::DBD::SqlEngine provides the typical methods required here. Developers who write DBI drivers based on DBI::DBD::SqlEngine need to override the methods <code>set_versions</code> and <code>init_valid_attributes</code>.</p>

</dd>
<dt id="DBI::DBD::SqlEngine::TieMeta">DBI::DBD::SqlEngine::TieMeta;</dt>
<dd>

<p>Provides the tie-magic for <code>$dbh-&gt;{$drv_pfx . &quot;_meta&quot;}</code>. Routes <code>STORE</code> through <code>$drv-&gt;set_sql_engine_meta()</code> and <code>FETCH</code> through <code>$drv-&gt;get_sql_engine_meta()</code>. <code>DELETE</code> is not supported, you have to execute a <code>DROP TABLE</code> statement, where applicable.</p>

</dd>
<dt id="DBI::DBD::SqlEngine::TieTables">DBI::DBD::SqlEngine::TieTables;</dt>
<dd>

<p>Provides the tie-magic for tables in <code>$dbh-&gt;{$drv_pfx . &quot;_meta&quot;}</code>. Routes <code>STORE</code> though <code>$tblClass-&gt;set_table_meta_attr()</code> and <code>FETCH</code> though <code>$tblClass-&gt;get_table_meta_attr()</code>. <code>DELETE</code> removes an attribute from the <i>meta object</i> retrieved by <code>$tblClass-&gt;get_table_meta()</code>.</p>

</dd>
<dt id="DBI::DBD::SqlEngine::st">DBI::DBD::SqlEngine::st</dt>
<dd>

<p>Contains the methods to deal with prepared statement handles. e.g.,</p>

<pre><code>  $sth-&gt;execute () or die $sth-&gt;errstr;</code></pre>

</dd>
<dt id="DBI::DBD::SqlEngine::TableSource">DBI::DBD::SqlEngine::TableSource;</dt>
<dd>

<p>Base class for 3rd party table sources:</p>

<pre><code>  $dbh-&gt;{sql_table_source} = &quot;DBD::Foo::TableSource&quot;;</code></pre>

</dd>
<dt id="DBI::DBD::SqlEngine::DataSource">DBI::DBD::SqlEngine::DataSource;</dt>
<dd>

<p>Base class for 3rd party data sources:</p>

<pre><code>  $dbh-&gt;{sql_data_source} = &quot;DBD::Foo::DataSource&quot;;</code></pre>

</dd>
<dt id="DBI::DBD::SqlEngine::Statement">DBI::DBD::SqlEngine::Statement;</dt>
<dd>

<p>Base class for derived drivers statement engine. Implements <code>open_table</code>.</p>

</dd>
<dt id="DBI::DBD::SqlEngine::Table">DBI::DBD::SqlEngine::Table;</dt>
<dd>

<p>Contains tailoring between SQL engine&#39;s requirements and <code>DBI::DBD::SqlEngine</code> magic for finding the right tables and storage. Builds bridges between <code>sql_meta</code> handling of <code>DBI::DBD::SqlEngine::db</code>, table initialization for SQL engines and <i>meta object</i>&#39;s attribute management for derived drivers.</p>

</dd>
</dl>

<h2 id="DBI::DBD::SqlEngine">DBI::DBD::SqlEngine</h2>

<p>This is the main package containing the routines to initialize DBI::DBD::SqlEngine based DBI drivers. Primarily the <code>DBI::DBD::SqlEngine::driver</code> method is invoked, either directly from DBI when the driver is initialized or from the derived class.</p>

<pre><code>  package DBD::DBM;

  use base qw( DBI::DBD::SqlEngine );

  sub driver
  {
      my ( $class, $attr ) = @_;
      ...
      my $drh = $class-&gt;SUPER::driver( $attr );
      ...
      return $drh;
  }</code></pre>

<p>It is not necessary to implement your own driver method as long as additional initialization (e.g. installing more private driver methods) is not required. You do not need to call <code>setup_driver</code> as DBI::DBD::SqlEngine takes care of it.</p>

<h2 id="DBI::DBD::SqlEngine::dr1">DBI::DBD::SqlEngine::dr</h2>

<p>The driver package contains the methods DBI calls indirectly via the DBI interface (see <a href="../../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBI.html#DBI-Class-Methods">&quot;DBI Class Methods&quot; in DBI</a>).</p>

<p>DBI::DBD::SqlEngine based DBI drivers usually do not need to implement anything here, it is enough to do the basic initialization:</p>

<pre><code>  package DBD:XXX::dr;

  @DBD::XXX::dr::ISA = qw (DBI::DBD::SqlEngine::dr);
  $DBD::XXX::dr::imp_data_size     = 0;
  $DBD::XXX::dr::data_sources_attr = undef;
  $DBD::XXX::ATTRIBUTION = &quot;DBD::XXX $DBD::XXX::VERSION by Hans Mustermann&quot;;</code></pre>

<h3 id="Methods-provided-by-DBI::DBD::SqlEngine::dr">Methods provided by <code>DBI::DBD::SqlEngine::dr</code>:</h3>

<dl>

<dt id="connect">connect</dt>
<dd>

<p>Supervises the driver bootstrap when calling</p>

<pre><code>  DBI-&gt;connect( &quot;dbi:Foo&quot;, , , { ... } );</code></pre>

<p>First it instantiates a new driver using <code>DBI::_new_dbh</code>. After that, initial bootstrap of the newly instantiated driver is done by</p>

<pre><code>  $dbh-&gt;func( 0, &quot;init_default_attributes&quot; );</code></pre>

<p>The first argument (<code>0</code>) signals that this is the very first call to <code>init_default_attributes</code>. Modern drivers understand that and do early stage setup here after calling</p>

<pre><code>  package DBD::Foo::db;
  our @DBD::Foo::db::ISA = qw(DBI::DBD::SqlEngine::db);
  
  sub init_default_attributes
  {
    my ($dbh, $phase) = @_;
    $dbh-&gt;SUPER::init_default_attributes($phase);
    ...; # own setup code, maybe separated by phases
  }</code></pre>

<p>When the <code>$phase</code> argument is passed down until <code>DBI::DBD::SqlEngine::db::init_default_attributes</code>, <code>connect()</code> recognizes a <i>modern</i> driver and initializes the attributes from <i>DSN</i> and <i>$attr</i> arguments passed via <code>DBI-&gt;connect( $dsn, $user, $pass, \%attr )</code>.</p>

<p>At the end of the attribute initialization after <i>phase 0</i>, <code>connect()</code> invoked <code>init_default_attributes</code> again for <i>phase 1</i>:</p>

<pre><code>  $dbh-&gt;func( 1, &quot;init_default_attributes&quot; );</code></pre>

</dd>
<dt id="data_sources">data_sources</dt>
<dd>

<p>Returns a list of <i>DSN</i>&#39;s using the <code>data_sources</code> method of the class specified in <code>$dbh-&gt;{sql_table_source}</code> or via <code>\%attr</code>:</p>

<pre><code>  @ary = DBI-&gt;data_sources($driver);
  @ary = DBI-&gt;data_sources($driver, \%attr);</code></pre>

</dd>
<dt id="disconnect_all">disconnect_all</dt>
<dd>

<p><code>DBI::DBD::SqlEngine</code> doesn&#39;t have an overall driver cache, so nothing happens here at all.</p>

</dd>
</dl>

<h2 id="DBI::DBD::SqlEngine::db1">DBI::DBD::SqlEngine::db</h2>

<p>This package defines the database methods, which are called via the DBI database handle <code>$dbh</code>.</p>

<h3 id="Methods-provided-by-DBI::DBD::SqlEngine::db">Methods provided by <code>DBI::DBD::SqlEngine::db</code>:</h3>

<dl>

<dt id="ping">ping</dt>
<dd>

<p>Simply returns the content of the <code>Active</code> attribute. Override when your driver needs more complicated actions here.</p>

</dd>
<dt id="prepare">prepare</dt>
<dd>

<p>Prepares a new SQL statement to execute. Returns a statement handle, <code>$sth</code> - instance of the DBD:XXX::st. It is neither required nor recommended to override this method.</p>

</dd>
<dt id="validate_FETCH_attr">validate_FETCH_attr</dt>
<dd>

<p>Called by <code>FETCH</code> to allow inherited drivers do their own attribute name validation. Calling convention is similar to <code>FETCH</code> and the return value is the approved attribute name.</p>

<pre><code>    return $validated_attribute_name;</code></pre>

<p>In case of validation fails (e.g. accessing private attribute or similar), <code>validate_FETCH_attr</code> is permitted to throw an exception.</p>

</dd>
<dt id="FETCH">FETCH</dt>
<dd>

<p>Fetches an attribute of a DBI database object. Private handle attributes must have a prefix (this is mandatory). If a requested attribute is detected as a private attribute without a valid prefix, the driver prefix (written as <code>$drv_prefix</code>) is added.</p>

<p>The driver prefix is extracted from the attribute name and verified against <code>$dbh-&gt;{ $drv_prefix . &quot;valid_attrs&quot; }</code> (when it exists). If the requested attribute value is not listed as a valid attribute, this method croaks. If the attribute is valid and readonly (listed in <code>$dbh-&gt;{ $drv_prefix . &quot;readonly_attrs&quot; }</code> when it exists), a real copy of the attribute value is returned. So it&#39;s not possible to modify <code>f_valid_attrs</code> from outside of DBI::DBD::SqlEngine::db or a derived class.</p>

</dd>
<dt id="validate_STORE_attr">validate_STORE_attr</dt>
<dd>

<p>Called by <code>STORE</code> to allow inherited drivers do their own attribute name validation. Calling convention is similar to <code>STORE</code> and the return value is the approved attribute name followed by the approved new value.</p>

<pre><code>    return ($validated_attribute_name, $validated_attribute_value);</code></pre>

<p>In case of validation fails (e.g. accessing private attribute or similar), <code>validate_STORE_attr</code> is permitted to throw an exception (<code>DBI::DBD::SqlEngine::db::validate_STORE_attr</code> throws an exception when someone tries to assign value other than <code>SQL_IC_UPPER .. SQL_IC_MIXED</code> to <code>$dbh-&gt;{sql_identifier_case}</code> or <code>$dbh-&gt;{sql_quoted_identifier_case}</code>).</p>

</dd>
<dt id="STORE">STORE</dt>
<dd>

<p>Stores a database private attribute. Private handle attributes must have a prefix (this is mandatory). If a requested attribute is detected as a private attribute without a valid prefix, the driver prefix (written as <code>$drv_prefix</code>) is added. If the database handle has an attribute <code>${drv_prefix}_valid_attrs</code> - for attribute names which are not listed in that hash, this method croaks. If the database handle has an attribute <code>${drv_prefix}_readonly_attrs</code>, only attributes which are not listed there can be stored (once they are initialized). Trying to overwrite such an immutable attribute forces this method to croak.</p>

<p>An example of a valid attributes list can be found in <code>DBI::DBD::SqlEngine::db::init_valid_attributes</code>.</p>

</dd>
<dt id="set_versions">set_versions</dt>
<dd>

<p>This method sets the attributes <code>f_version</code>, <code>sql_nano_version</code>, <code>sql_statement_version</code> and (if not prohibited by a restrictive <code>${prefix}_valid_attrs</code>) <code>${prefix}_version</code>.</p>

<p>This method is called at the end of the <code>connect ()</code> phase.</p>

<p>When overriding this method, do not forget to invoke the superior one.</p>

</dd>
<dt id="init_valid_attributes">init_valid_attributes</dt>
<dd>

<p>This method is called after the database handle is instantiated as the first attribute initialization.</p>

<p><code>DBI::DBD::SqlEngine::db::init_valid_attributes</code> initializes the attributes <code>sql_valid_attrs</code> and <code>sql_readonly_attrs</code>.</p>

<p>When overriding this method, do not forget to invoke the superior one, preferably before doing anything else.</p>

</dd>
<dt id="init_default_attributes">init_default_attributes</dt>
<dd>

<p>This method is called after the database handle is instantiated to initialize the default attributes. It expects one argument: <code>$phase</code>. If <code>$phase</code> is not given, <code>connect</code> of <code>DBI::DBD::SqlEngine::dr</code> expects this is an old-fashioned driver which isn&#39;t capable of multi-phased initialization.</p>

<p><code>DBI::DBD::SqlEngine::db::init_default_attributes</code> initializes the attributes <code>sql_identifier_case</code>, <code>sql_quoted_identifier_case</code>, <code>sql_handler</code>, <code>sql_init_order</code>, <code>sql_meta</code>, <code>sql_engine_version</code>, <code>sql_nano_version</code> and <code>sql_statement_version</code> when <a href="../../../../../lib/perl5/5.26.3/SQL/Statement.html">SQL::Statement</a> is available.</p>

<p>It sets <code>sql_init_order</code> to the given <code>$phase</code>.</p>

<p>When the derived implementor class provides the attribute to validate attributes (e.g. <code>$dbh-&gt;{dbm_valid_attrs} = {...};</code>) or the attribute containing the immutable attributes (e.g. <code>$dbh-&gt;{dbm_readonly_attrs} = {...};</code>), the attributes <code>drv_valid_attrs</code>, <code>drv_readonly_attrs</code> and <code>drv_version</code> are added (when available) to the list of valid and immutable attributes (where <code>drv_</code> is interpreted as the driver prefix).</p>

</dd>
<dt id="get_versions">get_versions</dt>
<dd>

<p>This method is called by the code injected into the instantiated driver to provide the user callable driver method <code>${prefix}versions</code> (e.g. <code>dbm_versions</code>, <code>csv_versions</code>, ...).</p>

<p>The DBI::DBD::SqlEngine implementation returns all version information known by DBI::DBD::SqlEngine (e.g. DBI version, Perl version, DBI::DBD::SqlEngine version and the SQL handler version).</p>

<p><code>get_versions</code> takes the <code>$dbh</code> as the first argument and optionally a second argument containing a table name. The second argument is not evaluated in <code>DBI::DBD::SqlEngine::db::get_versions</code> itself - but might be in the future.</p>

<p>If the derived implementor class provides a method named <code>get_${drv_prefix}versions</code>, this is invoked and the return value of it is associated to the derived driver name:</p>

<pre><code>    if (my $dgv = $dbh-&gt;{ImplementorClass}-&gt;can (&quot;get_&quot; . $drv_prefix . &quot;versions&quot;) {
        (my $derived_driver = $dbh-&gt;{ImplementorClass}) =~ s/::db$//;
        $versions{$derived_driver} = &amp;$dgv ($dbh, $table);
    }</code></pre>

<p>Override it to add more version information about your module, (e.g. some kind of parser version in case of DBD::CSV, ...), if one line is not enough room to provide all relevant information.</p>

</dd>
<dt id="sql_parser_object">sql_parser_object</dt>
<dd>

<p>Returns a <a href="../../../../../lib/perl5/5.26.3/SQL/Parser.html">SQL::Parser</a> instance, when <code>sql_handler</code> is set to &quot;SQL::Statement&quot;. The parser instance is stored in <code>sql_parser_object</code>.</p>

<p>It is not recommended to override this method.</p>

</dd>
<dt id="disconnect">disconnect</dt>
<dd>

<p>Disconnects from a database. All local table information is discarded and the <code>Active</code> attribute is set to 0.</p>

</dd>
<dt id="type_info_all">type_info_all</dt>
<dd>

<p>Returns information about all the types supported by DBI::DBD::SqlEngine.</p>

</dd>
<dt id="table_info">table_info</dt>
<dd>

<p>Returns a statement handle which is prepared to deliver information about all known tables.</p>

</dd>
<dt id="list_tables">list_tables</dt>
<dd>

<p>Returns a list of all known table names.</p>

</dd>
<dt id="quote">quote</dt>
<dd>

<p>Quotes a string for use in SQL statements.</p>

</dd>
<dt id="commit">commit</dt>
<dd>

<p>Warns about a useless call (if warnings enabled) and returns. DBI::DBD::SqlEngine is typically a driver which commits every action instantly when executed.</p>

</dd>
<dt id="rollback">rollback</dt>
<dd>

<p>Warns about a useless call (if warnings enabled) and returns. DBI::DBD::SqlEngine is typically a driver which commits every action instantly when executed.</p>

</dd>
</dl>

<h3 id="Attributes-used-by-DBI::DBD::SqlEngine::db">Attributes used by <code>DBI::DBD::SqlEngine::db</code>:</h3>

<p>This section describes attributes which are important to developers of DBI Database Drivers derived from <code>DBI::DBD::SqlEngine</code>.</p>

<dl>

<dt id="sql_init_order">sql_init_order</dt>
<dd>

<p>This attribute contains a hash with priorities as key and an array containing the <code>$dbh</code> attributes to be initialized during before/after other attributes.</p>

<p><code>DBI::DBD::SqlEngine</code> initializes following attributes:</p>

<pre><code>  $dbh-&gt;{sql_init_order} = {
       0 =&gt; [qw( Profile RaiseError PrintError AutoCommit )],
      90 =&gt; [ &quot;sql_meta&quot;, $dbh-&gt;{$drv_pfx_meta} ? $dbh-&gt;{$drv_pfx_meta} : () ]
  }</code></pre>

<p>The default priority of not listed attribute keys is <code>50</code>. It is well known that a lot of attributes needed to be set before some table settings are initialized. For example, for <a href="../../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBD/DBM.html">DBD::DBM</a>, when using</p>

<pre><code>  my $dbh = DBI-&gt;connect( &quot;dbi:DBM:&quot;, undef, undef, {
      f_dir =&gt; &quot;/path/to/dbm/databases&quot;,
      dbm_type =&gt; &quot;BerkeleyDB&quot;,
      dbm_mldbm =&gt; &quot;JSON&quot;, # use MLDBM::Serializer::JSON
      dbm_tables =&gt; {
          quick =&gt; {
              dbm_type =&gt; &quot;GDBM_File&quot;,
              dbm_MLDBM =&gt; &quot;FreezeThaw&quot;
          }
      }
  });</code></pre>

<p>This defines a known table <code>quick</code> which uses the <a href="../../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/GDBM_File.html">GDBM_File</a> backend and <a>FreezeThaw</a> as serializer instead of the overall default <a>BerkeleyDB</a> and <a href="../../../../../lib/perl5/5.26.3/JSON.html">JSON</a>. <b>But</b> all files containing the table data have to be searched in <code>$dbh-&gt;{f_dir}</code>, which requires <code>$dbh-&gt;{f_dir}</code> must be initialized before <code>$dbh-&gt;{sql_meta}-&gt;{quick}</code> is initialized by <code>bootstrap_table_meta</code> method of <a href="#DBI::DBD::SqlEngine::Table">&quot;DBI::DBD::SqlEngine::Table&quot;</a> to get <code>$dbh-&gt;{sql_meta}-&gt;{quick}-&gt;{f_dir}</code> being initialized properly.</p>

</dd>
<dt id="sql_init_phase">sql_init_phase</dt>
<dd>

<p>This attribute is only set during the initialization steps of the DBI Database Driver. It contains the value of the currently run initialization phase. Currently supported phases are <i>phase 0</i> and <i>phase 1</i>. This attribute is set in <code>init_default_attributes</code> and removed in <code>init_done</code>.</p>

</dd>
<dt id="sql_engine_in_gofer">sql_engine_in_gofer</dt>
<dd>

<p>This value has a true value in case of this driver is operated via <a href="../../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBD/Gofer.html">DBD::Gofer</a>. The impact of being operated via Gofer is a read-only driver (not read-only databases!), so you cannot modify any attributes later - neither any table settings. <b>But</b> you won&#39;t get an error in cases you modify table attributes, so please carefully watch <code>sql_engine_in_gofer</code>.</p>

</dd>
<dt id="sql_table_source">sql_table_source</dt>
<dd>

<p>Names a class which is responsible for delivering <i>data sources</i> and <i>available tables</i> (Database Driver related). <i>data sources</i> here refers to <a href="../../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBI.html#data_sources">&quot;data_sources&quot; in DBI</a>, not <code>sql_data_source</code>.</p>

<p>See <a href="#DBI::DBD::SqlEngine::TableSource">&quot;DBI::DBD::SqlEngine::TableSource&quot;</a> for details.</p>

</dd>
<dt id="sql_data_source">sql_data_source</dt>
<dd>

<p>Name a class which is responsible for handling table resources open and completing table names requested via SQL statements.</p>

<p>See <a href="#DBI::DBD::SqlEngine::DataSource">&quot;DBI::DBD::SqlEngine::DataSource&quot;</a> for details.</p>

</dd>
<dt id="sql_dialect">sql_dialect</dt>
<dd>

<p>Controls the dialect understood by SQL::Parser. Possible values (delivery state of SQL::Statement):</p>

<pre><code>  * ANSI
  * CSV
  * AnyData</code></pre>

<p>Defaults to &quot;CSV&quot;. Because an SQL::Parser is instantiated only once and SQL::Parser doesn&#39;t allow one to modify the dialect once instantiated, it&#39;s strongly recommended to set this flag before any statement is executed (best place is connect attribute hash).</p>

</dd>
</dl>

<h2 id="DBI::DBD::SqlEngine::st1">DBI::DBD::SqlEngine::st</h2>

<p>Contains the methods to deal with prepared statement handles:</p>

<dl>

<dt id="bind_param">bind_param</dt>
<dd>

<p>Common routine to bind placeholders to a statement for execution. It is dangerous to override this method without detailed knowledge about the DBI::DBD::SqlEngine internal storage structure.</p>

</dd>
<dt id="execute">execute</dt>
<dd>

<p>Executes a previously prepared statement (with placeholders, if any).</p>

</dd>
<dt id="finish">finish</dt>
<dd>

<p>Finishes a statement handle, discards all buffered results. The prepared statement is not discarded so the statement can be executed again.</p>

</dd>
<dt id="fetch">fetch</dt>
<dd>

<p>Fetches the next row from the result-set. This method may be rewritten in a later version and if it&#39;s overridden in a derived class, the derived implementation should not rely on the storage details.</p>

</dd>
<dt id="fetchrow_arrayref">fetchrow_arrayref</dt>
<dd>

<p>Alias for <code>fetch</code>.</p>

</dd>
<dt id="FETCH1">FETCH</dt>
<dd>

<p>Fetches statement handle attributes. Supported attributes (for full overview see <a href="../../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBI.html#Statement-Handle-Attributes">&quot;Statement Handle Attributes&quot; in DBI</a>) are <code>NAME</code>, <code>TYPE</code>, <code>PRECISION</code> and <code>NULLABLE</code>. Each column is returned as <code>NULLABLE</code> which might be wrong depending on the derived backend storage. If the statement handle has private attributes, they can be fetched using this method, too. <b>Note</b> that statement attributes are not associated with any table used in this statement.</p>

<p>This method usually requires extending in a derived implementation. See <a href="../../../../../lib/perl5/5.26.3/DBD/CSV.html">DBD::CSV</a> or <a href="../../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBD/DBM.html">DBD::DBM</a> for some example.</p>

</dd>
<dt id="STORE1">STORE</dt>
<dd>

<p>Allows storing of statement private attributes. No special handling is currently implemented here.</p>

</dd>
<dt id="rows">rows</dt>
<dd>

<p>Returns the number of rows affected by the last execute. This method might return <code>undef</code>.</p>

</dd>
</dl>

<h2 id="DBI::DBD::SqlEngine::TableSource1">DBI::DBD::SqlEngine::TableSource</h2>

<p>Provides data sources and table information on database driver and database handle level.</p>

<pre><code>  package DBI::DBD::SqlEngine::TableSource;

  sub data_sources ($;$)
  {
    my ( $class, $drh, $attrs ) = @_;
    ...
  }

  sub avail_tables
  {
    my ( $class, $drh ) = @_;
    ...
  }</code></pre>

<p>The <code>data_sources</code> method is called when the user invokes any of the following:</p>

<pre><code>  @ary = DBI-&gt;data_sources($driver);
  @ary = DBI-&gt;data_sources($driver, \%attr);
  
  @ary = $dbh-&gt;data_sources();
  @ary = $dbh-&gt;data_sources(\%attr);</code></pre>

<p>The <code>avail_tables</code> method is called when the user invokes any of the following:</p>

<pre><code>  @names = $dbh-&gt;tables( $catalog, $schema, $table, $type );
  
  $sth = $dbh-&gt;table_info( $catalog, $schema, $table, $type );
  $sth = $dbh-&gt;table_info( $catalog, $schema, $table, $type, \%attr );

  $dbh-&gt;func( &quot;list_tables&quot; );</code></pre>

<p>Every time where an <code>\%attr</code> argument can be specified, this <code>\%attr</code> object&#39;s <code>sql_table_source</code> attribute is preferred over the <code>$dbh</code> attribute or the driver default.</p>

<h2 id="DBI::DBD::SqlEngine::DataSource1">DBI::DBD::SqlEngine::DataSource</h2>

<p>Provides base functionality for dealing with tables. It is primarily designed for allowing transparent access to files on disk or already opened (file-)streams (e.g. for DBD::CSV).</p>

<p>Derived classes shall be restricted to similar functionality, too (e.g. opening streams from an archive, transparently compress/uncompress log files before parsing them,</p>

<pre><code>  package DBI::DBD::SqlEngine::DataSource;

  sub complete_table_name ($$;$)
  {
    my ( $self, $meta, $table, $respect_case ) = @_;
    ...
  }</code></pre>

<p>The method <code>complete_table_name</code> is called when first setting up the <i>meta information</i> for a table:</p>

<pre><code>  &quot;SELECT user.id, user.name, user.shell FROM user WHERE ...&quot;</code></pre>

<p>results in opening the table <code>user</code>. First step of the table open process is completing the name. Let&#39;s imagine you&#39;re having a <a href="../../../../../lib/perl5/5.26.3/DBD/CSV.html">DBD::CSV</a> handle with following settings:</p>

<pre><code>  $dbh-&gt;{sql_identifier_case} = SQL_IC_LOWER;
  $dbh-&gt;{f_ext} = &#39;.lst&#39;;
  $dbh-&gt;{f_dir} = &#39;/data/web/adrmgr&#39;;</code></pre>

<p>Those settings will result in looking for files matching <code>[Uu][Ss][Ee][Rr](\.lst)?$</code> in <code>/data/web/adrmgr/</code>. The scanning of the directory <code>/data/web/adrmgr/</code> and the pattern match check will be done in <code>DBD::File::DataSource::File</code> by the <code>complete_table_name</code> method.</p>

<p>If you intend to provide other sources of data streams than files, in addition to provide an appropriate <code>complete_table_name</code> method, a method to open the resource is required:</p>

<pre><code>  package DBI::DBD::SqlEngine::DataSource;

  sub open_data ($)
  {
    my ( $self, $meta, $attrs, $flags ) = @_;
    ...
  }</code></pre>

<p>After the method <code>open_data</code> has been run successfully, the table&#39;s meta information are in a state which allows the table&#39;s data accessor methods will be able to fetch/store row information. Implementation details heavily depends on the table implementation, whereby the most famous is surely <a href="../../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBD/File.html#DBD::File::Table">DBD::File::Table</a>.</p>

<h2 id="DBI::DBD::SqlEngine::Statement1">DBI::DBD::SqlEngine::Statement</h2>

<p>Derives from DBI::SQL::Nano::Statement for unified naming when deriving new drivers. No additional feature is provided from here.</p>

<h2 id="DBI::DBD::SqlEngine::Table1">DBI::DBD::SqlEngine::Table</h2>

<p>Derives from DBI::SQL::Nano::Table for unified naming when deriving new drivers.</p>

<p>You should consult the documentation of <code>SQL::Eval::Table</code> (see <a href="../../../../../lib/perl5/5.26.3/SQL/Eval.html">SQL::Eval</a>) to get more information about the abstract methods of the table&#39;s base class you have to override and a description of the table meta information expected by the SQL engines.</p>

<dl>

<dt id="bootstrap_table_meta">bootstrap_table_meta</dt>
<dd>

<p>Initializes a table meta structure. Can be safely overridden in a derived class, as long as the <code>SUPER</code> method is called at the end of the overridden method.</p>

<p>It copies the following attributes from the database into the table meta data <code>$dbh-&gt;{ReadOnly}</code> into <code>$meta-&gt;{readonly}</code>, <code>sql_identifier_case</code> and <code>sql_data_source</code> and makes them sticky to the table.</p>

<p>This method should be called before you attempt to map between file name and table name to ensure the correct directory, extension etc. are used.</p>

</dd>
<dt id="init_table_meta">init_table_meta</dt>
<dd>

<p>Initializes more attributes of the table meta data - usually more expensive ones (e.g. those which require class instantiations) - when the file name and the table name could mapped.</p>

</dd>
<dt id="get_table_meta">get_table_meta</dt>
<dd>

<p>Returns the table meta data. If there are none for the required table, a new one is initialized. When after bootstrapping a new <i>table_meta</i> and <a href="#DBI::DBD::SqlEngine::DataSource">completing the table name</a> a mapping can be established between an existing <i>table_meta</i> and the new bootstrapped one, the already existing is used and a mapping shortcut between the recent used table name and the already known table name is hold in <code>$dbh-&gt;{sql_meta_map}</code>. When it fails, nothing is returned. On success, the name of the table and the meta data structure is returned.</p>

</dd>
<dt id="get_table_meta_attr">get_table_meta_attr</dt>
<dd>

<p>Returns a single attribute from the table meta data. If the attribute name appears in <code>%compat_map</code>, the attribute name is updated from there.</p>

</dd>
<dt id="set_table_meta_attr">set_table_meta_attr</dt>
<dd>

<p>Sets a single attribute in the table meta data. If the attribute name appears in <code>%compat_map</code>, the attribute name is updated from there.</p>

</dd>
<dt id="table_meta_attr_changed">table_meta_attr_changed</dt>
<dd>

<p>Called when an attribute of the meta data is modified.</p>

<p>If the modified attribute requires to reset a calculated attribute, the calculated attribute is reset (deleted from meta data structure) and the <i>initialized</i> flag is removed, too. The decision is made based on <code>%register_reset_on_modify</code>.</p>

</dd>
<dt id="register_reset_on_modify">register_reset_on_modify</dt>
<dd>

<p>Allows <code>set_table_meta_attr</code> to reset meta attributes when special attributes are modified. For DBD::File, modifying one of <code>f_file</code>, <code>f_dir</code>, <code>f_ext</code> or <code>f_lockfile</code> will reset <code>f_fqfn</code>. DBD::DBM extends the list for <code>dbm_type</code> and <code>dbm_mldbm</code> to reset the value of <code>dbm_tietype</code>.</p>

<p>If your DBD has calculated values in the meta data area, then call <code>register_reset_on_modify</code>:</p>

<pre><code>    my %reset_on_modify = ( &quot;xxx_foo&quot; =&gt; &quot;xxx_bar&quot; );
    __PACKAGE__-&gt;register_reset_on_modify( \%reset_on_modify );</code></pre>

</dd>
<dt id="register_compat_map">register_compat_map</dt>
<dd>

<p>Allows <code>get_table_meta_attr</code> and <code>set_table_meta_attr</code> to update the attribute name to the current favored one:</p>

<pre><code>    # from DBD::DBM
    my %compat_map = ( &quot;dbm_ext&quot; =&gt; &quot;f_ext&quot; );
    __PACKAGE__-&gt;register_compat_map( \%compat_map );</code></pre>

</dd>
<dt id="open_data">open_data</dt>
<dd>

<p>Called to open the table&#39;s data storage. This is silently forwarded to <code>$meta-&gt;{sql_data_source}-&gt;open_data()</code>.</p>

<p>After this is done, a derived class might add more steps in an overridden <code>open_file</code> method.</p>

</dd>
<dt id="new">new</dt>
<dd>

<p>Instantiates the table. This is done in 3 steps:</p>

<pre><code> 1. get the table meta data
 2. open the data file
 3. bless the table data structure using inherited constructor new</code></pre>

<p>It is not recommended to override the constructor of the table class. Find a reasonable place to add you extensions in one of the above four methods.</p>

</dd>
</dl>

<h1 id="AUTHOR">AUTHOR</h1>

<p>The module DBI::DBD::SqlEngine is currently maintained by</p>

<p>H.Merijn Brand &lt; h.m.brand at xs4all.nl &gt; and Jens Rehsack &lt; rehsack at googlemail.com &gt;</p>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<p>Copyright (C) 2010 by H.Merijn Brand &amp; Jens Rehsack</p>

<p>All rights reserved.</p>

<p>You may freely distribute and/or modify this module under the terms of either the GNU General Public License (GPL) or the Artistic License, as specified in the Perl README file.</p>


</body>

</html>


