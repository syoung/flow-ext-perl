<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../tocTab.js"></script>
<title></title>
<link rel="stylesheet" href="../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#CLASSES">CLASSES</a>
    <ul>
      <li><a href="#DBD::File">DBD::File</a></li>
      <li><a href="#DBD::File::dr1">DBD::File::dr</a></li>
      <li><a href="#DBD::File::db1">DBD::File::db</a></li>
      <li><a href="#DBD::File::st1">DBD::File::st</a></li>
      <li><a href="#DBD::File::TableSource::FileSystem">DBD::File::TableSource::FileSystem</a></li>
      <li><a href="#DBD::File::DataSource::Stream">DBD::File::DataSource::Stream</a></li>
      <li><a href="#DBD::File::DataSource::File">DBD::File::DataSource::File</a></li>
      <li><a href="#DBD::File::Statement">DBD::File::Statement</a></li>
      <li><a href="#DBD::File::Table">DBD::File::Table</a></li>
    </ul>
  </li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>DBD::File::Developers - Developers documentation for DBD::File</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    package DBD::myDriver;

    use base qw( DBD::File );

    sub driver
    {
        ...
        my $drh = $proto-&gt;SUPER::driver ($attr);
        ...
        return $drh-&gt;{class};
        }

    sub CLONE { ... }

    package DBD::myDriver::dr;

    @ISA = qw( DBD::File::dr );

    sub data_sources { ... }
    ...

    package DBD::myDriver::db;

    @ISA = qw( DBD::File::db );

    sub init_valid_attributes { ... }
    sub init_default_attributes { ... }
    sub set_versions { ... }
    sub validate_STORE_attr { my ($dbh, $attrib, $value) = @_; ... }
    sub validate_FETCH_attr { my ($dbh, $attrib) = @_; ... }
    sub get_myd_versions { ... }

    package DBD::myDriver::st;

    @ISA = qw( DBD::File::st );

    sub FETCH { ... }
    sub STORE { ... }

    package DBD::myDriver::Statement;

    @ISA = qw( DBD::File::Statement );

    package DBD::myDriver::Table;

    @ISA = qw( DBD::File::Table );

    my %reset_on_modify = (
        myd_abc =&gt; &quot;myd_foo&quot;,
        myd_mno =&gt; &quot;myd_bar&quot;,
        );
    __PACKAGE__-&gt;register_reset_on_modify (\%reset_on_modify);
    my %compat_map = (
        abc =&gt; &#39;foo_abc&#39;,
        xyz =&gt; &#39;foo_xyz&#39;,
        );
    __PACKAGE__-&gt;register_compat_map (\%compat_map);

    sub bootstrap_table_meta { ... }
    sub init_table_meta { ... }
    sub table_meta_attr_changed { ... }
    sub open_data { ... }

    sub fetch_row { ... }
    sub push_row { ... }
    sub push_names { ... }

    # optimize the SQL engine by add one or more of
    sub update_current_row { ... }
    # or
    sub update_specific_row { ... }
    # or
    sub update_one_row { ... }
    # or
    sub insert_new_row { ... }
    # or
    sub delete_current_row { ... }
    # or
    sub delete_one_row { ... }</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This document describes how DBD developers can write DBD::File based DBI drivers. It supplements <a href="../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBI/DBD.html">DBI::DBD</a> and <a href="../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBI/DBD/SqlEngine/Developers.html">DBI::DBD::SqlEngine::Developers</a>, which you should read first.</p>

<h1 id="CLASSES">CLASSES</h1>

<p>Each DBI driver must provide a package global <code>driver</code> method and three DBI related classes:</p>

<dl>

<dt id="DBD::File::dr">DBD::File::dr</dt>
<dd>

<p>Driver package, contains the methods DBI calls indirectly via DBI interface:</p>

<pre><code>  DBI-&gt;connect (&#39;DBI:DBM:&#39;, undef, undef, {})

  # invokes
  package DBD::DBM::dr;
  @DBD::DBM::dr::ISA = qw( DBD::File::dr );

  sub connect ($$;$$$)
  {
      ...
      }</code></pre>

<p>Similar for <code>data_sources</code> and <code>disconnect_all</code>.</p>

<p>Pure Perl DBI drivers derived from DBD::File do not usually need to override any of the methods provided through the DBD::XXX::dr package however if you need additional initialization in the connect method you may need to.</p>

</dd>
<dt id="DBD::File::db">DBD::File::db</dt>
<dd>

<p>Contains the methods which are called through DBI database handles (<code>$dbh</code>). e.g.,</p>

<pre><code>  $sth = $dbh-&gt;prepare (&quot;select * from foo&quot;);
  # returns the f_encoding setting for table foo
  $dbh-&gt;csv_get_meta (&quot;foo&quot;, &quot;f_encoding&quot;);</code></pre>

<p>DBD::File provides the typical methods required here. Developers who write DBI drivers based on DBD::File need to override the methods <code>set_versions</code> and <code>init_valid_attributes</code>.</p>

</dd>
<dt id="DBD::File::st">DBD::File::st</dt>
<dd>

<p>Contains the methods to deal with prepared statement handles. e.g.,</p>

<pre><code>  $sth-&gt;execute () or die $sth-&gt;errstr;</code></pre>

</dd>
</dl>

<h2 id="DBD::File">DBD::File</h2>

<p>This is the main package containing the routines to initialize DBD::File based DBI drivers. Primarily the <code>DBD::File::driver</code> method is invoked, either directly from DBI when the driver is initialized or from the derived class.</p>

<pre><code>  package DBD::DBM;

  use base qw( DBD::File );

  sub driver
  {
      my ($class, $attr) = @_;
      ...
      my $drh = $class-&gt;SUPER::driver ($attr);
      ...
      return $drh;
      }</code></pre>

<p>It is not necessary to implement your own driver method as long as additional initialization (e.g. installing more private driver methods) is not required. You do not need to call <code>setup_driver</code> as DBD::File takes care of it.</p>

<h2 id="DBD::File::dr1">DBD::File::dr</h2>

<p>The driver package contains the methods DBI calls indirectly via the DBI interface (see <a href="../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBI.html#DBI-Class-Methods">&quot;DBI Class Methods&quot; in DBI</a>).</p>

<p>DBD::File based DBI drivers usually do not need to implement anything here, it is enough to do the basic initialization:</p>

<pre><code>  package DBD:XXX::dr;

  @DBD::XXX::dr::ISA = qw (DBD::File::dr);
  $DBD::XXX::dr::imp_data_size     = 0;
  $DBD::XXX::dr::data_sources_attr = undef;
  $DBD::XXX::ATTRIBUTION = &quot;DBD::XXX $DBD::XXX::VERSION by Hans Mustermann&quot;;</code></pre>

<h2 id="DBD::File::db1">DBD::File::db</h2>

<p>This package defines the database methods, which are called via the DBI database handle <code>$dbh</code>.</p>

<p>Methods provided by DBD::File:</p>

<dl>

<dt id="ping">ping</dt>
<dd>

<p>Simply returns the content of the <code>Active</code> attribute. Override when your driver needs more complicated actions here.</p>

</dd>
<dt id="prepare">prepare</dt>
<dd>

<p>Prepares a new SQL statement to execute. Returns a statement handle, <code>$sth</code> - instance of the DBD:XXX::st. It is neither required nor recommended to override this method.</p>

</dd>
<dt id="FETCH">FETCH</dt>
<dd>

<p>Fetches an attribute of a DBI database object. Private handle attributes must have a prefix (this is mandatory). If a requested attribute is detected as a private attribute without a valid prefix, the driver prefix (written as <code>$drv_prefix</code>) is added.</p>

<p>The driver prefix is extracted from the attribute name and verified against <code>$dbh-&gt;{$drv_prefix . &quot;valid_attrs&quot;}</code> (when it exists). If the requested attribute value is not listed as a valid attribute, this method croaks. If the attribute is valid and readonly (listed in <code>$dbh-&gt;{ $drv_prefix . &quot;readonly_attrs&quot; }</code> when it exists), a real copy of the attribute value is returned. So it&#39;s not possible to modify <code>f_valid_attrs</code> from outside of DBD::File::db or a derived class.</p>

</dd>
<dt id="STORE">STORE</dt>
<dd>

<p>Stores a database private attribute. Private handle attributes must have a prefix (this is mandatory). If a requested attribute is detected as a private attribute without a valid prefix, the driver prefix (written as <code>$drv_prefix</code>) is added. If the database handle has an attribute <code>${drv_prefix}_valid_attrs</code> - for attribute names which are not listed in that hash, this method croaks. If the database handle has an attribute <code>${drv_prefix}_readonly_attrs</code>, only attributes which are not listed there can be stored (once they are initialized). Trying to overwrite such an immutable attribute forces this method to croak.</p>

<p>An example of a valid attributes list can be found in <code>DBD::File::db::init_valid_attributes</code>.</p>

</dd>
<dt id="set_versions">set_versions</dt>
<dd>

<p>This method sets the attribute <code>f_version</code> with the version of DBD::File.</p>

<p>This method is called at the begin of the <code>connect ()</code> phase.</p>

<p>When overriding this method, do not forget to invoke the superior one.</p>

</dd>
<dt id="init_valid_attributes">init_valid_attributes</dt>
<dd>

<p>This method is called after the database handle is instantiated as the first attribute initialization.</p>

<p><code>DBD::File::db::init_valid_attributes</code> initializes the attributes <code>f_valid_attrs</code> and <code>f_readonly_attrs</code>.</p>

<p>When overriding this method, do not forget to invoke the superior one, preferably before doing anything else. Compatibility table attribute access must be initialized here to allow DBD::File to instantiate the map tie:</p>

<pre><code>    # for DBD::CSV
    $dbh-&gt;{csv_meta} = &quot;csv_tables&quot;;
    # for DBD::DBM
    $dbh-&gt;{dbm_meta} = &quot;dbm_tables&quot;;
    # for DBD::AnyData
    $dbh-&gt;{ad_meta}  = &quot;ad_tables&quot;;</code></pre>

</dd>
<dt id="init_default_attributes">init_default_attributes</dt>
<dd>

<p>This method is called after the database handle is instantiated to initialize the default attributes.</p>

<p><code>DBD::File::db::init_default_attributes</code> initializes the attributes <code>f_dir</code>, <code>f_meta</code>, <code>f_meta_map</code>, <code>f_version</code>.</p>

<p>When the derived implementor class provides the attribute to validate attributes (e.g. <code>$dbh-&gt;{dbm_valid_attrs} = {...};</code>) or the attribute containing the immutable attributes (e.g. <code>$dbh-&gt;{dbm_readonly_attrs} = {...};</code>), the attributes <code>drv_valid_attrs</code>, <code>drv_readonly_attrs</code>, <code>drv_version</code> and <code>drv_meta</code> are added (when available) to the list of valid and immutable attributes (where <code>drv_</code> is interpreted as the driver prefix).</p>

<p>If <code>drv_meta</code> is set, an attribute with the name in <code>drv_meta</code> is initialized providing restricted read/write access to the meta data of the tables using <code>DBD::File::TieTables</code> in the first (table) level and <code>DBD::File::TieMeta</code> for the meta attribute level. <code>DBD::File::TieTables</code> uses <code>DBD::DRV::Table::get_table_meta</code> to initialize the second level tied hash on FETCH/STORE. The <code>DBD::File::TieMeta</code> class uses <code>DBD::DRV::Table::get_table_meta_attr</code> to FETCH attribute values and <code>DBD::DRV::Table::set_table_meta_attr</code> to STORE attribute values. This allows it to map meta attributes for compatibility reasons.</p>

</dd>
<dt id="get_single_table_meta">get_single_table_meta</dt>
<dd>

</dd>
<dt id="get_file_meta">get_file_meta</dt>
<dd>

<p>Retrieve an attribute from a table&#39;s meta information. The method signature is <code>get_file_meta ($dbh, $table, $attr)</code>. This method is called by the injected db handle method <code>${drv_prefix}get_meta</code>.</p>

<p>While get_file_meta allows <code>$table</code> or <code>$attr</code> to be a list of tables or attributes to retrieve, get_single_table_meta allows only one table name and only one attribute name. A table name of <code>&#39;.&#39;</code> (single dot) is interpreted as the default table and this will retrieve the appropriate attribute globally from the dbh. This has the same restrictions as <code>$dbh-&gt;{$attrib}</code>.</p>

<p>get_file_meta allows <code>&#39;+&#39;</code> and <code>&#39;*&#39;</code> as wildcards for table names and <code>$table</code> being a regular expression matching against the table names (evaluated without the default table). The table name <code>&#39;*&#39;</code> is <i>all currently known tables, including the default one</i>. The table name <code>&#39;+&#39;</code> is <i>all table names which conform to ANSI file name restrictions</i> (/^[_A-Za-z0-9]+$/).</p>

<p>The table meta information is retrieved using the get_table_meta and get_table_meta_attr methods of the table class of the implementation.</p>

</dd>
<dt id="set_single_table_meta">set_single_table_meta</dt>
<dd>

</dd>
<dt id="set_file_meta">set_file_meta</dt>
<dd>

<p>Sets an attribute in a table&#39;s meta information. The method signature is <code>set_file_meta ($dbh, $table, $attr, $value)</code>. This method is called by the injected db handle method <code>${drv_prefix}set_meta</code>.</p>

<p>While set_file_meta allows <code>$table</code> to be a list of tables and <code>$attr</code> to be a hash of several attributes to set, set_single_table_meta allows only one table name and only one attribute name/value pair.</p>

<p>The wildcard characters for the table name are the same as for get_file_meta.</p>

<p>The table meta information is updated using the get_table_meta and set_table_meta_attr methods of the table class of the implementation.</p>

</dd>
<dt id="clear_file_meta">clear_file_meta</dt>
<dd>

<p>Clears all meta information cached about a table. The method signature is <code>clear_file_meta ($dbh, $table)</code>. This method is called by the injected db handle method <code>${drv_prefix}clear_meta</code>.</p>

</dd>
</dl>

<h2 id="DBD::File::st1">DBD::File::st</h2>

<p>Contains the methods to deal with prepared statement handles:</p>

<dl>

<dt id="FETCH1">FETCH</dt>
<dd>

<p>Fetches statement handle attributes. Supported attributes (for full overview see <a href="../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBI.html#Statement-Handle-Attributes">&quot;Statement Handle Attributes&quot; in DBI</a>) are <code>NAME</code>, <code>TYPE</code>, <code>PRECISION</code> and <code>NULLABLE</code> in case that SQL::Statement is used as SQL execution engine and a statement is successful prepared. When SQL::Statement has additional information about a table, those information are returned. Otherwise, the same defaults as in <a href="../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBI/DBD/SqlEngine.html">DBI::DBD::SqlEngine</a> are used.</p>

<p>This method usually requires extending in a derived implementation. See <a href="../../../../lib/perl5/5.26.3/DBD/CSV.html">DBD::CSV</a> or <a href="../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBD/DBM.html">DBD::DBM</a> for some example.</p>

</dd>
</dl>

<h2 id="DBD::File::TableSource::FileSystem">DBD::File::TableSource::FileSystem</h2>

<p>Provides data sources and table information on database driver and database handle level.</p>

<pre><code>  package DBD::File::TableSource::FileSystem;

  sub data_sources ($;$)
  {
      my ($class, $drh, $attrs) = @_;
      ...
      }

  sub avail_tables
  {
      my ($class, $drh) = @_;
      ...
      }</code></pre>

<p>The <code>data_sources</code> method is called when the user invokes any of the following:</p>

<pre><code>  @ary = DBI-&gt;data_sources ($driver);
  @ary = DBI-&gt;data_sources ($driver, \%attr);
  
  @ary = $dbh-&gt;data_sources ();
  @ary = $dbh-&gt;data_sources (\%attr);</code></pre>

<p>The <code>avail_tables</code> method is called when the user invokes any of the following:</p>

<pre><code>  @names = $dbh-&gt;tables ($catalog, $schema, $table, $type);
  
  $sth   = $dbh-&gt;table_info ($catalog, $schema, $table, $type);
  $sth   = $dbh-&gt;table_info ($catalog, $schema, $table, $type, \%attr);

  $dbh-&gt;func (&quot;list_tables&quot;);</code></pre>

<p>Every time where an <code>\%attr</code> argument can be specified, this <code>\%attr</code> object&#39;s <code>sql_table_source</code> attribute is preferred over the <code>$dbh</code> attribute or the driver default.</p>

<h2 id="DBD::File::DataSource::Stream">DBD::File::DataSource::Stream</h2>

<pre><code>  package DBD::File::DataSource::Stream;

  @DBD::File::DataSource::Stream::ISA = &#39;DBI::DBD::SqlEngine::DataSource&#39;;

  sub complete_table_name
  {
      my ($self, $meta, $file, $respect_case) = @_;
      ...
      }</code></pre>

<p>Clears all meta attributes identifying a file: <code>f_fqfn</code>, <code>f_fqbn</code> and <code>f_fqln</code>. The table name is set according to <code>$respect_case</code> and <code>$meta-&gt;{sql_identifier_case}</code> (SQL_IC_LOWER, SQL_IC_UPPER).</p>

<pre><code>  package DBD::File::DataSource::Stream;

  sub apply_encoding
  {
      my ($self, $meta, $fn) = @_;
      ...
      }</code></pre>

<p>Applies the encoding from <i>meta information</i> (<code>$meta-&gt;{f_encoding}</code>) to the file handled opened in <code>open_data</code>.</p>

<pre><code>  package DBD::File::DataSource::Stream;

  sub open_data
  {
      my ($self, $meta, $attrs, $flags) = @_;
      ...
      }</code></pre>

<p>Opens (<code>dup (2)</code>) the file handle provided in <code>$meta-&gt;{f_file}</code>.</p>

<pre><code>  package DBD::File::DataSource::Stream;

  sub can_flock { ... }</code></pre>

<p>Returns whether <code>flock (2)</code> is available or not (avoids retesting in subclasses).</p>

<h2 id="DBD::File::DataSource::File">DBD::File::DataSource::File</h2>

<pre><code>  package DBD::File::DataSource::File;

  sub complete_table_name ($$;$)
  {
      my ($self, $meta, $table, $respect_case) = @_;
      ...
      }</code></pre>

<p>The method <code>complete_table_name</code> tries to map a filename to the associated table name. It is called with a partially filled meta structure for the resulting table containing at least the following attributes: <code>f_ext</code>, <code>f_dir</code>, <code>f_lockfile</code> and <code>sql_identifier_case</code>.</p>

<p>If a file/table map can be found then this method sets the <code>f_fqfn</code>, <code>f_fqbn</code>, <code>f_fqln</code> and <code>table_name</code> attributes in the meta structure. If a map cannot be found the table name will be undef.</p>

<pre><code>  package DBD::File::DataSource::File;

  sub open_data ($)
  {
      my ($self, $meta, $attrs, $flags) = @_;
      ...
      }</code></pre>

<p>Depending on the attributes set in the table&#39;s meta data, the following steps are performed. Unless <code>f_dontopen</code> is set to a true value, <code>f_fqfn</code> must contain the full qualified file name for the table to work on (file2table ensures this). The encoding in <code>f_encoding</code> is applied if set and the file is opened. If <code>&lt;f_fqln </code>&gt; (full qualified lock name) is set, this file is opened, too. Depending on the value in <code>f_lock</code>, the appropriate lock is set on the opened data file or lock file.</p>

<h2 id="DBD::File::Statement">DBD::File::Statement</h2>

<p>Derives from DBI::SQL::Nano::Statement to provide following method:</p>

<dl>

<dt id="open_table">open_table</dt>
<dd>

<p>Implements the open_table method required by <a href="../../../../lib/perl5/5.26.3/SQL/Statement.html">SQL::Statement</a> and <a href="../../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/DBI/SQL/Nano.html">DBI::SQL::Nano</a>. All the work for opening the file(s) belonging to the table is handled and parametrized in DBD::File::Table. Unless you intend to add anything to the following implementation, an empty DBD::XXX::Statement package satisfies DBD::File.</p>

<pre><code>  sub open_table ($$$$$)
  {
      my ($self, $data, $table, $createMode, $lockMode) = @_;

      my $class = ref $self;
      $class =~ s/::Statement/::Table/;

      my $flags = {
          createMode =&gt; $createMode,
          lockMode   =&gt; $lockMode,
          };
      $self-&gt;{command} eq &quot;DROP&quot; and $flags-&gt;{dropMode} = 1;

      return $class-&gt;new ($data, { table =&gt; $table }, $flags);
      } # open_table</code></pre>

</dd>
</dl>

<h2 id="DBD::File::Table">DBD::File::Table</h2>

<p>Derives from DBI::SQL::Nano::Table and provides physical file access for the table data which are stored in the files.</p>

<dl>

<dt id="bootstrap_table_meta">bootstrap_table_meta</dt>
<dd>

<p>Initializes a table meta structure. Can be safely overridden in a derived class, as long as the <code>SUPER</code> method is called at the end of the overridden method.</p>

<p>It copies the following attributes from the database into the table meta data <code>f_dir</code>, <code>f_ext</code>, <code>f_encoding</code>, <code>f_lock</code>, <code>f_schema</code> and <code>f_lockfile</code> and makes them sticky to the table.</p>

<p>This method should be called before you attempt to map between file name and table name to ensure the correct directory, extension etc. are used.</p>

</dd>
<dt id="init_table_meta">init_table_meta</dt>
<dd>

<p>Initializes more attributes of the table meta data - usually more expensive ones (e.g. those which require class instantiations) - when the file name and the table name could mapped.</p>

</dd>
<dt id="get_table_meta">get_table_meta</dt>
<dd>

<p>Returns the table meta data. If there are none for the required table, a new one is initialized. When it fails, nothing is returned. On success, the name of the table and the meta data structure is returned.</p>

</dd>
<dt id="get_table_meta_attr">get_table_meta_attr</dt>
<dd>

<p>Returns a single attribute from the table meta data. If the attribute name appears in <code>%compat_map</code>, the attribute name is updated from there.</p>

</dd>
<dt id="set_table_meta_attr">set_table_meta_attr</dt>
<dd>

<p>Sets a single attribute in the table meta data. If the attribute name appears in <code>%compat_map</code>, the attribute name is updated from there.</p>

</dd>
<dt id="table_meta_attr_changed">table_meta_attr_changed</dt>
<dd>

<p>Called when an attribute of the meta data is modified.</p>

<p>If the modified attribute requires to reset a calculated attribute, the calculated attribute is reset (deleted from meta data structure) and the <i>initialized</i> flag is removed, too. The decision is made based on <code>%register_reset_on_modify</code>.</p>

</dd>
<dt id="register_reset_on_modify">register_reset_on_modify</dt>
<dd>

<p>Allows <code>set_table_meta_attr</code> to reset meta attributes when special attributes are modified. For DBD::File, modifying one of <code>f_file</code>, <code>f_dir</code>, <code>f_ext</code> or <code>f_lockfile</code> will reset <code>f_fqfn</code>. DBD::DBM extends the list for <code>dbm_type</code> and <code>dbm_mldbm</code> to reset the value of <code>dbm_tietype</code>.</p>

<p>If your DBD has calculated values in the meta data area, then call <code>register_reset_on_modify</code>:</p>

<pre><code>  my %reset_on_modify = (xxx_foo =&gt; &quot;xxx_bar&quot;);
  __PACKAGE__-&gt;register_reset_on_modify (\%reset_on_modify);</code></pre>

</dd>
<dt id="register_compat_map">register_compat_map</dt>
<dd>

<p>Allows <code>get_table_meta_attr</code> and <code>set_table_meta_attr</code> to update the attribute name to the current favored one:</p>

<pre><code>  # from DBD::DBM
  my %compat_map = (dbm_ext =&gt; &quot;f_ext&quot;);
  __PACKAGE__-&gt;register_compat_map (\%compat_map);</code></pre>

</dd>
<dt id="open_file">open_file</dt>
<dd>

<p>Called to open the table&#39;s data file.</p>

<p>Depending on the attributes set in the table&#39;s meta data, the following steps are performed. Unless <code>f_dontopen</code> is set to a true value, <code>f_fqfn</code> must contain the full qualified file name for the table to work on (file2table ensures this). The encoding in <code>f_encoding</code> is applied if set and the file is opened. If <code>&lt;f_fqln </code>&gt; (full qualified lock name) is set, this file is opened, too. Depending on the value in <code>f_lock</code>, the appropriate lock is set on the opened data file or lock file.</p>

<p>After this is done, a derived class might add more steps in an overridden <code>open_file</code> method.</p>

</dd>
<dt id="new">new</dt>
<dd>

<p>Instantiates the table. This is done in 3 steps:</p>

<pre><code> 1. get the table meta data
 2. open the data file
 3. bless the table data structure using inherited constructor new</code></pre>

<p>It is not recommended to override the constructor of the table class. Find a reasonable place to add you extensions in one of the above four methods.</p>

</dd>
<dt id="drop">drop</dt>
<dd>

<p>Implements the abstract table method for the <code>DROP</code> command. Discards table meta data after all files belonging to the table are closed and unlinked.</p>

<p>Overriding this method might be reasonable in very rare cases.</p>

</dd>
<dt id="seek">seek</dt>
<dd>

<p>Implements the abstract table method used when accessing the table from the engine. <code>seek</code> is called every time the engine uses dumb algorithms for iterating over the table content.</p>

</dd>
<dt id="truncate">truncate</dt>
<dd>

<p>Implements the abstract table method used when dumb table algorithms for <code>UPDATE</code> or <code>DELETE</code> need to truncate the table storage after the last written row.</p>

</dd>
</dl>

<p>You should consult the documentation of <code>SQL::Eval::Table</code> (see <a href="../../../../lib/perl5/5.26.3/SQL/Eval.html">SQL::Eval</a>) to get more information about the abstract methods of the table&#39;s base class you have to override and a description of the table meta information expected by the SQL engines.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>The module DBD::File is currently maintained by</p>

<p>H.Merijn Brand &lt; h.m.brand at xs4all.nl &gt; and Jens Rehsack &lt; rehsack at googlemail.com &gt;</p>

<p>The original author is Jochen Wiedmann.</p>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<p>Copyright (C) 2010-2013 by H.Merijn Brand &amp; Jens Rehsack</p>

<p>All rights reserved.</p>

<p>You may freely distribute and/or modify this module under the terms of either the GNU General Public License (GPL) or the Artistic License, as specified in the Perl README file.</p>


</body>

</html>


