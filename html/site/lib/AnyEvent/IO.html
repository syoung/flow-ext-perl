<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li><a href="#RATIONALE">RATIONALE</a></li>
      <li><a href="#ASYNCHRONOUS-VS.-NON-BLOCKING">ASYNCHRONOUS VS. NON-BLOCKING</a></li>
    </ul>
  </li>
  <li><a href="#IMPORT-TAGS">IMPORT TAGS</a></li>
  <li><a href="#API-NOTES">API NOTES</a>
    <ul>
      <li><a href="#NAMING">NAMING</a></li>
      <li><a href="#CALLING-CONVENTIONS-AND-ERROR-REPORTING">CALLING CONVENTIONS AND ERROR REPORTING</a></li>
      <li><a href="#CAVEAT:-RELATIVE-PATHS">CAVEAT: RELATIVE PATHS</a></li>
      <li><a href="#CAVEAT:-OTHER-SHARED-STATE">CAVEAT: OTHER SHARED STATE</a></li>
      <li><a href="#CALLBACKS-MIGHT-BE-CALLED-BEFORE-FUNCTION-RETURNS-TO-CALLER">CALLBACKS MIGHT BE CALLED BEFORE FUNCTION RETURNS TO CALLER</a></li>
      <li><a href="#BEHAVIOUR-AT-PROGRAM-EXIT">BEHAVIOUR AT PROGRAM EXIT</a></li>
    </ul>
  </li>
  <li><a href="#GLOBAL-VARIABLES-AND-FUNCTIONS">GLOBAL VARIABLES AND FUNCTIONS</a></li>
  <li><a href="#ENVIRONMENT-VARIABLES">ENVIRONMENT VARIABLES</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>AnyEvent::IO - the DBI of asynchronous I/O implementations</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>   use AnyEvent::IO;

   # load /etc/passwd, call callback with the file data when done.
   aio_load &quot;/etc/passwd&quot;, sub {
      my ($data) = @_
         or return AE::log error =&gt; &quot;/etc/passwd: $!&quot;;

      warn &quot;/etc/passwd contains &quot;, ($data =~ y/://) , &quot; colons.\n&quot;;
   };

   # the rest of the SYNOPSIS does the same, but with individual I/O calls

   # also import O_XXX flags
   use AnyEvent::IO qw(:DEFAULT :flags);

   my $filedata = AE::cv;

   # first open the file
   aio_open &quot;/etc/passwd&quot;, O_RDONLY, 0, sub {
      my ($fh) = @_
         or return AE::log error =&gt; &quot;/etc/passwd: $!&quot;;

      # now stat the file to get the size
      aio_stat $fh, sub {
         @_
            or return AE::log error =&gt; &quot;/etc/passwd: $!&quot;;

         my $size = -s _;

         # now read all the file data
         aio_read $fh, $size, sub {
            my ($data) = @_
               or return AE::log error =&gt; &quot;/etc/passwd: $!&quot;;

            $size == length $data
               or return AE::log error =&gt; &quot;/etc/passwd: short read, file changed?&quot;;

            # mostly the same as aio_load, above - $data contains
            # the file contents now.
            $filedata-&gt;($data);
         };
      };
   };

   my $passwd = $filedata-&gt;recv;
   warn length $passwd, &quot; octets.\n&quot;;</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>This module provides functions that do I/O in an asynchronous fashion. It is to I/O the same as <a href="../../../../../root/.cpanm/work/1586168094.26023/AnyEvent-7.17/blib/lib/AnyEvent.html">AnyEvent</a> is to event libraries - it only <i>interfaces</i> to other implementations or to a portable pure-perl implementation (which does not, however, do asynchronous I/O).</p>

<p>The only other implementation that is supported (or even known to the author) is <a>IO::AIO</a>, which is used automatically when it can be loaded (via <a>AnyEvent::AIO</a>, which also needs to be installed). If it is not available, then <a href="../../../../../root/.cpanm/work/1586168094.26023/AnyEvent-7.17/blib/lib/AnyEvent/IO.html">AnyEvent::IO</a> falls back to its synchronous pure-perl implementation.</p>

<p>Unlike <a href="../../../../../root/.cpanm/work/1586168094.26023/AnyEvent-7.17/blib/lib/AnyEvent.html">AnyEvent</a>, which model to use is currently decided at module load time, not at first use. Future releases might change this.</p>

<h2 id="RATIONALE">RATIONALE</h2>

<p>While disk I/O often seems &quot;instant&quot; compared to, say, socket I/O, there are many situations where your program can block for extended time periods when doing disk I/O. For example, you access a disk on an NFS server and it is gone - can take ages to respond again, if ever. Or your system is extremely busy because it creates or restores a backup - reading data from disk can then take seconds. Or you use Linux, which for so many years has a close-to-broken VM/IO subsystem that can often induce minutes or more of delay for disk I/O, even under what I would consider light I/O loads.</p>

<p>Whatever the situation, some programs just can&#39;t afford to block for long times (say, half a second or more), because they need to respond as fast as possible.</p>

<p>For those cases, you need asynchronous I/O.</p>

<p>The problem is, AnyEvent itself sometimes reads disk files (for example, when looking at <i>/etc/hosts</i>), and under the above situations, this can bring your program to a complete halt even if your program otherwise takes care to only use asynchronous I/O for everything (e.g. by using <a>IO::AIO</a>).</p>

<p>On the other hand, requiring <a>IO::AIO</a> for AnyEvent is clearly impossible, as AnyEvent promises to stay pure-perl, and the overhead of IO::AIO for small programs would be immense, especially when asynchronous I/O isn&#39;t even needed.</p>

<p>Clearly, this calls for an abstraction layer, and that is what you are looking at right now :-)</p>

<h2 id="ASYNCHRONOUS-VS.-NON-BLOCKING">ASYNCHRONOUS VS. NON-BLOCKING</h2>

<p>Many people are continuously confused on what the difference is between asynchronous I/O and non-blocking I/O. In fact, those two terms are not well defined, which often makes it hard to even talk about the difference. Here is a short guideline that should leave you less confused. It only talks about read operations, but the reasoning works with other I/O operations as well.</p>

<p>Non-blocking I/O means that data is delivered by some external means, automatically - that is, something <i>pushes</i> data towards your file handle, without you having to do anything. Non-blocking means that if your operating system currently has no data (or EOF, or some error) available for you, it will not wait (&quot;block&quot;) as it would normally do, but immediately return with an error (e.g. <code>EWOULDBLOCK</code> - &quot;I would have blocked, but you forbid it&quot;).</p>

<p>Your program can then wait for data to arrive by other means, for example, an I/O watcher which tells you when to re-attempt the read, after which it can try to read again, and so on.</p>

<p>Often, you would expect this to work for disk files as well - if the data isn&#39;t already in memory, one might want to wait for it and then re-attempt the read for example. While this is sound reasoning, the POSIX API does not support this, because disk drives and file systems do not send data &quot;on their own&quot;, and more so, the OS already knows that data is there, it doesn&#39;t need to &quot;wait&quot; until it arrives from some external entity, it only needs to transfer the data from disk to your memory buffer.</p>

<p>So basically, while the concept is sound, the existing OS APIs do not support this. Therefore, it makes no sense to switch a disk file handle into non-blocking mode - it will behave exactly the same as in blocking mode, namely it will block until the data has been read from the disk.</p>

<p>The alternative to non-blocking I/O that actually works with disk files is usually called <i>asynchronous I/O</i>. Asynchronous, because the actual I/O is done while your program does something else: there is no need to call the read function to see if data is there, you only order the read once, and it will notify you when the read has finished and the data is your buffer - all the work is done in the background.</p>

<p>This works with disk files, and even with sockets and other sources. It is, however, not very efficient when used with sources that could be driven in a non-blocking way, because it usually has higher overhead in the OS than non-blocking I/O, because it ties memory buffers for a potentially unlimited time and often only a limited number of operations can be done in parallel.</p>

<p>That&#39;s why asynchronous I/O makes most sense when confronted with disk files, and non-blocking I/O only makes sense with sockets, pipes and similar streaming sources.</p>

<h1 id="IMPORT-TAGS">IMPORT TAGS</h1>

<p>By default, this module exports all <code>aio_</code>xxx functions. In addition, the following import tags can be used:</p>

<pre><code>   :aio       all aio_* functions, same as :DEFAULT
   :flags     the fcntl open flags (O_CREAT, O_RDONLY, ...)</code></pre>

<h1 id="API-NOTES">API NOTES</h1>

<p>The functions in this module are not meant to be the most versatile or the highest-performers (they are not very slow either, of course). They are primarily meant to give users of your code the option to do the I/O asynchronously (by installing <a>IO::AIO</a> and <a>AnyEvent::AIO</a>), without adding a dependency on those modules.</p>

<h2 id="NAMING">NAMING</h2>

<p>All the functions in this module implement an I/O operation, usually with the same or similar name as the Perl built-in that they mimic, but with an <code>aio_</code> prefix. If you like you can think of the <code>aio_</code>xxx functions as &quot;AnyEvent I/O&quot; or &quot;Asynchronous I/O&quot; variants of Perl built-ins.</p>

<h2 id="CALLING-CONVENTIONS-AND-ERROR-REPORTING">CALLING CONVENTIONS AND ERROR REPORTING</h2>

<p>Each function expects a callback as their last argument. The callback is usually called with the result data or result code. An error is usually signalled by passing no arguments to the callback, which is then free to look at <code>$!</code> for the error code.</p>

<p>This makes all of the following forms of error checking valid:</p>

<pre><code>   aio_open ...., sub {
      my $fh = shift   # scalar assignment - will assign undef on error
         or return AE::log error =&gt; &quot;...&quot;;

      my ($fh) = @_    # list assignment - will be 0 elements on error
         or return AE::log error =&gt; &quot;...&quot;;

      @_               # check the number of elements directly
         or return AE::log error =&gt; &quot;...&quot;;</code></pre>

<h2 id="CAVEAT:-RELATIVE-PATHS">CAVEAT: RELATIVE PATHS</h2>

<p>When a path is specified, this path <i>must be an absolute</i> path, unless you make certain that nothing in your process calls <code>chdir</code> or an equivalent function while the request executes.</p>

<h2 id="CAVEAT:-OTHER-SHARED-STATE">CAVEAT: OTHER SHARED STATE</h2>

<p>Changing the <code>umask</code> while any requests execute that create files (or otherwise rely on the current umask) results in undefined behaviour - likewise changing anything else that would change the outcome, such as your effective user or group ID.</p>

<h2 id="CALLBACKS-MIGHT-BE-CALLED-BEFORE-FUNCTION-RETURNS-TO-CALLER">CALLBACKS MIGHT BE CALLED BEFORE FUNCTION RETURNS TO CALLER</h2>

<p>Unlike other functions in the AnyEvent module family, these functions <i>may</i> call your callback instantly, before returning. This should not be a real problem, as these functions never return anything useful.</p>

<h2 id="BEHAVIOUR-AT-PROGRAM-EXIT">BEHAVIOUR AT PROGRAM EXIT</h2>

<p>Both <a href="../../../../../root/.cpanm/work/1586168094.26023/AnyEvent-7.17/blib/lib/AnyEvent/IO/Perl.html">AnyEvent::IO::Perl</a> and <a href="../../../../../root/.cpanm/work/1586168094.26023/AnyEvent-7.17/blib/lib/AnyEvent/IO/IOAIO.html">AnyEvent::IO::IOAIO</a> implementations make sure that operations that have started will be finished on a clean programs exit. That makes programs work that start some I/O operations and then exit. For example this complete program:</p>

<pre><code>   use AnyEvent::IO;

   aio_stat &quot;path1&quot;, sub {
      aio_stat &quot;path2&quot;, sub {
         warn &quot;both stats done\n&quot;;
      };
   };</code></pre>

<p>Starts a <code>stat</code> operation and then exits by &quot;falling off the end&quot; of the program. Nevertheless, <i>both</i> <code>stat</code> operations will be executed, as AnyEvent::IO waits for all outstanding requests to finish and you can start new requests from request callbacks.</p>

<p>In fact, since <a href="../../../../../root/.cpanm/work/1586168094.26023/AnyEvent-7.17/blib/lib/AnyEvent/IO/Perl.html">AnyEvent::IO::Perl</a> is currently synchronous, the program will do both stats before falling off the end, but with <a href="../../../../../root/.cpanm/work/1586168094.26023/AnyEvent-7.17/blib/lib/AnyEvent/IO/IOAIO.html">AnyEvent::IO::IOAIO</a>, the program first falls of the end, then the stats are executed.</p>

<p>While not guaranteed, this behaviour will be present in future versions, if reasonably possible (which is extreemly likely :).</p>

<h1 id="GLOBAL-VARIABLES-AND-FUNCTIONS">GLOBAL VARIABLES AND FUNCTIONS</h1>

<dl>

<dt id="AnyEvent::IO::MODEL">$AnyEvent::IO::MODEL</dt>
<dd>

<p>Contains the package name of the backend I/O model in use - at the moment, this is usually <code>AnyEvent::IO::Perl</code> or <code>AnyEvent::IO::IOAIO</code>.</p>

</dd>
<dt id="aio_load-path-cb--data">aio_load $path, $cb-&gt;($data)</dt>
<dd>

<p>Tries to open <code>$path</code> and read its contents into memory (obviously, should only be used on files that are &quot;small enough&quot;), then passes them to the callback as a string.</p>

<p>Example: load <i>/etc/hosts</i>.</p>

<pre><code>   aio_load &quot;/etc/hosts&quot;, sub {
      my ($hosts) = @_
         or return AE::log error =&gt; &quot;/etc/hosts: $!&quot;;

      AE::log info =&gt; &quot;/etc/hosts contains &quot;, ($hosts =~ y/\n/), &quot; lines\n&quot;;
   };</code></pre>

</dd>
<dt id="aio_open-path-flags-mode-cb--fh">aio_open $path, $flags, $mode, $cb-&gt;($fh)</dt>
<dd>

<p>Tries to open the file specified by <code>$path</code> with the O_XXX-flags <code>$flags</code> (from the Fcntl module, or see below) and the mode <code>$mode</code> (a good value is 0666 for <code>O_CREAT</code>, and <code>0</code> otherwise).</p>

<p>The (normal, standard, perl) file handle associated with the opened file is then passed to the callback.</p>

<p>This works very much like Perl&#39;s <code>sysopen</code> function.</p>

<p>Changing the <code>umask</code> while this request executes results in undefined behaviour - likewise changing anything else that would change the outcome, such as your effective user or group ID.</p>

<p>To avoid having to load <a href="../../../lib/perl5/5.26.3/x86_64-linux-thread-multi/Fcntl.html">Fcntl</a>, this module provides constants for <code>O_RDONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code>, <code>O_CREAT</code>, <code>O_EXCL</code>, <code>O_TRUNC</code> and <code>O_APPEND</code> - you can either access them directly (<code>AnyEvent::IO::O_RDONLY</code>) or import them by specifying the <code>:flags</code> import tag (see SYNOPSIS).</p>

<p>Example: securely open a file in <i>/var/tmp</i>, fail if it exists or is a symlink.</p>

<pre><code>   use AnyEvent::IO qw(:flags);

   aio_open &quot;/var/tmp/mytmp$$&quot;, O_CREAT | O_EXCL | O_RDWR, 0600, sub {
      my ($fh) = @_
         or return AE::log error =&gt; &quot;$! - denial of service attack?&quot;;

      # now we have $fh
   };</code></pre>

</dd>
<dt id="aio_close-fh-cb--success">aio_close $fh, $cb-&gt;($success)</dt>
<dd>

<p>Closes the file handle (yes, close can block your process indefinitely) and passes a true value to the callback on success.</p>

<p>Due to idiosyncrasies in perl, instead of calling <code>close</code>, the file handle might get closed by <code>dup2</code>&#39;ing another file descriptor over it, that is, the <code>$fh</code> might still be open, but can be closed safely afterwards and must not be used for anything.</p>

<p>Example: close a file handle, and dirty as we are, do not even bother to check for errors.</p>

<pre><code>   aio_close $fh, sub { };</code></pre>

</dd>
<dt id="aio_read-fh-length-cb--data">aio_read $fh, $length, $cb-&gt;($data)</dt>
<dd>

<p>Tries to read <code>$length</code> octets from the current position from <code>$fh</code> and passes these bytes to <code>$cb</code>. Otherwise the semantics are very much like those of Perl&#39;s <code>sysread</code>.</p>

<p>If less than <code>$length</code> octets have been read, <code>$data</code> will contain only those bytes actually read. At EOF, <code>$data</code> will be a zero-length string. If an error occurs, then nothing is passed to the callback.</p>

<p>Obviously, multiple <code>aio_read</code>&#39;s or <code>aio_write</code>&#39;s at the same time on file handles sharing the underlying open file description results in undefined behaviour, due to sharing of the current file offset (and less obviously so, because OS X is not thread safe and corrupts data when you try).</p>

<p>Example: read 128 octets from a file.</p>

<pre><code>   aio_read $fh, 128, sub {
      my ($data) = @_
         or return AE::log error &quot;read from fh: $!&quot;;
  
      if (length $data) {
         print &quot;read &quot;, length $data, &quot; octets.\n&quot;;
      } else {
         print &quot;EOF\n&quot;;
      }
   };</code></pre>

</dd>
<dt id="aio_seek-fh-offset-whence-callback--offs">aio_seek $fh, $offset, $whence, $callback-&gt;($offs)</dt>
<dd>

<p>Seeks the filehandle to the new <code>$offset</code>, similarly to Perl&#39;s <code>sysseek</code>. The <code>$whence</code> are the traditional values (<code>0</code> to count from start, <code>1</code> to count from the current position and <code>2</code> to count from the end).</p>

<p>The resulting absolute offset will be passed to the callback on success.</p>

<p>Example: measure the size of the file in the old-fashioned way using seek.</p>

<pre><code>   aio_seek $fh, 0, 2, sub {
      my ($size) = @_
         or return AE::log error =&gt; &quot;seek to end failed: $!&quot;;

      # maybe we need to seek to the beginning again?
      aio_seek $fh, 0, 0, sub {
         # now we are hopefully at the beginning
      };
   };</code></pre>

</dd>
<dt id="aio_write-fh-data-cb--length">aio_write $fh, $data, $cb-&gt;($length)</dt>
<dd>

<p>Tries to write the octets in <code>$data</code> to the current position of <code>$fh</code> and passes the actual number of bytes written to the <code>$cb</code>. Otherwise the semantics are very much like those of Perl&#39;s <code>syswrite</code>.</p>

<p>If less than <code>length $data</code> octets have been written, <code>$length</code> will reflect that. If an error occurs, then nothing is passed to the callback.</p>

<p>Obviously, multiple <code>aio_read</code>&#39;s or <code>aio_write</code>&#39;s at the same time on file handles sharing the underlying open file description results in undefined behaviour, due to sharing of the current file offset (and less obviously so, because OS X is not thread safe and corrupts data when you try).</p>

</dd>
<dt id="aio_truncate-fh_or_path-new_length-cb--success">aio_truncate $fh_or_path, $new_length, $cb-&gt;($success)</dt>
<dd>

<p>Calls <code>truncate</code> on the path or perl file handle and passes a true value to the callback on success.</p>

<p>Example: truncate <i>/etc/passwd</i> to zero length - this only works on systems that support <code>truncate</code>, should not be tried out for obvious reasons and debian will probably open yte another security bug about this example.</p>

<pre><code>   aio_truncate &quot;/etc/passwd&quot;, sub {
      @_
         or return AE::log error =&gt; &quot;/etc/passwd: $! - are you root enough?&quot;;
   };</code></pre>

</dd>
<dt id="aio_utime-fh_or_path-atime-mtime-cb--success">aio_utime $fh_or_path, $atime, $mtime, $cb-&gt;($success)</dt>
<dd>

<p>Calls <code>utime</code> on the path or perl file handle and passes a true value to the callback on success.</p>

<p>The special case of both <code>$atime</code> and <code>$mtime</code> being <code>undef</code> sets the times to the current time, on systems that support this.</p>

<p>Example: try to touch <i>file</i>.</p>

<pre><code>   aio_utime &quot;file&quot;, undef, undef, sub { };</code></pre>

</dd>
<dt id="aio_chown-fh_or_path-uid-gid-cb--success">aio_chown $fh_or_path, $uid, $gid, $cb-&gt;($success)</dt>
<dd>

<p>Calls <code>chown</code> on the path or perl file handle and passes a true value to the callback on success.</p>

<p>If <code>$uid</code> or <code>$gid</code> can be specified as <code>undef</code>, in which case the uid or gid of the file is not changed. This differs from Perl&#39;s <code>chown</code> built-in, which wants <code>-1</code> for this.</p>

<p>Example: update the group of <i>file</i> to 0 (root), but leave the owner alone.</p>

<pre><code>   aio_chown &quot;file&quot;, undef, 0, sub {
      @_
         or return AE::log error =&gt; &quot;chown &#39;file&#39;: $!&quot;;
   };</code></pre>

</dd>
<dt id="aio_chmod-fh_or_path-perms-cb--success">aio_chmod $fh_or_path, $perms, $cb-&gt;($success)</dt>
<dd>

<p>Calls <code>chmod</code> on the path or perl file handle and passes a true value to the callback on success.</p>

<p>Example: change <i>file</i> to be user/group/world-readable, but leave the other flags alone.</p>

<pre><code>   aio_stat &quot;file&quot;, sub {
      @_
         or return AE::log error =&gt; &quot;file: $!&quot;;

      aio_chmod &quot;file&quot;, (stat _)[2] &amp; 07777 | 00444, sub { };
   };</code></pre>

</dd>
<dt id="aio_stat-fh_or_path-cb--success">aio_stat $fh_or_path, $cb-&gt;($success)</dt>
<dd>

</dd>
<dt id="aio_lstat-path-cb--success">aio_lstat $path, $cb-&gt;($success)</dt>
<dd>

<p>Calls <code>stat</code> or <code>lstat</code> on the path or perl file handle and passes a true value to the callback on success.</p>

<p>The stat data will be available by <code>stat</code>&#39;ing the <code>_</code> file handle (e.g. <code>-x _</code>, <code>stat _</code> and so on).</p>

<p>Example: see if we can find the number of subdirectories of <i>/etc</i>.</p>

<pre><code>   aio_stat &quot;/etc&quot;, sub {
      @_
         or return AE::log error =&gt; &quot;/etc: $!&quot;;

      (stat _)[3] &gt;= 2
         or return AE::log warn =&gt; &quot;/etc has low link count - non-POSIX filesystem?&quot;;

      print &quot;/etc has &quot;, (stat _)[3] - 2, &quot; subdirectories.\n&quot;;
   };</code></pre>

</dd>
<dt id="aio_link-oldpath-newpath-cb--success">aio_link $oldpath, $newpath, $cb-&gt;($success)</dt>
<dd>

<p>Calls <code>link</code> on the paths and passes a true value to the callback on success.</p>

<p>Example: link &quot;<i>file</i> to <i>file.bak</i>, then rename <i>file.new</i> over <i>file</i>, to atomically replace it.</p>

<pre><code>   aio_link &quot;file&quot;, &quot;file.bak&quot;, sub {
      @_
         or return AE::log error =&gt; &quot;file: $!&quot;;

      aio_rename &quot;file.new&quot;, &quot;file&quot;, sub {
         @_
            or return AE::log error =&gt; &quot;file.new: $!&quot;;

         print &quot;file atomically replaced by file.new, backup file.bak\n&quot;;
      };
   };</code></pre>

</dd>
<dt id="aio_symlink-oldpath-newpath-cb--success">aio_symlink $oldpath, $newpath, $cb-&gt;($success)</dt>
<dd>

<p>Calls <code>symlink</code> on the paths and passes a true value to the callback on success.</p>

<p>Example: create a symlink &quot;<i>slink</i> containing &quot;random data&quot;.</p>

<pre><code>   aio_symlink &quot;random data&quot;, &quot;slink&quot;, sub {
      @_
         or return AE::log error =&gt; &quot;slink: $!&quot;;
   };</code></pre>

</dd>
<dt id="aio_readlink-path-cb--target">aio_readlink $path, $cb-&gt;($target)</dt>
<dd>

<p>Calls <code>readlink</code> on the paths and passes the link target string to the callback.</p>

<p>Example: read the symlink called Fyslink&gt; and verify that it contains &quot;random data&quot;.</p>

<pre><code>  aio_readlink &quot;slink&quot;, sub {
     my ($target) = @_
        or return AE::log error =&gt; &quot;slink: $!&quot;;

     $target eq &quot;random data&quot;
        or AE::log critical =&gt; &quot;omg, the world will end!&quot;;
  };</code></pre>

</dd>
<dt id="aio_rename-oldpath-newpath-cb--success">aio_rename $oldpath, $newpath, $cb-&gt;($success)</dt>
<dd>

<p>Calls <code>rename</code> on the paths and passes a true value to the callback on success.</p>

<p>See <code>aio_link</code> for an example.</p>

</dd>
<dt id="aio_unlink-path-cb--success">aio_unlink $path, $cb-&gt;($success)</dt>
<dd>

<p>Tries to unlink the object at <code>$path</code> and passes a true value to the callback on success.</p>

<p>Example: try to delete the file <i>tmpfile.dat~</i>.</p>

<pre><code>   aio_unlink &quot;tmpfile.dat~&quot;, sub { };</code></pre>

</dd>
<dt id="aio_mkdir-path-perms-cb--success">aio_mkdir $path, $perms, $cb-&gt;($success)</dt>
<dd>

<p>Calls <code>mkdir</code> on the path with the given permissions <code>$perms</code> (when in doubt, <code>0777</code> is a good value) and passes a true value to the callback on success.</p>

<p>Example: try to create the directory <i>subdir</i> and leave it to whoeveer comes after us to check whether it worked.</p>

<pre><code>   aio_mkdir &quot;subdir&quot;, 0777, sub { };</code></pre>

</dd>
<dt id="aio_rmdir-path-cb--success">aio_rmdir $path, $cb-&gt;($success)</dt>
<dd>

<p>Tries to remove the directory at <code>$path</code> and passes a true value to the callback on success.</p>

<p>Example: try to remove the directory <i>subdir</i> and don&#39;t give a damn if that fails.</p>

<pre><code>   aio_rmdir &quot;subdir&quot;, sub { };</code></pre>

</dd>
<dt id="aio_readdir-path-cb--names">aio_readdir $path, $cb-&gt;(\@names)</dt>
<dd>

<p>Reads all filenames from the directory specified by <code>$path</code> and passes them to the callback, as an array reference with the names (without a path prefix). The <i>.</i> and <i>..</i> names will be filtered out first.</p>

<p>The ordering of the file names is undefined - backends that are capable of it (e.g. <a>IO::AIO</a>) will return the ordering that most likely is fastest to <code>stat</code> through, and furthermore put entries that likely are directories first in the array.</p>

<p>If you need best performance in recursive directory traversal or when looking at really big directories, you are advised to use <a>IO::AIO</a> directly, specifically the <code>aio_readdirx</code> and <code>aio_scandir</code> functions, which have more options to tune performance.</p>

<p>Example: recursively scan a directory hierarchy, silently skip diretcories we couldn&#39;t read and print all others.</p>

<pre><code>   sub scan($); # visibility-in-next statement is not so useful these days
   sub scan($) {
      my ($path) = @_;

      aio_readdir $path, sub {
         my ($names) = @_
            or return;

         print &quot;$path\n&quot;;

         for my $name (@$names) {
            aio_lstat &quot;$path/$name&quot;, sub {
               scan &quot;$path/$name&quot;
                  if -d _;
            };
         }
      };
   }

   scan &quot;/etc&quot;;</code></pre>

</dd>
</dl>

<h1 id="ENVIRONMENT-VARIABLES">ENVIRONMENT VARIABLES</h1>

<p>See the description of <code>PERL_ANYEVENT_IO_MODEL</code> in the <a href="../../../../../root/.cpanm/work/1586168094.26023/AnyEvent-7.17/blib/lib/AnyEvent.html">AnyEvent</a> manpage.</p>

<h1 id="AUTHOR">AUTHOR</h1>

<pre><code> Marc Lehmann &lt;schmorp@schmorp.de&gt;
 http://anyevent.schmorp.de</code></pre>


</body>

</html>


