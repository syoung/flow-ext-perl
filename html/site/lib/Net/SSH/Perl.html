<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../tocTab.js"></script>
<title></title>
<link rel="stylesheet" href="../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#BASIC-USAGE">BASIC USAGE</a>
    <ul>
      <li><a href="#Net::SSH::Perl-new-host-params">Net::SSH::Perl-&gt;new($host, %params)</a></li>
      <li><a href="#ssh-login-user-password-suppress_shell">$ssh-&gt;login([ $user [, $password [, $suppress_shell ] ] ])</a></li>
      <li><a href="#out-err-exit-ssh-cmd-cmd-stdin">($out, $err, $exit) = $ssh-&gt;cmd($cmd, [ $stdin ])</a></li>
      <li><a href="#ssh-shell">$ssh-&gt;shell</a></li>
      <li><a href="#ssh-register_handler-packet_type-subref-args">$ssh-&gt;register_handler($packet_type, $subref [, @args ])</a></li>
    </ul>
  </li>
  <li><a href="#ADVANCED-METHODS">ADVANCED METHODS</a>
    <ul>
      <li><a href="#ssh-config">$ssh-&gt;config</a></li>
      <li><a href="#ssh-sock">$ssh-&gt;sock</a></li>
      <li><a href="#ssh-debug-msg">$ssh-&gt;debug($msg)</a></li>
      <li><a href="#ssh-incoming_data">$ssh-&gt;incoming_data</a></li>
      <li><a href="#ssh-session_id">$ssh-&gt;session_id</a></li>
      <li><a href="#packet-ssh-packet_start-packet_type">$packet = $ssh-&gt;packet_start($packet_type)</a></li>
    </ul>
  </li>
  <li><a href="#SUPPORT">SUPPORT</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Net::SSH::Perl - Perl client Interface to SSH</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    use Net::SSH::Perl;
    my $ssh = Net::SSH::Perl-&gt;new($host);
    $ssh-&gt;login($user, $pass);
    my($stdout, $stderr, $exit) = $ssh-&gt;cmd($cmd);</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p><i>Net::SSH::Perl</i> is an all-Perl module implementing an SSH (Secure Shell) client. It is compatible with both the SSH-1 and SSH-2 protocols.</p>

<p><i>Net::SSH::Perl</i> enables you to simply and securely execute commands on remote machines, and receive the STDOUT, STDERR, and exit status of that remote command. It contains built-in support for various methods of authenticating with the server (password authentication, RSA challenge-response authentication, etc.). It completely implements the I/O buffering, packet transport, and user authentication layers of the SSH protocol, and makes use of external Perl libraries (in the Crypt:: family of modules) to handle encryption of all data sent across the insecure network. It can also read your existing SSH configuration files (<i>/etc/ssh_config</i>, etc.), RSA identity files, ECDSA identity files, Ed25519 identity files, known hosts files, etc.</p>

<p>One advantage to using <i>Net::SSH::Perl</i> over wrapper-style implementations of ssh clients is that it saves on process overhead: you no longer need to fork and execute a separate process in order to connect to an sshd. Depending on the amount of time and memory needed to fork a process, this win can be quite substantial; particularly if you&#39;re running in a persistent Perl environment (<i>mod_perl</i>, for example), where forking a new process is a drain on process and memory resources.</p>

<p>It also simplifies the process of using password-based authentications; when writing a wrapper around <i>ssh</i> you probably need to use <i>Expect</i> to control the ssh client and give it your password. <i>Net::SSH::Perl</i> has built-in support for the authentication protocols, so there&#39;s no longer any hassle of communicating with any external processes.</p>

<p>The SSH2 protocol support (present in <i>Net::SSH::Perl</i> as of version 1.00) is compatible with the SSH2 implementation in OpenSSH, and should also be fully compatible with the &quot;official&quot; SSH implementation. If you find an SSH2 implementation that is not compatible with <i>Net::SSH::Perl</i>, please let me know (email address down in <i>AUTHOR &amp; COPYRIGHTS</i>); it turns out that some SSH2 implementations have subtle differences from others. AES-CTR (<code>aes256-ctr</code>, <code>aes192-ctr</code>, and <code>aes128-ctr</code>) and Chacha20-Poly1305 ciphers are currently supported for SSH2 encryption. Deprecated ciphers AES-CBC (<code>aes256-cbc</code>, <code>aes192-cbc</code>, and <code>aes128-cbc</code>) 3DES (<code>3des-cbc</code>), Blowfish (<code>blowfish-cbc</code>), and RC4 (<code>arcfour</code>) are available but not enabled by default. One can enable them by using the Ciphers options parameter. For example:</p>

<pre><code>    options =&gt; [ &quot;Ciphers +aes256-cbc&quot; ]</code></pre>

<p>Using the + notation will append a cipher to the default ciphers list.</p>

<p>Integrity checking is performed by the <code>hmac-sha2-256</code>, <code>hmac-sha2-512</code>, <code>hmac-sha2-256-etm@openssh.com</code>, or <code>hmac-sha2-512-etm@openssh.com</code> algorithms. The deprecated <code>hmac-sha1</code> or <code>hmac-md5</code> algorithms are available but not enabled by default. Many older SSH server installations still use hmac-sha1 as the main accepted MAC algorithm. To enable this, use the following options parameter:</p>

<pre><code>    options =&gt; [ &quot;MACs +hmac-sha1&quot; ]</code></pre>

<p>Compression, if requested, is limited to Zlib.</p>

<p>Supported server host key algorithms are <code>ssh-ed25519</code>, <code>rsa-sha2-512</code>, <code>rsa-sha2-256</code>, <code>ecdsa-sha2-nistp521</code>, <code>ecdsa-sha2-nistp384</code>, <code>ecdsa-sha2-nistp256</code>, and <code>ssh-rsa</code>. Deprecated <code>ssh-dss</code> is supported but not enabled by default. It can be enabled with the options parameter:</p>

<pre><code>    options =&gt; [ &quot;HostKeyAlgorithms +ssh-dss&quot; ]</code></pre>

<p>Supported SSH2 public key authentication algorithms are the same.</p>

<p>Supported Key Exchange (KEX) algorithms are <code>diffie-hellman-group1-sha1</code>, <code>diffie-hellman-group14-sha1</code>, c&lt;diffie-hellman-group14-sha256&gt;, <code>diffie-hellman-group16-sha512</code>, <code>diffie-hellman-group18-sha512</code>, <code>diffie-hellman-group-exchange-sha256</code>, <code>diffie-hellman-group-exchange-sha1</code>, and <code>curve25519-sha256@libssh.org</code>/<code>curve25519-sha256</code>. The <code>diffie-hellman-group1-sha1</code> algorithm is disabled by default, but can be activated via the options parameter:</p>

<pre><code>    options =&gt; [ &quot;KexAlgorithms +diffie-hellman-group1-sha1&quot; ]</code></pre>

<p>If you&#39;re looking for SFTP support, take a look at <i>Net::SFTP</i>, which provides a full-featured Perl implementation of SFTP, and sits on top of <i>Net::SSH::Perl</i>. SFTP requires the usage of the SSH2 protocol.</p>

<h1 id="BASIC-USAGE">BASIC USAGE</h1>

<p>Usage of <i>Net::SSH::Perl</i> is very simple.</p>

<h2 id="Net::SSH::Perl-new-host-params">Net::SSH::Perl-&gt;new($host, %params)</h2>

<p>To set up a new connection, call the <i>new</i> method, which connects to <i>$host</i> and returns a <i>Net::SSH::Perl</i> object.</p>

<p><i>new</i> accepts the following named parameters in <i>%params</i>:</p>

<ul>

<li><p>protocol</p>

<p>The protocol you wish to use for the connection: should be either <code>2</code>, <code>1</code>, <code>&#39;1,2&#39;</code> or <code>&#39;2,1&#39;</code>. The first two say, quite simply, &quot;only use this version of the protocol&quot; (SSH-2 or SSH-1, respectively). The latter two specify that either protocol can be used, but that one protocol (the first in the comma-separated list) is preferred over the other.</p>

<p>For this reason, it&#39;s &quot;safer&quot; to use the latter two protocol specifications, because they ensure that either way, you&#39;ll be able to connect; if your server doesn&#39;t support the first protocol listed, the second will be used. (Presumably your server will support at least one of the two protocols. :)</p>

<p>The default value is <code>&#39;1,2&#39;</code>, for compatibility with OpenSSH; this means that the client will use SSH-1 if the server supports SSH-1. Of course, you can always override this using a user/global configuration file, or through using this constructor argument.</p>

</li>
<li><p>cipher</p>

<p>Specifies the name of the encryption cipher that you wish to use for this connection. This must be one of the supported ciphers; specifying an unsupported cipher will give you an error when you enter algorithm negotiation (in either SSH-1 or SSH-2).</p>

<p>In SSH-1, the supported cipher names are <i>IDEA</i>, <i>DES</i>, <i>DES3</i>, and <i>Blowfish</i>; in SSH-2, the supported ciphers are <i>aes256-ctr</i>, <i>aes192-ctr</i>, <i>aes128-ctr</i>, <i>chacha20-poly1305@openssh.com</i>. <i>arcfour</i>, <i>blowfish-cbc</i>, and <i>3des-cbc</i> are deprecated and are not enabled by default. <i>aes256-cbc</i>, <i>aes192-cbc</i>, and <i>aes128-cbc</i> are also supported but not enabled by default as CBC is no longer considered secure.</p>

<p>The default SSH-1 cipher is <i>IDEA</i>; the default SSH-2 ciphers are <i>aes256-ctr</i>, <i>aes192-ctr</i>, <i>aes128-ctr</i>, <i>chacha20-poly1305@openssh.com</i>.</p>

</li>
<li><p>ciphers</p>

<p>Like <i>cipher</i>, this is a method of setting the cipher you wish to use for a particular SSH connection; but this corresponds to the <i>Ciphers</i> configuration option, where <i>cipher</i> corresponds to <i>Cipher</i>. This also applies only in SSH-2.</p>

<p>This should be a comma-separated list of SSH-2 cipher names; the list of cipher names is listed above in <i>cipher</i>.</p>

<p>This defaults to: <i>chacha20-poly1305@openssh.com,aes256-ctr,aes192-ctr,aes128-ctr</i>.</p>

</li>
<li><p>port</p>

<p>The port of the <i>sshd</i> daemon to which you wish to connect; if not specified, this is assumed to be the default <i>ssh</i> port.</p>

</li>
<li><p>debug</p>

<p>Set to a true value if you want debugging messages printed out while the connection is being opened. These can be helpful in trying to determine connection problems, etc. The messages are similar (and in some cases exact) to those written out by the <i>ssh</i> client when you use the <i>-v</i> option.</p>

<p>Defaults to false.</p>

</li>
<li><p>interactive</p>

<p>Set to a true value if you&#39;re using <i>Net::SSH::Perl</i> interactively. This is used in determining whether or not to display password prompts, for example. It&#39;s basically the inverse of the <i>BatchMode</i> parameter in ssh configuration.</p>

<p>Defaults to false.</p>

</li>
<li><p>privileged</p>

<p>Set to a true value if you want to bind to a privileged port locally. You&#39;ll need this if you plan to use Rhosts or Rhosts-RSA authentication, because the remote server requires the client to connect on a privileged port. Of course, to bind to a privileged port you&#39;ll need to be root.</p>

<p>If you don&#39;t provide this parameter, and <i>Net::SSH::Perl</i> detects that you&#39;re running as root, this will automatically be set to true. Otherwise it defaults to false.</p>

</li>
<li><p>identity_files</p>

<p>A list of identity files to be used in pubkey authentication. The value of this argument should be a reference to an array of strings, each string identifying the location of an identity file. Each identity file will be tested against the server until the client finds one that authenticates successfully.</p>

<p>If you don&#39;t provide this, SSH1 authentication defaults to using <i>$ENV{HOME}/.ssh/identity</i>, and SSH2 authentication defaults to the three files <i>$ENV{HOME}/.ssh/id_ed25519</i>, <i>$ENV{HOME}/.ssh/id_ecdsa</i>, and <i>$ENV{HOME}/.ssh/id_rsa</i>.</p>

</li>
<li><p>strict_host_key_checking</p>

<p>This corresponds to the <i>StrictHostKeyChecking</i> ssh configuration option. Allowed values are <i>no</i>, <i>yes</i>, or <i>ask</i>. <i>no</i> disables host key checking, e.g., if you connect to a virtual host that answers to multiple IP addresses. <i>yes</i> or <i>ask</i> enable it, and when it fails in <i>interactive</i> mode, you are asked whether to continue. The host is then added to the list of known hosts.</p>

</li>
<li><p>compression</p>

<p>If set to a true value, compression is turned on for the session (assuming that the server supports it).</p>

<p>Compression is off by default.</p>

<p>Note that compression requires that you have the <i>Compress::Zlib</i> module installed on your system. If the module can&#39;t be loaded successfully, compression is disabled; you&#39;ll receive a warning stating as much if you having debugging on (<i>debug</i> set to 1), and you try to turn on compression.</p>

</li>
<li><p>compression_level</p>

<p>Specifies the compression level to use if compression is enabled (note that you must provide both the <i>compression</i> and <i>compression_level</i> arguments to set the level; providing only this argument will not turn on encryption).</p>

<p>This setting is only applicable to SSH-1; the compression level for SSH-2 Zlib compression is always set to 6.</p>

<p>The default value is 6.</p>

</li>
<li><p>use_pty</p>

<p>Set this to 1 if you want to request a pseudo tty on the remote machine. This is really only useful if you&#39;re setting up a shell connection (see the <i>shell</i> method, below); and in that case, unless you&#39;ve explicitly declined a pty (by setting <i>use_pty</i> to 0), this will be set automatically to 1. In other words, you probably won&#39;t need to use this, often.</p>

<p>The default is 1 if you&#39;re starting up a shell, and 0 otherwise.</p>

</li>
<li><p>terminal_mode_string</p>

<p>Specify the POSIX terminal mode string to send when use_pty is set. By default the only mode set is the VEOF character to 0x04 (opcode 5, value 0x00000004). See RFC 4254 section 8 for complete details on this value.</p>

</li>
<li><p>no_append_veof</p>

<p>(SSH-2 only) Set this to 1 if you specified use_pty and do not want Ctrl-D (0x04) appended twice to the end of your input string. On most systems, these bytes cause the terminal driver to return &quot;EOF&quot; when standard input is read. Without them, many programs that read from standard input will hang after consuming all the data on STDIN.</p>

<p>No other modifications are made to input data. If your data contains 0x04 bytes, you may need to escape them.</p>

<p>Set this to 0 if you have raw terminal data to specify on standard input, and you have terminated it correctly.</p>

</li>
<li><p>options</p>

<p>Used to specify additional options to the configuration settings; useful for specifying options for which there is no separate constructor argument. This is analogous to the <b>-o</b> command line flag to the <i>ssh</i> program.</p>

<p>If used, the value should be a reference to a list of option directives in the format used in the config file. For example:</p>

<pre><code>    my $ssh = Net::SSH::Perl-&gt;new(&quot;host&quot;, options =&gt; [
        &quot;BatchMode yes&quot;, &quot;RhostsAuthentication no&quot; ]);</code></pre>

<p>Available options are:</p>

<pre><code>    BindAddress
    Host
    BatchMode
    ChallengeResponseAuthentication
    CheckHostIP
    Cipher
    Ciphers*
    Compression
    CompressionLevel
    DSAAuthentication
    FingerprintHash
    GlobalKnownHostsFile
    HashKnownHosts
    HostKeyAlgorithms*
    HostName
    IdentityFile
    KexAlgorithms*
    MACs*
    NumberOfPasswordPrompts
    PasswordAuthentication
    PasswordPromptHost
    PasswordPromptLogin
    Port
    Protocol
    RhostsAuthentication
    RhostsRSAAuthentication
    RSAAuthentication
    StrictHostKeyChecking
    UpdateHostKeys
    UsePrivilegedPort
    User
    UserKnownHostsFile</code></pre>

<p>* Indicates the +/- wildcard notation may be used.</p>

<p>For example:</p>

<pre><code>    MACs +hmac-sha1</code></pre>

<p>will add hmac-sha1 to the default MACs list.</p>

<p>Or:</p>

<pre><code>    Ciphers +aes*-cbc</code></pre>

<p>will add aes128-cbc, aes192-cbc, and aes256-cbc to the default Ciphers</p>

<p>While:</p>

<pre><code>    KexAlgorithms -*-sha512
    </code></pre>

<p>will remove all algorithms that end in -sha512 from the default list.</p>

</li>
</ul>

<h2 id="ssh-login-user-password-suppress_shell">$ssh-&gt;login([ $user [, $password [, $suppress_shell ] ] ])</h2>

<p>Sets the username and password to be used when authenticating with the <i>sshd</i> daemon. The username <i>$user</i> is required for all authentication protocols (to identify yourself to the remote server), but if you don&#39;t supply it the username of the user executing the program is used.</p>

<p>The password <i>$password</i> is needed only for password authentication (it&#39;s not used for passphrases on encrypted RSA/DSA identity files, though perhaps it should be). And if you&#39;re running in an interactive session and you&#39;ve not provided a password, you&#39;ll be prompted for one.</p>

<p>By default, Net::SSH::Perl will open a channel with a shell on it. This is usually what you want. If you are tunneling another protocol over SSH, however, you may want to prevent this behavior. Passing a true value in <i>$suppress_shell</i> will prevent the shell channel from being opened (SSH2 only).</p>

<h2 id="out-err-exit-ssh-cmd-cmd-stdin">($out, $err, $exit) = $ssh-&gt;cmd($cmd, [ $stdin ])</h2>

<p>Runs the command <i>$cmd</i> on the remote server and returns the <i>stdout</i>, <i>stderr</i>, and exit status of that command.</p>

<p>If <i>$stdin</i> is provided, it&#39;s supplied to the remote command <i>$cmd</i> on standard input.</p>

<p>NOTE: the SSH-1 protocol does not support running multiple commands per connection, unless those commands are chained together so that the remote shell can evaluate them. Because of this, a new socket connection is created each time you call <i>cmd</i>, and disposed of afterwards. In other words, this code:</p>

<pre><code>    my $ssh = Net::SSH::Perl-&gt;new(&quot;host1&quot;);
    $ssh-&gt;login(&quot;user1&quot;, &quot;pass1&quot;);

    $ssh-&gt;cmd(&quot;foo&quot;);
    $ssh-&gt;cmd(&quot;bar&quot;);</code></pre>

<p>will actually connect to the <i>sshd</i> on the first invocation of <i>cmd</i>, then disconnect; then connect again on the second invocation of <i>cmd</i>, then disconnect again.</p>

<p>Note that this does <i>not</i> apply to the SSH-2 protocol. SSH-2 fully supports running more than one command over the same connection.</p>

<h2 id="ssh-shell">$ssh-&gt;shell</h2>

<p>Opens up an interactive shell on the remote machine and connects it to your STDIN. This is most effective when used with a pseudo tty; otherwise you won&#39;t get a command line prompt, and it won&#39;t look much like a shell. For this reason--unless you&#39;ve specifically declined one--a pty will be requested from the remote machine, even if you haven&#39;t set the <i>use_pty</i> argument to <i>new</i> (described above).</p>

<p>This is really only useful in an interactive program.</p>

<p>In addition, you&#39;ll probably want to set your terminal to raw input before calling this method. This lets <i>Net::SSH::Perl</i> process each character and send it off to the remote machine, as you type it.</p>

<p>To do so, use <i>Term::ReadKey</i> in your program:</p>

<pre><code>    use Term::ReadKey;
    ReadMode(&#39;raw&#39;);
    $ssh-&gt;shell;
    ReadMode(&#39;restore&#39;);</code></pre>

<p>In fact, you may want to place the <code>restore</code> line in an <i>END</i> block, in case your program exits prior to reaching that line.</p>

<p>If you need an example, take a look at <i>eg/pssh</i>, which uses almost this exact code to implement an ssh shell.</p>

<h2 id="ssh-register_handler-packet_type-subref-args">$ssh-&gt;register_handler($packet_type, $subref [, @args ])</h2>

<p>Registers an anonymous subroutine handler <i>$subref</i> to handle packets of type <i>$packet_type</i> during the client loop. The subroutine will be called when packets of type <i>$packet_type</i> are received, and in addition to the standard arguments (see below), will receive any additional arguments in <i>@args</i>, if specified.</p>

<p>The client loop is entered after the client has sent a command to the remote server, and after any STDIN data has been sent; it consists of reading packets from the server (STDOUT packets, STDERR packets, etc.) until the server sends the exit status of the command executed remotely. At this point the client exits the client loop and disconnects from the server.</p>

<p>When you call the <i>cmd</i> method, the client loop by default simply sticks STDOUT packets into a scalar variable and returns that value to the caller. It does the same for STDERR packets, and for the process exit status. (See the docs for <i>cmd</i>).</p>

<p>You can, however, override that default behavior, and instead process the data itself as it is sent to the client. You do this by calling the <i>register_handler</i> method and setting up handlers to be called at specific times.</p>

<p>The behavior of the <i>register_handler</i> method differs between the <i>Net::SSH::Perl</i> SSH-1 and SSH-2 implementations. This is so because of the differences between the protocols (all client-server communications in SSH-2 go through the channel mechanism, which means that input packets are processed differently).</p>

<ul>

<li><p>SSH-1 Protocol</p>

<p>In the SSH-1 protocol, you should call <i>register_handler</i> with two arguments: a packet type <i>$packet_type</i> and a subroutine reference <i>$subref</i>. Your subroutine will receive as arguments the <i>Net::SSH::Perl::SSH1</i> object (with an open connection to the ssh3), and a <i>Net::SSH::Perl::Packet</i> object, which represents the packet read from the server. It will also receive any additional arguments <i>@args</i> that you pass to <i>register_handler</i>; this can be used to give your callback functions access to some of your otherwise private variables, if desired. <i>$packet_type</i> should be an integer constant; you can import the list of constants into your namespace by explicitly loading the <i>Net::SSH::Perl::Constants</i> module:</p>

<pre><code>    use Net::SSH::Perl::Constants qw( :msg );</code></pre>

<p>This will load all of the <i>MSG</i> constants into your namespace so that you can use them when registering the handler. To do that, use this method. For example:</p>

<pre><code>    $ssh-&gt;register_handler(SSH_SMSG_STDOUT_DATA, sub {
        my($ssh, $packet) = @_;
        print &quot;I received this: &quot;, $packet-&gt;get_str;
    });</code></pre>

<p>To learn about the methods that you can call on the packet object, take a look at the <i>Net::SSH::Perl::Packet</i> docs, as well as the <i>Net::SSH::Perl::Buffer</i> docs (the <i>get_*</i> and <i>put_*</i> methods).</p>

<p>Obviously, writing these handlers requires some knowledge of the contents of each packet. For that, read through the SSH RFC, which explains each packet type in detail. There&#39;s a <i>get_*</i> method for each datatype that you may need to read from a packet.</p>

<p>Take a look at <i>eg/remoteinteract.pl</i> for an example of interacting with a remote command through the use of <i>register_handler</i>.</p>

</li>
<li><p>SSH-2 Protocol</p>

<p>In the SSH-2 protocol, you call <i>register_handler</i> with two arguments: a string identifying the type of handler you wish to create, and a subroutine reference. The &quot;string&quot; should be, at this point, either <code>stdout</code> or <code>stderr</code>; any other string will be silently ignored. <code>stdout</code> denotes that you wish to handle STDOUT data sent from the server, and <code>stderr</code> that you wish to handle STDERR data.</p>

<p>Your subroutine reference will be passed two arguments: a <i>Net::SSH::Perl::Channel</i> object that represents the open channel on which the data was sent, and a <i>Net::SSH::Perl::Buffer</i> object containing data read from the server. In addition to these two arguments, the callback will be passed any additional arguments <i>@args</i> that you passed to <i>register_handler</i>; this can be used to give your callback functions to otherwise private variables, if desired.</p>

<p>This illustrates the two main differences between the SSH-1 and SSH-2 implementations. The first difference is that, as mentioned above, all communication between server and client is done through channels, which are built on top of the main connection between client and server. Multiple channels are multiplexed over the same connection. The second difference is that, in SSH-1, you are processing the actual packets as they come in; in SSH-2, the packets have already been processed somewhat, and their contents stored in buffers--you are processing those buffers.</p>

<p>The above example (the <i>I received this</i> example) of using <i>register_handler</i> in SSH-1 would look like this in SSH-2:</p>

<pre><code>    $ssh-&gt;register_handler(&quot;stdout&quot;, sub {
        my($channel, $buffer) = @_;
        print &quot;I received this: &quot;, $buffer-&gt;bytes;
    });</code></pre>

<p>As you can see, it&#39;s quite similar to the form used in SSH-1, but with a few important differences, due to the differences mentioned above between SSH-1 and SSH-2.</p>

</li>
</ul>

<h1 id="ADVANCED-METHODS">ADVANCED METHODS</h1>

<p>Your basic SSH needs will hopefully be met by the methods listed above. If they&#39;re not, however, you may want to use some of the additional methods listed here. Some of these are aimed at end-users, while others are probably more useful for actually writing an authentication module, or a cipher, etc.</p>

<h2 id="ssh-config">$ssh-&gt;config</h2>

<p>Returns the <i>Net::SSH::Perl::Config</i> object managing the configuration data for this SSH object. This is constructed from data passed in to the constructor <i>new</i> (see above), merged with data read from the user and system configuration files. See the <i>Net::SSH::Perl::Config</i> docs for details on methods you can call on this object (you&#39;ll probably be more interested in the <i>get</i> and <i>set</i> methods).</p>

<h2 id="ssh-sock">$ssh-&gt;sock</h2>

<p>Returns the socket connection to sshd. If your client is not connected, dies.</p>

<h2 id="ssh-debug-msg">$ssh-&gt;debug($msg)</h2>

<p>If debugging is turned on for this session (see the <i>debug</i> parameter to the <i>new</i> method, above), writes <i>$msg</i> to <code>STDERR</code>. Otherwise nothing is done.</p>

<h2 id="ssh-incoming_data">$ssh-&gt;incoming_data</h2>

<p>Incoming data buffer, an object of type <i>Net::SSH::Perl::Buffer</i>. Returns the buffer object.</p>

<p>The idea behind this is that we our socket is non-blocking, so we buffer input and periodically check back to see if we&#39;ve read a full packet. If we have a full packet, we rip it out of the incoming data buffer and process it, returning it to the caller who presumably asked for it.</p>

<p>This data &quot;belongs&quot; to the underlying packet layer in <i>Net::SSH::Perl::Packet</i>. Unless you really know what you&#39;re doing you probably don&#39;t want to disturb that data.</p>

<h2 id="ssh-session_id">$ssh-&gt;session_id</h2>

<p>Returns the session ID, which is generated from the server&#39;s host and server keys, and from the check bytes that it sends along with the keys. The server may require the session ID to be passed along in other packets, as well (for example, when responding to RSA challenges).</p>

<h2 id="packet-ssh-packet_start-packet_type">$packet = $ssh-&gt;packet_start($packet_type)</h2>

<p>Starts building a new packet of type <i>$packet_type</i>. This is just a handy method for lazy people. Internally it calls <i>Net::SSH::Perl::Packet::new</i>, so take a look at those docs for more details.</p>

<h1 id="SUPPORT">SUPPORT</h1>

<p>For samples/tutorials, take a look at the scripts in <i>eg/</i> in the distribution directory.</p>

<p>Please report bugs at: https://github.com/lkinley/Net-SSH-Perl/issues</p>

<h1 id="AUTHOR">AUTHOR</h1>

<p>Development on V2 by Lance Kinley lkinley@rythmos.com</p>

<p>Previous maintainers were: David Robins, dbrobins@cpan.org Dave Rolsky, autarch@urth.org.</p>

<p>Originally written by Benjamin Trott.</p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<p>Copyright (c) 2015-2017 Rythmos, Inc. Copyright (c) 2001-2003 Benjamin Trott, Copyright (c) 2003-2008 David Rolsky. Copyright (c) David Robins. All rights reserved. This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.</p>

<p>The full text of the license can be found in the LICENSE file included with this module.</p>


</body>

</html>


