<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../../tocTab.js"></script>
<title></title>
<link rel="stylesheet" href="../../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#GET-AND-PUT-METHODS">GET AND PUT METHODS</a>
    <ul>
      <li><a href="#buffer-get_int8">$buffer-&gt;get_int8</a></li>
      <li><a href="#buffer-put_int8">$buffer-&gt;put_int8</a></li>
      <li><a href="#buffer-get_int16">$buffer-&gt;get_int16</a></li>
      <li><a href="#buffer-put_int16-integer">$buffer-&gt;put_int16($integer)</a></li>
      <li><a href="#buffer-get_int32">$buffer-&gt;get_int32</a></li>
      <li><a href="#buffer-put_int32-integer">$buffer-&gt;put_int32($integer)</a></li>
      <li><a href="#buffer-get_char">$buffer-&gt;get_char</a></li>
      <li><a href="#buffer-put_char-bytes">$buffer-&gt;put_char($bytes)</a></li>
      <li><a href="#buffer-get_str">$buffer-&gt;get_str</a></li>
      <li><a href="#buffer-put_str-string">$buffer-&gt;put_str($string)</a></li>
      <li><a href="#buffer-get_mp_int">$buffer-&gt;get_mp_int</a></li>
      <li><a href="#buffer-put_mp_int-mp_int">$buffer-&gt;put_mp_int($mp_int)</a></li>
    </ul>
  </li>
  <li><a href="#LOW-LEVEL-METHODS">LOW-LEVEL METHODS</a>
    <ul>
      <li><a href="#Net::SSH::Perl::Buffer-new">Net::SSH::Perl::Buffer-&gt;new</a></li>
      <li><a href="#buffer-append-bytes">$buffer-&gt;append($bytes)</a></li>
      <li><a href="#buffer-empty">$buffer-&gt;empty</a></li>
      <li><a href="#buffer-bytes-offset-length-replacement">$buffer-&gt;bytes([ $offset [, $length [, $replacement ]]])</a></li>
      <li><a href="#buffer-length">$buffer-&gt;length</a></li>
      <li><a href="#buffer-offset">$buffer-&gt;offset</a></li>
      <li><a href="#buffer-dump">$buffer-&gt;dump</a></li>
      <li><a href="#buffer-insert_padding">$buffer-&gt;insert_padding</a></li>
    </ul>
  </li>
  <li><a href="#AUTHOR-COPYRIGHTS">AUTHOR &amp; COPYRIGHTS</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Net::SSH::Perl::Buffer - Low-level read/write buffer class</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>    use Net::SSH::Perl::Buffer (@args);
    my $buffer = Net::SSH::Perl::Buffer-&gt;new;

    ## Add a 32-bit integer.
    $buffer-&gt;put_int32(10932930);

    ## Get it back.
    my $int = $buffer-&gt;get_int32;</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p><i>Net::SSH::Perl::Buffer</i> implements the low-level binary buffer needed by the <i>Net::SSH::Perl</i> suite. Specifically, a <i>Net::SSH::Perl::Buffer</i> object is what makes up the data segment of a packet transferred between server and client (a <i>Net::SSH::Perl::Packet</i> object).</p>

<p>Buffers contain integers, strings, characters, etc. Because of the use of GMP integers in SSH, buffers can also contain multiple-precision integers (represented internally by <i>Math::GMP</i> objects).</p>

<p>Note: the method documentation here is in what some might call a slightly backwards order. The reason for this is that the get and put methods (listed first) are probably what most users/developers of <i>Net::SSH::Perl</i> need to care about; they&#39;re high-level methods used to get/put data from the buffer. The other methods (<i>LOW-LEVEL METHODS</i>) are much more low-level, and typically you won&#39;t need to use them explicitly.</p>

<h1 id="GET-AND-PUT-METHODS">GET AND PUT METHODS</h1>

<p>All of the <i>get_*</i> and <i>put_*</i> methods respect the internal offset state in the buffer object. This means that, for example, if you call <i>get_int16</i> twice in a row, you can be ensured that you&#39;ll get the next two 16-bit integers in the buffer. You don&#39;t need to worry about the number of bytes a certain piece of data takes up, for example.</p>

<h2 id="buffer-get_int8">$buffer-&gt;get_int8</h2>

<p>Returns the next 8-bit integer from the buffer (which is really just the ASCII code for the next character/byte in the buffer).</p>

<h2 id="buffer-put_int8">$buffer-&gt;put_int8</h2>

<p>Appends an 8-bit integer to the buffer (which is really just the character corresponding to that integer, in ASCII).</p>

<h2 id="buffer-get_int16">$buffer-&gt;get_int16</h2>

<p>Returns the next 16-bit integer from the buffer.</p>

<h2 id="buffer-put_int16-integer">$buffer-&gt;put_int16($integer)</h2>

<p>Appends a 16-bit integer to the buffer.</p>

<h2 id="buffer-get_int32">$buffer-&gt;get_int32</h2>

<p>Returns the next 32-bit integer from the buffer.</p>

<h2 id="buffer-put_int32-integer">$buffer-&gt;put_int32($integer)</h2>

<p>Appends a 32-bit integer to the buffer.</p>

<h2 id="buffer-get_char">$buffer-&gt;get_char</h2>

<p>More appropriately called <i>get_byte</i>, perhaps, this returns the next byte from the buffer.</p>

<h2 id="buffer-put_char-bytes">$buffer-&gt;put_char($bytes)</h2>

<p>Appends a byte (or a sequence of bytes) to the buffer. There is no restriction on the length of the byte string <i>$bytes</i>; if it makes you uncomfortable to call <i>put_char</i> to put multiple bytes, you can instead call this method as <i>put_chars</i>. It&#39;s the same thing.</p>

<h2 id="buffer-get_str">$buffer-&gt;get_str</h2>

<p>Returns the next &quot;string&quot; from the buffer. A string here is represented as the length of the string (a 32-bit integer) followed by the string itself.</p>

<h2 id="buffer-put_str-string">$buffer-&gt;put_str($string)</h2>

<p>Appends a string (32-bit integer length and the string itself) to the buffer.</p>

<h2 id="buffer-get_mp_int">$buffer-&gt;get_mp_int</h2>

<p>Returns a bigint object representing a multiple precision integer read from the buffer. Depending on the protocol, the object is either of type <i>Math::GMP</i> (SSH1) or a binary string (SSH2).</p>

<p>You determine which protocol will be in use when you <i>use</i> the module: specify <i>SSH1</i> or <i>SSH2</i> to load the proper <i>get</i> and <i>put</i> routines for bigints:</p>

<pre><code>    use Net::SSH::Perl::Buffer qw( SSH1 );</code></pre>

<h2 id="buffer-put_mp_int-mp_int">$buffer-&gt;put_mp_int($mp_int)</h2>

<p>Appends a multiple precision integer to the buffer. Depending on the protocol in use, <i>$mp_int</i> should be either a <i>Math::GMP</i> object (SSH1) or a binary string (SSH2). The format in which the integer is stored in the buffer differs between the protocols, as well.</p>

<h1 id="LOW-LEVEL-METHODS">LOW-LEVEL METHODS</h1>

<h2 id="Net::SSH::Perl::Buffer-new">Net::SSH::Perl::Buffer-&gt;new</h2>

<p>Creates a new buffer object and returns it. The buffer is empty.</p>

<p>This method takes no arguments.</p>

<h2 id="buffer-append-bytes">$buffer-&gt;append($bytes)</h2>

<p>Appends raw data <i>$bytes</i> to the end of the in-memory buffer. Generally you don&#39;t need to use this method unless you&#39;re initializing an empty buffer, because when you need to add data to a buffer you should generally use one of the <i>put_*</i> methods.</p>

<h2 id="buffer-empty">$buffer-&gt;empty</h2>

<p>Empties out the buffer object.</p>

<h2 id="buffer-bytes-offset-length-replacement">$buffer-&gt;bytes([ $offset [, $length [, $replacement ]]])</h2>

<p>Behaves exactly like the <i>substr</i> built-in function, except on the buffer <i>$buffer</i>. Given no arguments, <i>bytes</i> returns the entire buffer; given one argument <i>$offset</i>, returns everything from that position to the end of the string; given <i>$offset</i> and <i>$length</i>, returns the segment of the buffer starting at <i>$offset</i> and consisting of <i>$length</i> bytes; and given all three arguments, replaces that segment with <i>$replacement</i>.</p>

<p>This is a very low-level method, and you generally won&#39;t need to use it.</p>

<p>Also be warned that you should not intermix use of this method with use of the <i>get_*</i> and <i>put_*</i> methods; the latter classes of methods maintain internal state of the buffer offset where arguments will be gotten from and put, respectively. The <i>bytes</i> method gives no thought to this internal offset state.</p>

<h2 id="buffer-length">$buffer-&gt;length</h2>

<p>Returns the length of the buffer object.</p>

<h2 id="buffer-offset">$buffer-&gt;offset</h2>

<p>Returns the internal offset state.</p>

<p>If you insist on intermixing calls to <i>bytes</i> with calls to the <i>get_*</i> and <i>put_*</i> methods, you&#39;ll probably want to use this method to get some status on that internal offset.</p>

<h2 id="buffer-dump">$buffer-&gt;dump</h2>

<p>Returns a hex dump of the buffer.</p>

<h2 id="buffer-insert_padding">$buffer-&gt;insert_padding</h2>

<p>A helper method: pads out the buffer so that the length of the transferred packet will be evenly divisible by 8, which is a requirement of the SSH protocol.</p>

<h1 id="AUTHOR-COPYRIGHTS">AUTHOR &amp; COPYRIGHTS</h1>

<p>Please see the Net::SSH::Perl manpage for author, copyright, and license information.</p>


</body>

</html>


