<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../tocTab.js"></script>
<title></title>
<link rel="stylesheet" href="../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#METHODS">METHODS</a>
    <ul>
      <li><a href="#new">new</a></li>
      <li><a href="#generate_key">generate_key</a></li>
      <li><a href="#import_key">import_key</a></li>
      <li><a href="#import_key_raw">import_key_raw</a></li>
      <li><a href="#export_key_der">export_key_der</a></li>
      <li><a href="#export_key_pem">export_key_pem</a></li>
      <li><a href="#export_key_jwk">export_key_jwk</a></li>
      <li><a href="#export_key_jwk_thumbprint">export_key_jwk_thumbprint</a></li>
      <li><a href="#export_key_raw">export_key_raw</a></li>
      <li><a href="#encrypt">encrypt</a></li>
      <li><a href="#decrypt">decrypt</a></li>
      <li><a href="#sign_message">sign_message</a></li>
      <li><a href="#sign_message_rfc7518">sign_message_rfc7518</a></li>
      <li><a href="#verify_message">verify_message</a></li>
      <li><a href="#verify_message_rfc7518">verify_message_rfc7518</a></li>
      <li><a href="#sign_hash">sign_hash</a></li>
      <li><a href="#sign_hash_rfc7518">sign_hash_rfc7518</a></li>
      <li><a href="#verify_hash">verify_hash</a></li>
      <li><a href="#verify_hash_rfc7518">verify_hash_rfc7518</a></li>
      <li><a href="#shared_secret">shared_secret</a></li>
      <li><a href="#is_private">is_private</a></li>
      <li><a href="#size">size</a></li>
      <li><a href="#key2hash">key2hash</a></li>
      <li><a href="#curve2hash">curve2hash</a></li>
    </ul>
  </li>
  <li><a href="#FUNCTIONS">FUNCTIONS</a>
    <ul>
      <li><a href="#ecc_encrypt">ecc_encrypt</a></li>
      <li><a href="#ecc_decrypt">ecc_decrypt</a></li>
      <li><a href="#ecc_sign_message">ecc_sign_message</a></li>
      <li><a href="#ecc_verify_message">ecc_verify_message</a></li>
      <li><a href="#ecc_sign_hash">ecc_sign_hash</a></li>
      <li><a href="#ecc_verify_hash">ecc_verify_hash</a></li>
      <li><a href="#ecc_shared_secret">ecc_shared_secret</a></li>
    </ul>
  </li>
  <li><a href="#OpenSSL-interoperability">OpenSSL interoperability</a>
    <ul>
      <li><a href="#Sign-by-OpenSSL-verify-by-Crypt::PK::ECC">Sign by OpenSSL, verify by Crypt::PK::ECC</a></li>
      <li><a href="#Sign-by-Crypt::PK::ECC-verify-by-OpenSSL">Sign by Crypt::PK::ECC, verify by OpenSSL</a></li>
      <li><a href="#Keys-generated-by-Crypt::PK::ECC">Keys generated by Crypt::PK::ECC</a></li>
      <li><a href="#Keys-generated-by-OpenSSL">Keys generated by OpenSSL</a></li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Crypt::PK::ECC - Public key cryptography based on EC</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code> ### OO interface

 #Encryption: Alice
 my $pub = Crypt::PK::ECC-&gt;new(&#39;Bob_pub_ecc1.der&#39;);
 my $ct = $pub-&gt;encrypt(&quot;secret message&quot;);
 #
 #Encryption: Bob (received ciphertext $ct)
 my $priv = Crypt::PK::ECC-&gt;new(&#39;Bob_priv_ecc1.der&#39;);
 my $pt = $priv-&gt;decrypt($ct);

 #Signature: Alice
 my $priv = Crypt::PK::ECC-&gt;new(&#39;Alice_priv_ecc1.der&#39;);
 my $sig = $priv-&gt;sign_message($message);
 #
 #Signature: Bob (received $message + $sig)
 my $pub = Crypt::PK::ECC-&gt;new(&#39;Alice_pub_ecc1.der&#39;);
 $pub-&gt;verify_message($sig, $message) or die &quot;ERROR&quot;;

 #Shared secret
 my $priv = Crypt::PK::ECC-&gt;new(&#39;Alice_priv_ecc1.der&#39;);
 my $pub = Crypt::PK::ECC-&gt;new(&#39;Bob_pub_ecc1.der&#39;);
 my $shared_secret = $priv-&gt;shared_secret($pub);

 #Key generation
 my $pk = Crypt::PK::ECC-&gt;new();
 $pk-&gt;generate_key(&#39;secp160r1&#39;);
 my $private_der = $pk-&gt;export_key_der(&#39;private&#39;);
 my $public_der = $pk-&gt;export_key_der(&#39;public&#39;);
 my $private_pem = $pk-&gt;export_key_pem(&#39;private&#39;);
 my $public_pem = $pk-&gt;export_key_pem(&#39;public&#39;);
 my $public_raw = $pk-&gt;export_key_raw(&#39;public&#39;);

 ### Functional interface

 #Encryption: Alice
 my $ct = ecc_encrypt(&#39;Bob_pub_ecc1.der&#39;, &quot;secret message&quot;);
 #Encryption: Bob (received ciphertext $ct)
 my $pt = ecc_decrypt(&#39;Bob_priv_ecc1.der&#39;, $ct);

 #Signature: Alice
 my $sig = ecc_sign_message(&#39;Alice_priv_ecc1.der&#39;, $message);
 #Signature: Bob (received $message + $sig)
 ecc_verify_message(&#39;Alice_pub_ecc1.der&#39;, $sig, $message) or die &quot;ERROR&quot;;

 #Shared secret
 my $shared_secret = ecc_shared_secret(&#39;Alice_priv_ecc1.der&#39;, &#39;Bob_pub_ecc1.der&#39;);</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>The module provides a set of core ECC functions as well as implementation of ECDSA and ECDH.</p>

<p>Supports elliptic curves <code>y^2 = x^3 + a*x + b</code> over prime fields <code>Fp = Z/pZ</code> (binary fields not supported).</p>

<h1 id="METHODS">METHODS</h1>

<h2 id="new">new</h2>

<pre><code> my $pk = Crypt::PK::ECC-&gt;new();
 #or
 my $pk = Crypt::PK::ECC-&gt;new($priv_or_pub_key_filename);
 #or
 my $pk = Crypt::PK::ECC-&gt;new(\$buffer_containing_priv_or_pub_key);</code></pre>

<p>Support for password protected PEM keys</p>

<pre><code> my $pk = Crypt::PK::ECC-&gt;new($priv_pem_key_filename, $password);
 #or
 my $pk = Crypt::PK::ECC-&gt;new(\$buffer_containing_priv_pem_key, $password);</code></pre>

<h2 id="generate_key">generate_key</h2>

<p>Uses Yarrow-based cryptographically strong random number generator seeded with random data taken from <code>/dev/random</code> (UNIX) or <code>CryptGenRandom</code> (Win32).</p>

<pre><code> $pk-&gt;generate_key($curve_name);
 #or
 $pk-&gt;generate_key($hashref_with_curve_params);</code></pre>

<p>The following predefined <code>$curve_name</code> values are supported:</p>

<pre><code> # curves from http://www.ecc-brainpool.org/download/Domain-parameters.pdf
 &#39;brainpoolp160r1&#39;
 &#39;brainpoolp192r1&#39;
 &#39;brainpoolp224r1&#39;
 &#39;brainpoolp256r1&#39;
 &#39;brainpoolp320r1&#39;
 &#39;brainpoolp384r1&#39;
 &#39;brainpoolp512r1&#39;
 # curves from http://www.secg.org/collateral/sec2_final.pdf
 &#39;secp112r1&#39;
 &#39;secp112r2&#39;
 &#39;secp128r1&#39;
 &#39;secp128r2&#39;
 &#39;secp160k1&#39;
 &#39;secp160r1&#39;
 &#39;secp160r2&#39;
 &#39;secp192k1&#39;
 &#39;secp192r1&#39;   ... same as nistp192, prime192v1
 &#39;secp224k1&#39;
 &#39;secp224r1&#39;   ... same as nistp224
 &#39;secp256k1&#39;   ... used by Bitcoin
 &#39;secp256r1&#39;   ... same as nistp256, prime256v1
 &#39;secp384r1&#39;   ... same as nistp384
 &#39;secp521r1&#39;   ... same as nistp521
 #curves from http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf
 &#39;nistp192&#39;    ... same as secp192r1, prime192v1
 &#39;nistp224&#39;    ... same as secp224r1
 &#39;nistp256&#39;    ... same as secp256r1, prime256v1
 &#39;nistp384&#39;    ... same as secp384r1
 &#39;nistp521&#39;    ... same as secp521r1
 # curves from ANS X9.62
 &#39;prime192v1&#39;   ... same as nistp192, secp192r1
 &#39;prime192v2&#39;
 &#39;prime192v3&#39;
 &#39;prime239v1&#39;
 &#39;prime239v2&#39;
 &#39;prime239v3&#39;
 &#39;prime256v1&#39;   ... same as nistp256, secp256r1</code></pre>

<p>Using custom curve parameters:</p>

<pre><code> $pk-&gt;generate_key({ prime    =&gt; &#39;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF&#39;,
                     A        =&gt; &#39;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC&#39;,
                     B        =&gt; &#39;22123DC2395A05CAA7423DAECCC94760A7D462256BD56916&#39;,
                     Gx       =&gt; &#39;7D29778100C65A1DA1783716588DCE2B8B4AEE8E228F1896&#39;,
                     Gy       =&gt; &#39;38A90F22637337334B49DCB66A6DC8F9978ACA7648A943B0&#39;,
                     order    =&gt; &#39;FFFFFFFFFFFFFFFFFFFFFFFF7A62D031C83F4294F640EC13&#39;,
                     cofactor =&gt; 1 });</code></pre>

<p>See <a href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf">http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf</a>, <a href="http://www.secg.org/collateral/sec2_final.pdf">http://www.secg.org/collateral/sec2_final.pdf</a>, <a href="http://www.ecc-brainpool.org/download/Domain-parameters.pdf">http://www.ecc-brainpool.org/download/Domain-parameters.pdf</a></p>

<h2 id="import_key">import_key</h2>

<p>Loads private or public key in DER or PEM format.</p>

<pre><code> $pk-&gt;import_key($filename);
 #or
 $pk-&gt;import_key(\$buffer_containing_key);</code></pre>

<p>Support for password protected PEM keys:</p>

<pre><code> $pk-&gt;import_key($filename, $password);
 #or
 $pk-&gt;import_key(\$buffer_containing_key, $password);</code></pre>

<p>Loading private or public keys form perl hash:</p>

<pre><code> $pk-&gt;import_key($hashref);

 # the $hashref is either a key exported via key2hash
 $pk-&gt;import_key({
      curve_A        =&gt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC&quot;,
      curve_B        =&gt; &quot;1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45&quot;,
      curve_bits     =&gt; 160,
      curve_bytes    =&gt; 20,
      curve_cofactor =&gt; 1,
      curve_Gx       =&gt; &quot;4A96B5688EF573284664698968C38BB913CBFC82&quot;,
      curve_Gy       =&gt; &quot;23A628553168947D59DCC912042351377AC5FB32&quot;,
      curve_order    =&gt; &quot;0100000000000000000001F4C8F927AED3CA752257&quot;,
      curve_prime    =&gt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF&quot;,
      k              =&gt; &quot;B0EE84A749FE95DF997E33B8F333E12101E824C3&quot;,
      pub_x          =&gt; &quot;5AE1ACE3ED0AEA9707CE5C0BCE014F6A2F15023A&quot;,
      pub_y          =&gt; &quot;895D57E992D0A15F88D6680B27B701F615FCDC0F&quot;,
 });

 # or with the curve defined just by name
 $pk-&gt;import_key({
      curve_name =&gt; &quot;secp160r1&quot;,
      k          =&gt; &quot;B0EE84A749FE95DF997E33B8F333E12101E824C3&quot;,
      pub_x      =&gt; &quot;5AE1ACE3ED0AEA9707CE5C0BCE014F6A2F15023A&quot;,
      pub_y      =&gt; &quot;895D57E992D0A15F88D6680B27B701F615FCDC0F&quot;,
 });

 # or a hash with items corresponding to JWK (JSON Web Key)
 $pk-&gt;import_key({
       kty =&gt; &quot;EC&quot;,
       crv =&gt; &quot;P-256&quot;,
       x   =&gt; &quot;MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4&quot;,
       y   =&gt; &quot;4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM&quot;,
       d   =&gt; &quot;870MB6gfuTJ4HtUnUvYMyJpr5eUZNP4Bk43bVdj3eAE&quot;,
 });</code></pre>

<p>Supported key formats:</p>

<pre><code> # all formats can be loaded from a file
 my $pk = Crypt::PK::ECC-&gt;new($filename);

 # or from a buffer containing the key
 my $pk = Crypt::PK::ECC-&gt;new(\$buffer_with_key);</code></pre>

<ul>

<li><p>EC private keys with with all curve parameters</p>

<pre><code> -----BEGIN EC PRIVATE KEY-----
 MIIB+gIBAQQwCKEAcA6cIt6CGfyLKm57LyXWv2PgTjydrHSbvhDJTOl+7bzUW8DS
 rgSdtSPONPq1oIIBWzCCAVcCAQEwPAYHKoZIzj0BAQIxAP//////////////////
 ///////////////////////+/////wAAAAAAAAAA/////zB7BDD/////////////
 /////////////////////////////v////8AAAAAAAAAAP////wEMLMxL6fiPufk
 mI4Fa+P4LRkYHZxu/oFBEgMUCI9QE4daxlY5jYou0Z0qhcjt0+wq7wMVAKM1kmqj
 GaJ6HQCJamdzpIJ6zaxzBGEEqofKIr6LBTeOscce8yCtdG4dO2KLp5uYWfdB4IJU
 KjhVAvJdv1UpbDpUXjhydgq3NhfeSpYmLG9dnpi/kpLcKfj0Hb0omhR86doxE7Xw
 uMAKYLHOHX6BnXpDHXyQ6g5fAjEA////////////////////////////////x2NN
 gfQ3Ld9YGg2ySLCneuzsGWrMxSlzAgEBoWQDYgAEeGyHPLmHcszPQ9MIIYnznpzi
 QbvuJtYSjCqtIGxDfzgcLcc3nCc5tBxo+qX6OJEzcWdDAC0bwplY+9Z9jHR3ylNy
 ovlHoK4ItdWkVO8NH89SLSRyVuOF8N5t3CHIo93B
 -----END EC PRIVATE KEY-----</code></pre>

</li>
<li><p>EC private keys with curve defined by OID (short form)</p>

<pre><code> -----BEGIN EC PRIVATE KEY-----
 MHcCAQEEIBG1c3z52T8XwMsahGVdOZWgKCQJfv+l7djuJjgetdbDoAoGCCqGSM49
 AwEHoUQDQgAEoBUyo8CQAFPeYPvv78ylh5MwFZjTCLQeb042TjiMJxG+9DLFmRSM
 lBQ9T/RsLLc+PmpB1+7yPAR+oR5gZn3kJQ==
 -----END EC PRIVATE KEY-----</code></pre>

</li>
<li><p>EC private keys with curve defined by OID + compressed form (supported since: CryptX-0.059)</p>

<pre><code> -----BEGIN EC PRIVATE KEY-----
 MFcCAQEEIBG1c3z52T8XwMsahGVdOZWgKCQJfv+l7djuJjgetdbDoAoGCCqGSM49
 AwEHoSQDIgADoBUyo8CQAFPeYPvv78ylh5MwFZjTCLQeb042TjiMJxE=
 -----END EC PRIVATE KEY-----</code></pre>

</li>
<li><p>EC private keys in password protected PEM format</p>

<pre><code> -----BEGIN EC PRIVATE KEY-----
 Proc-Type: 4,ENCRYPTED
 DEK-Info: AES-128-CBC,98245C830C9282F7937E13D1D5BA11EC

 0Y85oZ2+BKXYwrkBjsZdj6gnhOAfS5yDVmEsxFCDug+R3+Kw3QvyIfO4MVo9iWoA
 D7wtoRfbt2OlBaLVl553+6QrUoa2DyKf8kLHQs1x1/J7tJOMM4SCXjlrOaToQ0dT
 o7fOnjQjHne16pjgBVqGilY/I79Ab85AnE4uw7vgEucBEiU0d3nrhwuS2Opnhzyx
 009q9VLDPwY2+q7tXjTqnk9mCmQgsiaDJqY09wlauSukYPgVuOJFmi1VdkRSDKYZ
 rUUsQvz6Q6Q+QirSlfHna+NhUgQ2eyhGszwcP6NU8iqIxI+NCwfFVuAzw539yYwS
 8SICczoC/YRlaclayXuomQ==
 -----END EC PRIVATE KEY-----</code></pre>

</li>
<li><p>EC public keys with all curve parameters</p>

<pre><code> -----BEGIN PUBLIC KEY-----
 MIH1MIGuBgcqhkjOPQIBMIGiAgEBMCwGByqGSM49AQECIQD/////////////////
 ///////////////////+///8LzAGBAEABAEHBEEEeb5mfvncu6xVoGKVzocLBwKb
 /NstzijZWfKBWxb4F5hIOtp3JqPEZV2k+/wOEQio/Re0SKaFVBmcR9CP+xDUuAIh
 AP////////////////////66rtzmr0igO7/SXozQNkFBAgEBA0IABITjF/nKK3jg
 pjmBRXKWAv7ekR1Ko/Nb5FFPHXjH0sDrpS7qRxFALwJHv7ylGnekgfKU3vzcewNs
 lvjpBYt0Yg4=
 -----END PUBLIC KEY-----</code></pre>

</li>
<li><p>EC public keys with curve defined by OID (short form)</p>

<pre><code> -----BEGIN PUBLIC KEY-----
 MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEoBUyo8CQAFPeYPvv78ylh5MwFZjT
 CLQeb042TjiMJxG+9DLFmRSMlBQ9T/RsLLc+PmpB1+7yPAR+oR5gZn3kJQ==
 -----END PUBLIC KEY-----</code></pre>

</li>
<li><p>EC public keys with curve defined by OID + public point in compressed form (supported since: CryptX-0.059)</p>

<pre><code> -----BEGIN PUBLIC KEY-----
 MDkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDIgADoBUyo8CQAFPeYPvv78ylh5MwFZjT
 CLQeb042TjiMJxE=
 -----END PUBLIC KEY-----</code></pre>

</li>
<li><p>PKCS#8 private keys with all curve parameters</p>

<pre><code> -----BEGIN PRIVATE KEY-----
 MIIBMAIBADCB0wYHKoZIzj0CATCBxwIBATAkBgcqhkjOPQEBAhkA////////////
 /////////v//////////MEsEGP////////////////////7//////////AQYIhI9
 wjlaBcqnQj2uzMlHYKfUYiVr1WkWAxUAxGloRDXes3jEtlypWR4qV2MFmi4EMQR9
 KXeBAMZaHaF4NxZYjc4ri0rujiKPGJY4qQ8iY3M3M0tJ3LZqbcj5l4rKdkipQ7AC
 GQD///////////////96YtAxyD9ClPZA7BMCAQEEVTBTAgEBBBiKolTGIsTgOCtl
 6dpdos0LvuaExCDFyT6hNAMyAAREwaCX0VY1LZxLW3G75tmft4p9uhc0J7/+NGaP
 DN3Tr7SXkT9+co2a+8KPJhQy10k=
 -----END PRIVATE KEY-----</code></pre>

</li>
<li><p>PKCS#8 private keys with curve defined by OID (short form)</p>

<pre><code> -----BEGIN PRIVATE KEY-----
 MG8CAQAwEwYHKoZIzj0CAQYIKoZIzj0DAQMEVTBTAgEBBBjFP/caeQV4WO3fnWWS
 f917PGzwtypd/t+hNAMyAATSg6pBT7RO6l/p+aKcrFsGuthUdfwJWS5V3NGcVt1b
 lEHQYjWya2YnHaPq/iMFa7A=
 -----END PRIVATE KEY-----</code></pre>

</li>
<li><p>PKCS#8 encrypted private keys - password protected keys (supported since: CryptX-0.059)</p>

<pre><code> -----BEGIN ENCRYPTED PRIVATE KEY-----
 MIGYMBwGCiqGSIb3DQEMAQMwDgQINApjTa6oFl0CAggABHi+59l4d4e6KtG9yci2
 BSC65LEsQSnrnFAExfKptNU1zMFsDLCRvDeDQDbxc6HlfoxyqFL4SmH1g3RvC/Vv
 NfckdL5O2L8MRnM+ljkFtV2Te4fszWcJFdd7KiNOkPpn+7sWLfzQdvhHChLKUzmz
 4INKZyMv/G7VpZ0=
 -----END ENCRYPTED PRIVATE KEY-----</code></pre>

</li>
<li><p>EC public key from X509 certificate</p>

<pre><code> -----BEGIN CERTIFICATE-----
 MIIBdDCCARqgAwIBAgIJAL2BBClDEnnOMAoGCCqGSM49BAMEMBcxFTATBgNVBAMM
 DFRlc3QgQ2VydCBFQzAgFw0xNzEyMzAyMDMzNDFaGA8zMDE3MDUwMjIwMzM0MVow
 FzEVMBMGA1UEAwwMVGVzdCBDZXJ0IEVDMFYwEAYHKoZIzj0CAQYFK4EEAAoDQgAE
 KvkL2r5xZp7RzxLQJK+6tn/7lic+L70e1fmNbHOdxRaRvbK5G0AQWrdsbjJb92Ni
 lCQk2+w/i+VuS2Q3MSR5TaNQME4wHQYDVR0OBBYEFGbJkDyKgaMcIGHS8/WuqIVw
 +R8sMB8GA1UdIwQYMBaAFGbJkDyKgaMcIGHS8/WuqIVw+R8sMAwGA1UdEwQFMAMB
 Af8wCgYIKoZIzj0EAwQDSAAwRQIhAJtOsmrM+gJpImoynAyqTN+7myL71uxd+YeC
 6ze4MnzWAiBQi5/BqEr/SQ1+BC2TPtswvJPRFh2ZvT/6Km3gKoNVXQ==
 -----END CERTIFICATE-----</code></pre>

</li>
<li><p>SSH public EC keys</p>

<pre><code> ecdsa-sha2-nistp256 AAAAE2VjZHNhLXNoYTItbmlzdHAyNT...T3xYfJIs=</code></pre>

</li>
<li><p>SSH public EC keys (RFC-4716 format)</p>

<pre><code> ---- BEGIN SSH2 PUBLIC KEY ----
 Comment: &quot;521-bit ECDSA, converted from OpenSSH&quot;
 AAAAE2VjZHNhLXNoYTItbmlzdHA1MjEAAAAIbmlzdHA1MjEAAACFBAFk35srteP9twCwYK
 vU9ovMBi77Dd6lEBPrFaMEb0CZdZ5MC3nSqflGHRWkSbUpjdPdO7cYQNpK9YXHbNSO5hbU
 1gFZgyiGFxwJYYz8NAjedBXMgyH4JWplK5FQm5P5cvaglItC9qkKioUXhCc67YMYBtivXl
 Ue0PgIq6kbHTqbX6+5Nw==
 ---- END SSH2 PUBLIC KEY ----</code></pre>

</li>
<li><p>EC private keys in JSON Web Key (JWK) format</p>

<p>See <a href="http://tools.ietf.org/html/draft-ietf-jose-json-web-key">http://tools.ietf.org/html/draft-ietf-jose-json-web-key</a></p>

<pre><code> {
  &quot;kty&quot;:&quot;EC&quot;,
  &quot;crv&quot;:&quot;P-256&quot;,
  &quot;x&quot;:&quot;MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4&quot;,
  &quot;y&quot;:&quot;4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM&quot;,
  &quot;d&quot;:&quot;870MB6gfuTJ4HtUnUvYMyJpr5eUZNP4Bk43bVdj3eAE&quot;,
 }</code></pre>

<p><b>BEWARE:</b> For JWK support you need to have <a href="../../../../lib/perl5/5.26.3/JSON/PP.html">JSON::PP</a>, <a>JSON::XS</a> or <a>Cpanel::JSON::XS</a> module.</p>

</li>
<li><p>EC public keys in JSON Web Key (JWK) format</p>

<pre><code> {
  &quot;kty&quot;:&quot;EC&quot;,
  &quot;crv&quot;:&quot;P-256&quot;,
  &quot;x&quot;:&quot;MKBCTNIcKUSDii11ySs3526iDZ8AiTo7Tu6KPAqv7D4&quot;,
  &quot;y&quot;:&quot;4Etl6SRW2YiLUrN5vfvVHuhp7x8PxltmWWlbbM4IFyM&quot;,
 }</code></pre>

<p><b>BEWARE:</b> For JWK support you need to have <a href="../../../../lib/perl5/5.26.3/JSON/PP.html">JSON::PP</a>, <a>JSON::XS</a> or <a>Cpanel::JSON::XS</a> module.</p>

</li>
</ul>

<h2 id="import_key_raw">import_key_raw</h2>

<p>Import raw public/private key - can load data exported by <a href="#export_key_raw">&quot;export_key_raw&quot;</a>.</p>

<pre><code> $pk-&gt;import_key_raw($key, $curve);
 # $key .... data exported by export_key_raw()
 # $curve .. curve name or hashref with curve parameters - same as by generate_key()</code></pre>

<h2 id="export_key_der">export_key_der</h2>

<pre><code> my $private_der = $pk-&gt;export_key_der(&#39;private&#39;);
 #or
 my $public_der = $pk-&gt;export_key_der(&#39;public&#39;);</code></pre>

<p>Since CryptX-0.36 <code>export_key_der</code> can also export keys in a format that does not explicitly contain curve parameters but only curve OID.</p>

<pre><code> my $private_der = $pk-&gt;export_key_der(&#39;private_short&#39;);
 #or
 my $public_der = $pk-&gt;export_key_der(&#39;public_short&#39;);</code></pre>

<p>Since CryptX-0.59 <code>export_key_der</code> can also export keys in &quot;compressed&quot; format that defines curve by OID + stores public point in compressed form.</p>

<pre><code> my $private_pem = $pk-&gt;export_key_der(&#39;private_compressed&#39;);
 #or
 my $public_pem = $pk-&gt;export_key_der(&#39;public_compressed&#39;);</code></pre>

<h2 id="export_key_pem">export_key_pem</h2>

<pre><code> my $private_pem = $pk-&gt;export_key_pem(&#39;private&#39;);
 #or
 my $public_pem = $pk-&gt;export_key_pem(&#39;public&#39;);</code></pre>

<p>Since CryptX-0.36 <code>export_key_pem</code> can also export keys in a format that does not explicitly contain curve parameters but only curve OID.</p>

<pre><code> my $private_pem = $pk-&gt;export_key_pem(&#39;private_short&#39;);
 #or
 my $public_pem = $pk-&gt;export_key_pem(&#39;public_short&#39;);</code></pre>

<p>Since CryptX-0.59 <code>export_key_pem</code> can also export keys in &quot;compressed&quot; format that defines curve by OID + stores public point in compressed form.</p>

<pre><code> my $private_pem = $pk-&gt;export_key_pem(&#39;private_compressed&#39;);
 #or
 my $public_pem = $pk-&gt;export_key_pem(&#39;public_compressed&#39;);</code></pre>

<p>Support for password protected PEM keys</p>

<pre><code> my $private_pem = $pk-&gt;export_key_pem(&#39;private&#39;, $password);
 #or
 my $private_pem = $pk-&gt;export_key_pem(&#39;private&#39;, $password, $cipher);

 # supported ciphers: &#39;DES-CBC&#39;
 #                    &#39;DES-EDE3-CBC&#39;
 #                    &#39;SEED-CBC&#39;
 #                    &#39;CAMELLIA-128-CBC&#39;
 #                    &#39;CAMELLIA-192-CBC&#39;
 #                    &#39;CAMELLIA-256-CBC&#39;
 #                    &#39;AES-128-CBC&#39;
 #                    &#39;AES-192-CBC&#39;
 #                    &#39;AES-256-CBC&#39; (DEFAULT)</code></pre>

<h2 id="export_key_jwk">export_key_jwk</h2>

<p><i>Since: CryptX-0.022</i></p>

<p>Exports public/private keys as a JSON Web Key (JWK).</p>

<pre><code> my $private_json_text = $pk-&gt;export_key_jwk(&#39;private&#39;);
 #or
 my $public_json_text = $pk-&gt;export_key_jwk(&#39;public&#39;);</code></pre>

<p>Also exports public/private keys as a perl HASH with JWK structure.</p>

<pre><code> my $jwk_hash = $pk-&gt;export_key_jwk(&#39;private&#39;, 1);
 #or
 my $jwk_hash = $pk-&gt;export_key_jwk(&#39;public&#39;, 1);</code></pre>

<p><b>BEWARE:</b> For JWK support you need to have <a href="../../../../lib/perl5/5.26.3/JSON/PP.html">JSON::PP</a>, <a>JSON::XS</a> or <a>Cpanel::JSON::XS</a> module.</p>

<h2 id="export_key_jwk_thumbprint">export_key_jwk_thumbprint</h2>

<p><i>Since: CryptX-0.031</i></p>

<p>Exports the key&#39;s JSON Web Key Thumbprint as a string.</p>

<p>If you don&#39;t know what this is, see RFC 7638 <a href="https://tools.ietf.org/html/rfc7638">https://tools.ietf.org/html/rfc7638</a>.</p>

<pre><code> my $thumbprint = $pk-&gt;export_key_jwk_thumbprint(&#39;SHA256&#39;);</code></pre>

<h2 id="export_key_raw">export_key_raw</h2>

<p>Export raw public/private key. Public key is exported in ASN X9.62 format (compressed or uncompressed), private key is exported as raw bytes (padded with leading zeros to have the same size as the ECC curve).</p>

<pre><code> my $pubkey_octets  = $pk-&gt;export_key_raw(&#39;public&#39;);
 #or
 my $pubckey_octets = $pk-&gt;export_key_raw(&#39;public_compressed&#39;);
 #or
 my $privkey_octets = $pk-&gt;export_key_raw(&#39;private&#39;);</code></pre>

<h2 id="encrypt">encrypt</h2>

<pre><code> my $pk = Crypt::PK::ECC-&gt;new($pub_key_filename);
 my $ct = $pk-&gt;encrypt($message);
 #or
 my $ct = $pk-&gt;encrypt($message, $hash_name);

 #NOTE: $hash_name can be &#39;SHA1&#39; (DEFAULT), &#39;SHA256&#39; or any other hash supported by Crypt::Digest</code></pre>

<h2 id="decrypt">decrypt</h2>

<pre><code> my $pk = Crypt::PK::ECC-&gt;new($priv_key_filename);
 my $pt = $pk-&gt;decrypt($ciphertext);</code></pre>

<h2 id="sign_message">sign_message</h2>

<pre><code> my $pk = Crypt::PK::ECC-&gt;new($priv_key_filename);
 my $signature = $priv-&gt;sign_message($message);
 #or
 my $signature = $priv-&gt;sign_message($message, $hash_name);

 #NOTE: $hash_name can be &#39;SHA1&#39; (DEFAULT), &#39;SHA256&#39; or any other hash supported by Crypt::Digest</code></pre>

<h2 id="sign_message_rfc7518">sign_message_rfc7518</h2>

<p><i>Since: CryptX-0.024</i></p>

<p>Same as <a href="#sign_message">sign_message</a> only the signature format is as defined by <a href="https://tools.ietf.org/html/rfc7518">https://tools.ietf.org/html/rfc7518</a> (JWA - JSON Web Algorithms).</p>

<p><b>BEWARE:</b> This creates signatures according to the structure that RFC 7518 describes but does not apply the RFC logic for the hashing algorithm selection. You&#39;ll still need to specify, e.g., SHA256 for a P-256 key to get a fully RFC-7518-compliant signature.</p>

<h2 id="verify_message">verify_message</h2>

<pre><code> my $pk = Crypt::PK::ECC-&gt;new($pub_key_filename);
 my $valid = $pub-&gt;verify_message($signature, $message)
 #or
 my $valid = $pub-&gt;verify_message($signature, $message, $hash_name);

 #NOTE: $hash_name can be &#39;SHA1&#39; (DEFAULT), &#39;SHA256&#39; or any other hash supported by Crypt::Digest</code></pre>

<h2 id="verify_message_rfc7518">verify_message_rfc7518</h2>

<p><i>Since: CryptX-0.024</i></p>

<p>Same as <a href="#verify_message">verify_message</a> only the signature format is as defined by <a href="https://tools.ietf.org/html/rfc7518">https://tools.ietf.org/html/rfc7518</a> (JWA - JSON Web Algorithms).</p>

<p><b>BEWARE:</b> This verifies signatures according to the structure that RFC 7518 describes but does not apply the RFC logic for the hashing algorithm selection. You&#39;ll still need to specify, e.g., SHA256 for a P-256 key to get a fully RFC-7518-compliant signature.</p>

<h2 id="sign_hash">sign_hash</h2>

<pre><code> my $pk = Crypt::PK::ECC-&gt;new($priv_key_filename);
 my $signature = $priv-&gt;sign_hash($message_hash);</code></pre>

<h2 id="sign_hash_rfc7518">sign_hash_rfc7518</h2>

<p><i>Since: CryptX-0.059</i></p>

<p>Same as <a href="#sign_hash">sign_hash</a> only the signature format is as defined by <a href="https://tools.ietf.org/html/rfc7518">https://tools.ietf.org/html/rfc7518</a> (JWA - JSON Web Algorithms).</p>

<h2 id="verify_hash">verify_hash</h2>

<pre><code> my $pk = Crypt::PK::ECC-&gt;new($pub_key_filename);
 my $valid = $pub-&gt;verify_hash($signature, $message_hash);</code></pre>

<h2 id="verify_hash_rfc7518">verify_hash_rfc7518</h2>

<p><i>Since: CryptX-0.059</i></p>

<p>Same as <a href="#verify_hash">verify_hash</a> only the signature format is as defined by <a href="https://tools.ietf.org/html/rfc7518">https://tools.ietf.org/html/rfc7518</a> (JWA - JSON Web Algorithms).</p>

<h2 id="shared_secret">shared_secret</h2>

<pre><code>  # Alice having her priv key $pk and Bob&#39;s public key $pkb
  my $pk  = Crypt::PK::ECC-&gt;new($priv_key_filename);
  my $pkb = Crypt::PK::ECC-&gt;new($pub_key_filename);
  my $shared_secret = $pk-&gt;shared_secret($pkb);

  # Bob having his priv key $pk and Alice&#39;s public key $pka
  my $pk = Crypt::PK::ECC-&gt;new($priv_key_filename);
  my $pka = Crypt::PK::ECC-&gt;new($pub_key_filename);
  my $shared_secret = $pk-&gt;shared_secret($pka);  # same value as computed by Alice</code></pre>

<h2 id="is_private">is_private</h2>

<pre><code> my $rv = $pk-&gt;is_private;
 # 1 .. private key loaded
 # 0 .. public key loaded
 # undef .. no key loaded</code></pre>

<h2 id="size">size</h2>

<pre><code> my $size = $pk-&gt;size;
 # returns key size in bytes or undef if no key loaded</code></pre>

<h2 id="key2hash">key2hash</h2>

<pre><code> my $hash = $pk-&gt;key2hash;

 # returns hash like this (or undef if no key loaded):
 {
   size           =&gt; 20, # integer: key (curve) size in bytes
   type           =&gt; 1,  # integer: 1 .. private, 0 .. public
   #curve parameters
   curve_A        =&gt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC&quot;,
   curve_B        =&gt; &quot;1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45&quot;,
   curve_bits     =&gt; 160,
   curve_bytes    =&gt; 20,
   curve_cofactor =&gt; 1,
   curve_Gx       =&gt; &quot;4A96B5688EF573284664698968C38BB913CBFC82&quot;,
   curve_Gy       =&gt; &quot;23A628553168947D59DCC912042351377AC5FB32&quot;,
   curve_name     =&gt; &quot;secp160r1&quot;,
   curve_order    =&gt; &quot;0100000000000000000001F4C8F927AED3CA752257&quot;,
   curve_prime    =&gt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF&quot;,
   #private key
   k              =&gt; &quot;B0EE84A749FE95DF997E33B8F333E12101E824C3&quot;,
   #public key point coordinates
   pub_x          =&gt; &quot;5AE1ACE3ED0AEA9707CE5C0BCE014F6A2F15023A&quot;,
   pub_y          =&gt; &quot;895D57E992D0A15F88D6680B27B701F615FCDC0F&quot;,
 }</code></pre>

<h2 id="curve2hash">curve2hash</h2>

<p><i>Since: CryptX-0.024</i></p>

<pre><code> my $crv = $pk-&gt;curve2hash;

 # returns a hash that can be passed to: $pk-&gt;generate_key($crv)
 {
   A        =&gt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC&quot;,
   B        =&gt; &quot;1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45&quot;,
   cofactor =&gt; 1,
   Gx       =&gt; &quot;4A96B5688EF573284664698968C38BB913CBFC82&quot;,
   Gy       =&gt; &quot;23A628553168947D59DCC912042351377AC5FB32&quot;,
   order    =&gt; &quot;0100000000000000000001F4C8F927AED3CA752257&quot;,
   prime    =&gt; &quot;FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF&quot;,
 }</code></pre>

<h1 id="FUNCTIONS">FUNCTIONS</h1>

<h2 id="ecc_encrypt">ecc_encrypt</h2>

<p>Elliptic Curve Diffie-Hellman (ECDH) encryption as implemented by libtomcrypt. See method <a href="#encrypt">&quot;encrypt&quot;</a> below.</p>

<pre><code> my $ct = ecc_encrypt($pub_key_filename, $message);
 #or
 my $ct = ecc_encrypt(\$buffer_containing_pub_key, $message);
 #or
 my $ct = ecc_encrypt($pub_key_filename, $message, $hash_name);

 #NOTE: $hash_name can be &#39;SHA1&#39; (DEFAULT), &#39;SHA256&#39; or any other hash supported by Crypt::Digest</code></pre>

<p>ECCDH Encryption is performed by producing a random key, hashing it, and XOR&#39;ing the digest against the plaintext.</p>

<h2 id="ecc_decrypt">ecc_decrypt</h2>

<p>Elliptic Curve Diffie-Hellman (ECDH) decryption as implemented by libtomcrypt. See method <a href="#decrypt">&quot;decrypt&quot;</a> below.</p>

<pre><code> my $pt = ecc_decrypt($priv_key_filename, $ciphertext);
 #or
 my $pt = ecc_decrypt(\$buffer_containing_priv_key, $ciphertext);</code></pre>

<h2 id="ecc_sign_message">ecc_sign_message</h2>

<p>Elliptic Curve Digital Signature Algorithm (ECDSA) - signature generation. See method <a href="#sign_message">&quot;sign_message&quot;</a> below.</p>

<pre><code> my $sig = ecc_sign_message($priv_key_filename, $message);
 #or
 my $sig = ecc_sign_message(\$buffer_containing_priv_key, $message);
 #or
 my $sig = ecc_sign_message($priv_key, $message, $hash_name);</code></pre>

<h2 id="ecc_verify_message">ecc_verify_message</h2>

<p>Elliptic Curve Digital Signature Algorithm (ECDSA) - signature verification. See method <a href="#verify_message">&quot;verify_message&quot;</a> below.</p>

<pre><code> ecc_verify_message($pub_key_filename, $signature, $message) or die &quot;ERROR&quot;;
 #or
 ecc_verify_message(\$buffer_containing_pub_key, $signature, $message) or die &quot;ERROR&quot;;
 #or
 ecc_verify_message($pub_key, $signature, $message, $hash_name) or die &quot;ERROR&quot;;</code></pre>

<h2 id="ecc_sign_hash">ecc_sign_hash</h2>

<p>Elliptic Curve Digital Signature Algorithm (ECDSA) - signature generation. See method <a href="#sign_hash">&quot;sign_hash&quot;</a> below.</p>

<pre><code> my $sig = ecc_sign_hash($priv_key_filename, $message_hash);
 #or
 my $sig = ecc_sign_hash(\$buffer_containing_priv_key, $message_hash);</code></pre>

<h2 id="ecc_verify_hash">ecc_verify_hash</h2>

<p>Elliptic Curve Digital Signature Algorithm (ECDSA) - signature verification. See method <a href="#verify_hash">&quot;verify_hash&quot;</a> below.</p>

<pre><code> ecc_verify_hash($pub_key_filename, $signature, $message_hash) or die &quot;ERROR&quot;;
 #or
 ecc_verify_hash(\$buffer_containing_pub_key, $signature, $message_hash) or die &quot;ERROR&quot;;</code></pre>

<h2 id="ecc_shared_secret">ecc_shared_secret</h2>

<p>Elliptic curve Diffie-Hellman (ECDH) - construct a Diffie-Hellman shared secret with a private and public ECC key. See method <a href="#shared_secret">&quot;shared_secret&quot;</a> below.</p>

<pre><code> #on Alice side
 my $shared_secret = ecc_shared_secret(&#39;Alice_priv_ecc1.der&#39;, &#39;Bob_pub_ecc1.der&#39;);

 #on Bob side
 my $shared_secret = ecc_shared_secret(&#39;Bob_priv_ecc1.der&#39;, &#39;Alice_pub_ecc1.der&#39;);</code></pre>

<h1 id="OpenSSL-interoperability">OpenSSL interoperability</h1>

<pre><code> ### let&#39;s have:
 # ECC private key in PEM format - eckey.priv.pem
 # ECC public key in PEM format  - eckey.pub.pem
 # data file to be signed - input.data</code></pre>

<h2 id="Sign-by-OpenSSL-verify-by-Crypt::PK::ECC">Sign by OpenSSL, verify by Crypt::PK::ECC</h2>

<p>Create signature (from commandline):</p>

<pre><code> openssl dgst -sha1 -sign eckey.priv.pem -out input.sha1-ec.sig input.data</code></pre>

<p>Verify signature (Perl code):</p>

<pre><code> use Crypt::PK::ECC;
 use Crypt::Digest &#39;digest_file&#39;;
 use Crypt::Misc &#39;read_rawfile&#39;;

 my $pkec = Crypt::PK::ECC-&gt;new(&quot;eckey.pub.pem&quot;);
 my $signature = read_rawfile(&quot;input.sha1-ec.sig&quot;);
 my $valid = $pkec-&gt;verify_hash($signature, digest_file(&quot;SHA1&quot;, &quot;input.data&quot;), &quot;SHA1&quot;, &quot;v1.5&quot;);
 print $valid ? &quot;SUCCESS&quot; : &quot;FAILURE&quot;;</code></pre>

<h2 id="Sign-by-Crypt::PK::ECC-verify-by-OpenSSL">Sign by Crypt::PK::ECC, verify by OpenSSL</h2>

<p>Create signature (Perl code):</p>

<pre><code> use Crypt::PK::ECC;
 use Crypt::Digest &#39;digest_file&#39;;
 use Crypt::Misc &#39;write_rawfile&#39;;

 my $pkec = Crypt::PK::ECC-&gt;new(&quot;eckey.priv.pem&quot;);
 my $signature = $pkec-&gt;sign_hash(digest_file(&quot;SHA1&quot;, &quot;input.data&quot;), &quot;SHA1&quot;, &quot;v1.5&quot;);
 write_rawfile(&quot;input.sha1-ec.sig&quot;, $signature);</code></pre>

<p>Verify signature (from commandline):</p>

<pre><code> openssl dgst -sha1 -verify eckey.pub.pem -signature input.sha1-ec.sig input.data</code></pre>

<h2 id="Keys-generated-by-Crypt::PK::ECC">Keys generated by Crypt::PK::ECC</h2>

<p>Generate keys (Perl code):</p>

<pre><code> use Crypt::PK::ECC;
 use Crypt::Misc &#39;write_rawfile&#39;;

 my $pkec = Crypt::PK::ECC-&gt;new;
 $pkec-&gt;generate_key(&#39;secp160k1&#39;);
 write_rawfile(&quot;eckey.pub.der&quot;,  $pkec-&gt;export_key_der(&#39;public&#39;));
 write_rawfile(&quot;eckey.priv.der&quot;, $pkec-&gt;export_key_der(&#39;private&#39;));
 write_rawfile(&quot;eckey.pub.pem&quot;,  $pkec-&gt;export_key_pem(&#39;public&#39;));
 write_rawfile(&quot;eckey.priv.pem&quot;, $pkec-&gt;export_key_pem(&#39;private&#39;));
 write_rawfile(&quot;eckey-passwd.priv.pem&quot;, $pkec-&gt;export_key_pem(&#39;private&#39;, &#39;secret&#39;));</code></pre>

<p>Use keys by OpenSSL:</p>

<pre><code> openssl ec -in eckey.priv.der -text -inform der
 openssl ec -in eckey.priv.pem -text
 openssl ec -in eckey-passwd.priv.pem -text -inform pem -passin pass:secret
 openssl ec -in eckey.pub.der -pubin -text -inform der
 openssl ec -in eckey.pub.pem -pubin -text</code></pre>

<h2 id="Keys-generated-by-OpenSSL">Keys generated by OpenSSL</h2>

<p>Generate keys:</p>

<pre><code> openssl ecparam -param_enc explicit -name prime192v3 -genkey -out eckey.priv.pem
 openssl ec -param_enc explicit -in eckey.priv.pem -out eckey.pub.pem -pubout
 openssl ec -param_enc explicit -in eckey.priv.pem -out eckey.priv.der -outform der
 openssl ec -param_enc explicit -in eckey.priv.pem -out eckey.pub.der -outform der -pubout
 openssl ec -param_enc explicit -in eckey.priv.pem -out eckey.privc.der -outform der -conv_form compressed
 openssl ec -param_enc explicit -in eckey.priv.pem -out eckey.pubc.der -outform der -pubout -conv_form compressed
 openssl ec -param_enc explicit -in eckey.priv.pem -passout pass:secret -des3 -out eckey-passwd.priv.pem</code></pre>

<p>Load keys (Perl code):</p>

<pre><code> use Crypt::PK::ECC;

 my $pkec = Crypt::PK::ECC-&gt;new;
 $pkec-&gt;import_key(&quot;eckey.pub.der&quot;);
 $pkec-&gt;import_key(&quot;eckey.pubc.der&quot;);
 $pkec-&gt;import_key(&quot;eckey.priv.der&quot;);
 $pkec-&gt;import_key(&quot;eckey.privc.der&quot;);
 $pkec-&gt;import_key(&quot;eckey.pub.pem&quot;);
 $pkec-&gt;import_key(&quot;eckey.priv.pem&quot;);
 $pkec-&gt;import_key(&quot;eckey-passwd.priv.pem&quot;, &quot;secret&quot;);</code></pre>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<ul>

<li><p><a href="https://en.wikipedia.org/wiki/Elliptic_curve_cryptography">https://en.wikipedia.org/wiki/Elliptic_curve_cryptography</a></p>

</li>
<li><p><a href="https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman">https://en.wikipedia.org/wiki/Elliptic_curve_Diffie%E2%80%93Hellman</a></p>

</li>
<li><p><a href="https://en.wikipedia.org/wiki/ECDSA">https://en.wikipedia.org/wiki/ECDSA</a></p>

</li>
</ul>


</body>

</html>


