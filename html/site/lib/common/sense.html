<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../displayToc.js"></script>
<script language="JavaScript" src="../../../tocParas.js"></script>
<script language="JavaScript" src="../../../tocTab.js"></script>
<title></title>
<link rel="stylesheet" href="../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#RATIONALE">RATIONALE</a></li>
  <li><a href="#THERE-IS-NO-no-common::sense">THERE IS NO &#39;no common::sense&#39;!!!! !!!! !!</a></li>
  <li><a href="#STABILITY-AND-FUTURE-VERSIONS">STABILITY AND FUTURE VERSIONS</a></li>
  <li><a href="#WHAT-OTHER-PEOPLE-HAD-TO-SAY-ABOUT-THIS-MODULE">WHAT OTHER PEOPLE HAD TO SAY ABOUT THIS MODULE</a></li>
  <li><a href="#FREQUENTLY-ASKED-QUESTIONS">FREQUENTLY ASKED QUESTIONS</a></li>
  <li><a href="#AUTHOR">AUTHOR</a></li>
  <li><a href="#POD-ERRORS">POD ERRORS</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>common::sense - save a tree AND a kitten, use common::sense!</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>   use common::sense;

   # Supposed to be mostly the same, with much lower memory usage, as:
  
   # use utf8;
   # use strict qw(vars subs);
   # use feature qw(say state switch);
   # use feature qw(unicode_strings unicode_eval current_sub fc evalbytes);
   # no feature qw(array_base);
   # no warnings;
   # use warnings qw(FATAL closed threads internal debugging pack
   #                 prototype inplace io pipe unpack malloc glob
   #                 digit printf layer reserved taint closure semicolon);
   # no warnings qw(exec newline unopened);</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<pre><code>   &ldquo;Nothing is more fairly distributed than common sense: no one thinks
   he needs more of it than he already has.&rdquo;

   &ndash; Ren&eacute; Descartes</code></pre>

<p>This module implements some sane defaults for Perl programs, as defined by two typical (or not so typical - use your common sense) specimens of Perl coders. In fact, after working out details on which warnings and strict modes to enable and make fatal, we found that we (and our code written so far, and others) fully agree on every option, even though we never used warnings before, so it seems this module indeed reflects a &quot;common&quot; sense among some long-time Perl coders.</p>

<p>The basic philosophy behind the choices made in common::sense can be summarised as: &quot;enforcing strict policies to catch as many bugs as possible, while at the same time, not limiting the expressive power available to the programmer&quot;.</p>

<p>Two typical examples of how this philosophy is applied in practise is the handling of uninitialised and malloc warnings:</p>

<dl>

<dt id="uninitialised"><i>uninitialised</i></dt>
<dd>

<p><code>undef</code> is a well-defined feature of perl, and enabling warnings for using it rarely catches any bugs, but considerably limits you in what you can do, so uninitialised warnings are disabled.</p>

</dd>
<dt id="malloc"><i>malloc</i></dt>
<dd>

<p>Freeing something twice on the C level is a serious bug, usually causing memory corruption. It often leads to side effects much later in the program and there are no advantages to not reporting this, so malloc warnings are fatal by default.</p>

</dd>
</dl>

<p>Unfortunately, there is no fine-grained warning control in perl, so often whole groups of useful warnings had to be excluded because of a single useless warning (for example, perl puts an arbitrary limit on the length of text you can match with some regexes before emitting a warning, making the whole <code>regexp</code> category useless).</p>

<p>What follows is a more thorough discussion of what this module does, and why it does it, and what the advantages (and disadvantages) of this approach are.</p>

<h1 id="RATIONALE">RATIONALE</h1>

<dl>

<dt id="use-utf8">use utf8</dt>
<dd>

<p>While it&#39;s not common sense to write your programs in UTF-8, it&#39;s quickly becoming the most common encoding, is the designated future default encoding for perl sources, and the most convenient encoding available (you can do really nice quoting tricks...). Experience has shown that our programs were either all pure ascii or utf-8, both of which will stay the same.</p>

<p>There are few drawbacks to enabling UTF-8 source code by default (mainly some speed hits due to bugs in older versions of perl), so this module enables UTF-8 source code encoding by default.</p>

</dd>
<dt id="use-strict-qw-subs-vars">use strict qw(subs vars)</dt>
<dd>

<p>Using <code>use strict</code> is definitely common sense, but <code>use strict &#39;refs&#39;</code> definitely overshoots its usefulness. After almost two decades of Perl hacking, we decided that it does more harm than being useful. Specifically, constructs like these:</p>

<pre><code>   @{ $var-&gt;[0] }</code></pre>

<p>Must be written like this (or similarly), when <code>use strict &#39;refs&#39;</code> is in scope, and <code>$var</code> can legally be <code>undef</code>:</p>

<pre><code>   @{ $var-&gt;[0] || [] }</code></pre>

<p>This is annoying, and doesn&#39;t shield against obvious mistakes such as using <code>&quot;&quot;</code>, so one would even have to write (at least for the time being):</p>

<pre><code>   @{ defined $var-&gt;[0] ? $var-&gt;[0] : [] }</code></pre>

<p>... which nobody with a bit of common sense would consider writing: clear code is clearly something else.</p>

<p>Curiously enough, sometimes perl is not so strict, as this works even with <code>use strict</code> in scope:</p>

<pre><code>   for (@{ $var-&gt;[0] }) { ...</code></pre>

<p>If that isn&#39;t hypocrisy! And all that from a mere program!</p>

</dd>
<dt id="use-feature-qw-say-state-given">use feature qw(say state given ...)</dt>
<dd>

<p>We found it annoying that we always have to enable extra features. If something breaks because it didn&#39;t anticipate future changes, so be it. 5.10 broke almost all our XS modules and nobody cared either (or at least I know of nobody who really complained about gratuitous changes - as opposed to bugs).</p>

<p>Few modules that are not actively maintained work with newer versions of Perl, regardless of use feature or not, so a new major perl release means changes to many modules - new keywords are just the tip of the iceberg.</p>

<p>If your code isn&#39;t alive, it&#39;s dead, Jim - be an active maintainer.</p>

<p>But nobody forces you to use those extra features in modules meant for older versions of perl - common::sense of course works there as well. There is also an important other mode where having additional features by default is useful: commandline hacks and internal use scripts: See &quot;much reduced typing&quot;, below.</p>

<p>There is one notable exception: <code>unicode_eval</code> is not enabled by default. In our opinion, <code>use feature</code> had one main effect - newer perl versions don&#39;t value backwards compatibility and the ability to write modules for multiple perl versions much, after all, you can use feature.</p>

<p><code>unicode_eval</code> doesn&#39;t add a new feature, it breaks an existing function.</p>

</dd>
<dt id="no-warnings-but-a-lot-of-new-errors">no warnings, but a lot of new errors</dt>
<dd>

<p>Ah, the dreaded warnings. Even worse, the horribly dreaded <code>-w</code> switch: Even though we don&#39;t care if other people use warnings (and certainly there are useful ones), a lot of warnings simply go against the spirit of Perl.</p>

<p>Most prominently, the warnings related to <code>undef</code>. There is nothing wrong with <code>undef</code>: it has well-defined semantics, it is useful, and spitting out warnings you never asked for is just evil.</p>

<p>The result was that every one of our modules did <code>no warnings</code> in the past, to avoid somebody accidentally using and forcing his bad standards on our code. Of course, this switched off all warnings, even the useful ones. Not a good situation. Really, the <code>-w</code> switch should only enable warnings for the main program only.</p>

<p>Funnily enough, <a href="../../../lib/perl5/5.26.3/pod/perllexwarn.html">perllexwarn</a> explicitly mentions <code>-w</code> (and not in a favourable way, calling it outright &quot;wrong&quot;), but standard utilities, such as <a href="../../../bin/prove.html">prove</a>, or MakeMaker when running <code>make test</code>, still enable them blindly.</p>

<p>For version 2 of common::sense, we finally sat down a few hours and went through <i>every single warning message</i>, identifying - according to common sense - all the useful ones.</p>

<p>This resulted in the rather impressive list in the SYNOPSIS. When we weren&#39;t sure, we didn&#39;t include the warning, so the list might grow in the future (we might have made a mistake, too, so the list might shrink as well).</p>

<p>Note the presence of <code>FATAL</code> in the list: we do not think that the conditions caught by these warnings are worthy of a warning, we <i>insist</i> that they are worthy of <i>stopping</i> your program, <i>instantly</i>. They are <i>bugs</i>!</p>

<p>Therefore we consider <code>common::sense</code> to be much stricter than <code>use warnings</code>, which is good if you are into strict things (we are not, actually, but these things tend to be subjective).</p>

<p>After deciding on the list, we ran the module against all of our code that uses <code>common::sense</code> (that is almost all of our code), and found only one occurrence where one of them caused a problem: one of elmex&#39;s (unreleased) modules contained:</p>

<pre><code>   $fmt =~ s/([^\s\[]*)\[( [^\]]* )\]/\x0$1\x1$2\x0/xgo;</code></pre>

<p>We quickly agreed that indeed the code should be changed, even though it happened to do the right thing when the warning was switched off.</p>

</dd>
<dt id="much-reduced-typing">much reduced typing</dt>
<dd>

<p>Especially with version 2.0 of common::sense, the amount of boilerplate code you need to add to get <i>this</i> policy is daunting. Nobody would write this out in throwaway scripts, commandline hacks or in quick internal-use scripts.</p>

<p>By using common::sense you get a defined set of policies (ours, but maybe yours, too, if you accept them), and they are easy to apply to your scripts: typing <code>use common::sense;</code> is even shorter than <code>use warnings; use strict; use feature ...</code>.</p>

<p>And you can immediately use the features of your installed perl, which is more difficult in code you release, but not usually an issue for internal-use code (downgrades of your production perl should be rare, right?).</p>

</dd>
<dt id="mucho-reduced-memory-usage">mucho reduced memory usage</dt>
<dd>

<p>Just using all those pragmas mentioned in the SYNOPSIS together wastes &lt;blink&gt;<i><b>776</b> kilobytes</i>&lt;/blink&gt; of precious memory in my perl, for <i>every single perl process using our code</i>, which on our machines, is a lot. In comparison, this module only uses <i><b>four</b></i> kilobytes (I even had to write it out so it looks like more) of memory on the same platform.</p>

<p>The money/time/effort/electricity invested in these gigabytes (probably petabytes globally!) of wasted memory could easily save 42 trees, and a kitten!</p>

<p>Unfortunately, until everybody applies more common sense, there will still often be modules that pull in the monster pragmas. But one can hope...</p>

</dd>
</dl>

<h1 id="THERE-IS-NO-no-common::sense">THERE IS NO &#39;no common::sense&#39;!!!! !!!! !!</h1>

<p>This module doesn&#39;t offer an unimport. First of all, it wastes even more memory, second, and more importantly, who with even a bit of common sense would want no common sense?</p>

<h1 id="STABILITY-AND-FUTURE-VERSIONS">STABILITY AND FUTURE VERSIONS</h1>

<p>Future versions might change just about everything in this module. We might test our modules and upload new ones working with newer versions of this module, and leave you standing in the rain because we didn&#39;t tell you. In fact, we did so when switching from 1.0 to 2.0, which enabled gobs of warnings, and made them FATAL on top.</p>

<p>Maybe we will load some nifty modules that try to emulate <code>say</code> or so with perls older than 5.10 (this module, of course, should work with older perl versions - supporting 5.8 for example is just common sense at this time. Maybe not in the future, but of course you can trust our common sense to be consistent with, uhm, our opinion).</p>

<h1 id="WHAT-OTHER-PEOPLE-HAD-TO-SAY-ABOUT-THIS-MODULE">WHAT OTHER PEOPLE HAD TO SAY ABOUT THIS MODULE</h1>

<p>apeiron</p>

<pre><code>   &quot;... wow&quot;
   &quot;I hope common::sense is a joke.&quot;</code></pre>

<p>crab</p>

<pre><code>   &quot;i wonder how it would be if joerg schilling wrote perl modules.&quot;</code></pre>

<p>Adam Kennedy</p>

<pre><code>   &quot;Very interesting, efficient, and potentially something I&#39;d use all the time.&quot;
   [...]
   &quot;So no common::sense for me, alas.&quot;</code></pre>

<p>H.Merijn Brand</p>

<pre><code>   &quot;Just one more reason to drop JSON::XS from my distribution list&quot;</code></pre>

<p>Pista Palo</p>

<pre><code>   &quot;Something in short supply these days...&quot;</code></pre>

<p>Steffen Schwigon</p>

<pre><code>   &quot;This module is quite for sure *not* just a repetition of all the other
   &#39;use strict, use warnings&#39;-approaches, and it&#39;s also not the opposite.
   [...] And for its chosen middle-way it&#39;s also not the worst name ever.
   And everything is documented.&quot;</code></pre>

<p>BKB</p>

<pre><code>   &quot;[Deleted - thanks to Steffen Schwigon for pointing out this review was
   in error.]&quot;</code></pre>

<p>Somni</p>

<pre><code>   &quot;the arrogance of the guy&quot;
   &quot;I swear he tacked somenoe else&#39;s name onto the module
   just so he could use the royal &#39;we&#39; in the documentation&quot;</code></pre>

<p>Anonymous Monk</p>

<pre><code>   &quot;You just gotta love this thing, its got META.json!!!&quot;</code></pre>

<p>dngor</p>

<pre><code>   &quot;Heh.  &#39;&quot;&lt;elmex at ta-sa.org&gt;&quot;&#39;  The quotes are semantic
   distancing from that e-mail address.&quot;</code></pre>

<p>Jerad Pierce</p>

<pre><code>   &quot;Awful name (not a proper pragma), and the SYNOPSIS doesn&#39;t tell you
   anything either. Nor is it clear what features have to do with &quot;common
   sense&quot; or discipline.&quot;</code></pre>

<p>acme</p>

<pre><code>   &quot;THERE IS NO &#39;no common::sense&#39;!!!! !!!! !!&quot;</code></pre>

<p>apeiron (meta-comment about us commenting^Wquoting his comment)</p>

<pre><code>   &quot;How about quoting this: get a clue, you fucktarded amoeba.&quot;</code></pre>

<p>quanth</p>

<pre><code>   &quot;common sense is beautiful, json::xs is fast, Anyevent, EV are fast and
   furious. I love mlehmannware ;)&quot;</code></pre>

<p>apeiron</p>

<pre><code>   &quot;... it&#39;s mlehmann&#39;s view of what common sense is. His view of common
   sense is certainly uncommon, insofar as anyone with a clue disagrees
   with him.&quot;</code></pre>

<p>apeiron (another meta-comment)</p>

<pre><code>   &quot;apeiron wonders if his little informant is here to steal more quotes&quot;</code></pre>

<p>ew73</p>

<pre><code>   &quot;... I never got past the SYNOPSIS before calling it shit.&quot;
   [...]
   How come no one ever quotes me. :(&quot;</code></pre>

<p>chip (not willing to explain his cryptic questions about links in Changes files)</p>

<pre><code>   &quot;I&#39;m willing to ask the question I&#39;ve asked. I&#39;m not willing to go
   through the whole dance you apparently have choreographed. Either
   answer the completely obvious question, or tell me to fuck off again.&quot;</code></pre>

<h1 id="FREQUENTLY-ASKED-QUESTIONS">FREQUENTLY ASKED QUESTIONS</h1>

<p>Or frequently-come-up confusions.</p>

<dl>

<dt id="Is-this-module-meant-to-be-serious">Is this module meant to be serious?</dt>
<dd>

<p>Yes, we would have put it under the <code>Acme::</code> namespace otherwise.</p>

</dd>
<dt id="But-the-manpage-is-written-in-a-funny-stupid-...-way">But the manpage is written in a funny/stupid/... way?</dt>
<dd>

<p>This was meant to make it clear that our common sense is a subjective thing and other people can use their own notions, taking the steam out of anybody who might be offended (as some people are always offended no matter what you do).</p>

<p>This was a failure.</p>

<p>But we hope the manpage still is somewhat entertaining even though it explains boring rationale.</p>

</dd>
<dt id="Why-do-you-impose-your-conventions-on-my-code">Why do you impose your conventions on my code?</dt>
<dd>

<p>For some reason people keep thinking that <code>common::sense</code> imposes process-wide limits, even though the SYNOPSIS makes it clear that it works like other similar modules - i.e. only within the scope that <code>use</code>s them.</p>

<p>So, no, we don&#39;t - nobody is forced to use this module, and using a module that relies on common::sense does not impose anything on you.</p>

</dd>
<dt id="Why-do-you-think-only-your-notion-of-common::sense-is-valid">Why do you think only your notion of common::sense is valid?</dt>
<dd>

<p>Well, we don&#39;t, and have clearly written this in the documentation to every single release. We were just faster than anybody else w.r.t. to grabbing the namespace.</p>

</dd>
<dt id="But-everybody-knows-that-you-have-to-use-strict-and-use-warnings-why-do-you-disable-them">But everybody knows that you have to use strict and use warnings, why do you disable them?</dt>
<dd>

<p>Well, we don&#39;t do this either - we selectively disagree with the usefulness of some warnings over others. This module is aimed at experienced Perl programmers, not people migrating from other languages who might be surprised about stuff such as <code>undef</code>. On the other hand, this does not exclude the usefulness of this module for total newbies, due to its strictness in enforcing policy, while at the same time not limiting the expressive power of perl.</p>

<p>This module is considerably <i>more</i> strict than the canonical <code>use strict; use warnings</code>, as it makes all its warnings fatal in nature, so you can not get away with as many things as with the canonical approach.</p>

<p>This was not implemented in version 1.0 because of the daunting number of warning categories and the difficulty in getting exactly the set of warnings you wish (i.e. look at the SYNOPSIS in how complicated it is to get a specific set of warnings - it is not reasonable to put this into every module, the maintenance effort would be enormous).</p>

</dd>
<dt id="But-many-modules-use-strict-or-use-warnings-so-the-memory-savings-do-not-apply">But many modules <code>use strict</code> or <code>use warnings</code>, so the memory savings do not apply?</dt>
<dd>

<p>I suddenly feel sad...</p>

<p>But yes, that&#39;s true. Fortunately <code>common::sense</code> still uses only a miniscule amount of RAM.</p>

</dd>
<dt id="But-it-adds-another-dependency-to-your-modules">But it adds another dependency to your modules!</dt>
<dd>

<p>It&#39;s a fact, yeah. But it&#39;s trivial to install, most popular modules have many more dependencies. And we consider dependencies a good thing - it leads to better APIs, more thought about interworking of modules and so on.</p>

</dd>
<dt id="Why-do-you-use-JSON-and-not-YAML-for-your-META.yml">Why do you use JSON and not YAML for your META.yml?</dt>
<dd>

<p>This is not true - YAML supports a large subset of JSON, and this subset is what META.yml is written in, so it would be correct to say &quot;the META.yml is written in a common subset of YAML and JSON&quot;.</p>

<p>The META.yml follows the YAML, JSON and META.yml specifications, and is correctly parsed by CPAN, so if you have trouble with it, the problem is likely on your side.</p>

</dd>
<dt id="But-But">But! But!</dt>
<dd>

<p>Yeah, we know.</p>

</dd>
</dl>

<h1 id="AUTHOR">AUTHOR</h1>

<pre><code> Marc Lehmann &lt;schmorp@schmorp.de&gt;
 http://home.schmorp.de/

 Robin Redeker, &quot;&lt;elmex at ta-sa.org&gt;&quot;.</code></pre>

<h1 id="POD-ERRORS">POD ERRORS</h1>

<p>Hey! <b>The above document had some coding errors, which are explained below:</b></p>

<dl>

<dt id="Around-line-24">Around line 24:</dt>
<dd>

<p>Non-ASCII character seen before =encoding in &#39;&ldquo;Nothing&#39;. Assuming UTF-8</p>

</dd>
</dl>


</body>

</html>


