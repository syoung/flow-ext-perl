<?xml version="1.0" ?>
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<!-- saved from url=(0017)http://localhost/ -->
<script language="JavaScript" src="../../../../displayToc.js"></script>
<script language="JavaScript" src="../../../../tocParas.js"></script>
<script language="JavaScript" src="../../../../tocTab.js"></script>
<title></title>
<link rel="stylesheet" href="../../../../Active.css" type="text/css" />
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rev="made" href="mailto:support@ActiveState.com" />
</head>

<body>



<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#VERSION">VERSION</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#CLASSES-AND-ATTRIBUTES">CLASSES AND ATTRIBUTES</a></li>
  <li><a href="#AUTHORS">AUTHORS</a></li>
  <li><a href="#COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>Moose::Manual::Unsweetened - Moose idioms in plain old Perl 5 without the sugar</p>

<h1 id="VERSION">VERSION</h1>

<p>version 2.2012</p>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>If you&#39;re trying to figure out just what the heck Moose does, and how it saves you time, you might find it helpful to see what Moose is <i>really</i> doing for you. This document shows you the translation from Moose sugar back to plain old Perl 5.</p>

<h1 id="CLASSES-AND-ATTRIBUTES">CLASSES AND ATTRIBUTES</h1>

<p>First, we define two very small classes the Moose way.</p>

<pre><code>  package Person;

  use DateTime;
  use DateTime::Format::Natural;
  use Moose;
  use Moose::Util::TypeConstraints;

  has name =&gt; (
      is       =&gt; &#39;rw&#39;,
      isa      =&gt; &#39;Str&#39;,
      required =&gt; 1,
  );

  # Moose doesn&#39;t know about non-Moose-based classes.
  class_type &#39;DateTime&#39;;

  my $en_parser = DateTime::Format::Natural-&gt;new(
      lang      =&gt; &#39;en&#39;,
      time_zone =&gt; &#39;UTC&#39;,
  );

  coerce &#39;DateTime&#39;
      =&gt; from &#39;Str&#39;
      =&gt; via { $en_parser-&gt;parse_datetime($_) };

  has birth_date =&gt; (
      is      =&gt; &#39;rw&#39;,
      isa     =&gt; &#39;DateTime&#39;,
      coerce  =&gt; 1,
      handles =&gt; { birth_year =&gt; &#39;year&#39; },
  );

  enum &#39;ShirtSize&#39; =&gt; [qw( s m l xl xxl )];

  has shirt_size =&gt; (
      is      =&gt; &#39;rw&#39;,
      isa     =&gt; &#39;ShirtSize&#39;,
      default =&gt; &#39;l&#39;,
  );</code></pre>

<p>This is a fairly simple class with three attributes. We also define an enum type to validate t-shirt sizes because we don&#39;t want to end up with something like &quot;blue&quot; for the shirt size!</p>

<pre><code>  package User;

  use Email::Valid;
  use Moose;
  use Moose::Util::TypeConstraints;

  extends &#39;Person&#39;;

  subtype &#39;Email&#39;
      =&gt; as &#39;Str&#39;
      =&gt; where { Email::Valid-&gt;address($_) }
      =&gt; message { &quot;$_ is not a valid email address&quot; };

  has email_address =&gt; (
      is       =&gt; &#39;rw&#39;,
      isa      =&gt; &#39;Email&#39;,
      required =&gt; 1,
  );</code></pre>

<p>This class subclasses Person to add a single attribute, email address.</p>

<p>Now we will show what these classes would look like in plain old Perl 5. For the sake of argument, we won&#39;t use any base classes or any helpers like <code>Class::Accessor</code>.</p>

<pre><code>  package Person;

  use strict;
  use warnings;

  use Carp qw( confess );
  use DateTime;
  use DateTime::Format::Natural;

  sub new {
      my $class = shift;
      my %p = ref $_[0] ? %{ $_[0] } : @_;

      exists $p{name}
          or confess &#39;name is a required attribute&#39;;
      $class-&gt;_validate_name( $p{name} );

      exists $p{birth_date}
          or confess &#39;birth_date is a required attribute&#39;;

      $p{birth_date} = $class-&gt;_coerce_birth_date( $p{birth_date} );
      $class-&gt;_validate_birth_date( $p{birth_date} );

      $p{shirt_size} = &#39;l&#39;
          unless exists $p{shirt_size};

      $class-&gt;_validate_shirt_size( $p{shirt_size} );

      return bless \%p, $class;
  }

  sub _validate_name {
      shift;
      my $name = shift;

      local $Carp::CarpLevel = $Carp::CarpLevel + 1;

      defined $name
          or confess &#39;name must be a string&#39;;
  }

  {
      my $en_parser = DateTime::Format::Natural-&gt;new(
          lang      =&gt; &#39;en&#39;,
          time_zone =&gt; &#39;UTC&#39;,
      );

      sub _coerce_birth_date {
          shift;
          my $date = shift;

          return $date unless defined $date &amp;&amp; ! ref $date;

          my $dt = $en_parser-&gt;parse_datetime($date);

          return $dt ? $dt : undef;
      }
  }

  sub _validate_birth_date {
      shift;
      my $birth_date = shift;

      local $Carp::CarpLevel = $Carp::CarpLevel + 1;

      $birth_date-&gt;isa(&#39;DateTime&#39;)
          or confess &#39;birth_date must be a DateTime object&#39;;
  }

  sub _validate_shirt_size {
      shift;
      my $shirt_size = shift;

      local $Carp::CarpLevel = $Carp::CarpLevel + 1;

      defined $shirt_size
          or confess &#39;shirt_size cannot be undef&#39;;

      my %sizes = map { $_ =&gt; 1 } qw( s m l xl xxl );

      $sizes{$shirt_size}
          or confess &quot;$shirt_size is not a valid shirt size (s, m, l, xl, xxl)&quot;;
  }

  sub name {
      my $self = shift;

      if (@_) {
          $self-&gt;_validate_name( $_[0] );
          $self-&gt;{name} = $_[0];
      }

      return $self-&gt;{name};
  }

  sub birth_date {
      my $self = shift;

      if (@_) {
          my $date = $self-&gt;_coerce_birth_date( $_[0] );
          $self-&gt;_validate_birth_date( $date );

          $self-&gt;{birth_date} = $date;
      }

      return $self-&gt;{birth_date};
  }

  sub birth_year {
      my $self = shift;

      return $self-&gt;birth_date-&gt;year;
  }

  sub shirt_size {
      my $self = shift;

      if (@_) {
          $self-&gt;_validate_shirt_size( $_[0] );
          $self-&gt;{shirt_size} = $_[0];
      }

      return $self-&gt;{shirt_size};
  }</code></pre>

<p>Wow, that was a mouthful! One thing to note is just how much space the data validation code consumes. As a result, it&#39;s pretty common for Perl 5 programmers to just not bother. Unfortunately, not validating arguments leads to surprises down the line (&quot;why is birth_date an email address?&quot;).</p>

<p>Also, did you spot the (intentional) bug?</p>

<p>It&#39;s in the <code>_validate_birth_date()</code> method. We should check that the value in <code>$birth_date</code> is actually defined and an object before we go and call <code>isa()</code> on it! Leaving out those checks means our data validation code could actually cause our program to die. Oops.</p>

<p>Note that if we add a superclass to Person we&#39;ll have to change the constructor to account for that.</p>

<p>(As an aside, getting all the little details of what Moose does for you just right in this example was really not easy, which emphasizes the point of the example. Moose saves you a lot of work!)</p>

<p>Now let&#39;s see User:</p>

<pre><code>  package User;

  use strict;
  use warnings;

  use Carp qw( confess );
  use Email::Valid;
  use Scalar::Util qw( blessed );

  use parent &#39;Person&#39;;

  sub new {
      my $class = shift;
      my %p = ref $_[0] ? %{ $_[0] } : @_;

      exists $p{email_address}
          or confess &#39;email_address is a required attribute&#39;;
      $class-&gt;_validate_email_address( $p{email_address} );

      my $self = $class-&gt;SUPER::new(%p);

      $self-&gt;{email_address} = $p{email_address};

      return $self;
  }

  sub _validate_email_address {
      shift;
      my $email_address = shift;

      local $Carp::CarpLevel = $Carp::CarpLevel + 1;

      defined $email_address
          or confess &#39;email_address must be a string&#39;;

      Email::Valid-&gt;address($email_address)
          or confess &quot;$email_address is not a valid email address&quot;;
  }

  sub email_address {
      my $self = shift;

      if (@_) {
          $self-&gt;_validate_email_address( $_[0] );
          $self-&gt;{email_address} = $_[0];
      }

      return $self-&gt;{email_address};
  }</code></pre>

<p>That one was shorter, but it only has one attribute.</p>

<p>Between the two classes, we have a whole lot of code that doesn&#39;t do much. We could probably simplify this by defining some sort of &quot;attribute and validation&quot; hash, like this:</p>

<pre><code>  package Person;

  my %Attr = (
      name =&gt; {
          required =&gt; 1,
          validate =&gt; sub { defined $_ },
      },
      birth_date =&gt; {
          required =&gt; 1,
          validate =&gt; sub { blessed $_ &amp;&amp; $_-&gt;isa(&#39;DateTime&#39;) },
      },
      shirt_size =&gt; {
          required =&gt; 1,
          validate =&gt; sub { defined $_ &amp;&amp; $_ =~ /^(?:s|m|l|xl|xxl)$/i },
      }
  );</code></pre>

<p>Then we could define a base class that would accept such a definition and do the right thing. Keep that sort of thing up and we&#39;re well on our way to writing a half-assed version of Moose!</p>

<p>Of course, there are CPAN modules that do some of what Moose does, like <code>Class::Accessor</code>, <code>Class::Meta</code>, and so on. But none of them put together all of Moose&#39;s features along with a layer of declarative sugar, nor are these other modules designed for extensibility in the same way as Moose. With Moose, it&#39;s easy to write a MooseX module to replace or extend a piece of built-in functionality.</p>

<p>Moose is a complete OO package in and of itself, and is part of a rich ecosystem of extensions. It also has an enthusiastic community of users and is being actively maintained and developed.</p>

<h1 id="AUTHORS">AUTHORS</h1>

<ul>

<li><p>Stevan Little &lt;stevan.little@iinteractive.com&gt;</p>

</li>
<li><p>Dave Rolsky &lt;autarch@urth.org&gt;</p>

</li>
<li><p>Jesse Luehrs &lt;doy@tozt.net&gt;</p>

</li>
<li><p>Shawn M Moore &lt;code@sartak.org&gt;</p>

</li>
<li><p>&#x5D9;&#x5D5;&#x5D1;&#x5DC; &#x5E7;&#x5D5;&#x5D2;&#39;&#x5DE;&#x5DF; (Yuval Kogman) &lt;nothingmuch@woobling.org&gt;</p>

</li>
<li><p>Karen Etheridge &lt;ether@cpan.org&gt;</p>

</li>
<li><p>Florian Ragwitz &lt;rafl@debian.org&gt;</p>

</li>
<li><p>Hans Dieter Pearcey &lt;hdp@weftsoar.net&gt;</p>

</li>
<li><p>Chris Prather &lt;chris@prather.org&gt;</p>

</li>
<li><p>Matt S Trout &lt;mst@shadowcat.co.uk&gt;</p>

</li>
</ul>

<h1 id="COPYRIGHT-AND-LICENSE">COPYRIGHT AND LICENSE</h1>

<p>This software is copyright (c) 2006 by Infinity Interactive, Inc.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>


</body>

</html>


