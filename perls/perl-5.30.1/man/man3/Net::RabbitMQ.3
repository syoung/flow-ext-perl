.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "RabbitMQ 3"
.TH RabbitMQ 3 "2015-01-16" "perl v5.30.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::RabbitMQ \- interact with RabbitMQ over AMQP using librabbitmq
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&        use Net::RabbitMQ;
\&        my $mq = Net::RabbitMQ\->new();
\&        $mq\->connect("localhost", { user => "guest", password => "guest" });
\&        $mq\->channel_open(1);
\&        $mq\->publish(1, "queuename", "Hi there!");
\&        $mq\->disconnect();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Net::RabbitMQ\*(C'\fR provides a simple wrapper around the librabbitmq library
that allows connecting, declaring exchanges and queues, binding and unbinding
queues, publishing, consuming and receiving events.
.PP
Error handling in this module is primarily achieve by Perl_croak (die). You
should be making good use of eval around these methods to ensure that you
appropriately catch the errors.
.SS "Methods"
.IX Subsection "Methods"
All methods, unless specifically stated, return nothing on success
and die on failure.
.IP "\fBnew()\fR" 4
.IX Item "new()"
Creates a new Net::RabbitMQ object.
.ie n .IP "connect( $hostname, $options )" 4
.el .IP "connect( \f(CW$hostname\fR, \f(CW$options\fR )" 4
.IX Item "connect( $hostname, $options )"
\&\f(CW$hostname\fR is the host to which a connection will be attempted.
.Sp
\&\f(CW$options\fR is an optional hash respecting the following keys:
.Sp
.Vb 10
\&     {
\&       user => $user,           #default \*(Aqguest\*(Aq
\&       password => $password,   #default \*(Aqguest\*(Aq
\&       port => $port,           #default 5672
\&       vhost => $vhost,         #default \*(Aq/\*(Aq
\&       channel_max => $cmax,    #default 0
\&       frame_max => $fmax,      #default 131072
\&       heartbeat => $hearbeat,  #default 0
\&       timeout => $seconds      #default undef (no timeout)
\&     }
.Ve
.IP "\fBdisconnect()\fR" 4
.IX Item "disconnect()"
Causes the connection to RabbitMQ to be torn down.
.IP "channel_open($channel)" 4
.IX Item "channel_open($channel)"
\&\f(CW$channel\fR is a positive integer describing the channel you which to open.
.IP "channel_close($channel)" 4
.IX Item "channel_close($channel)"
\&\f(CW$channel\fR is a positive integer describing the channel you which to close.
.IP "\fBget_channel_max()\fR" 4
.IX Item "get_channel_max()"
Returns the maximum allowed channel number.
.ie n .IP "exchange_declare($channel, $exchange, $options)" 4
.el .IP "exchange_declare($channel, \f(CW$exchange\fR, \f(CW$options\fR)" 4
.IX Item "exchange_declare($channel, $exchange, $options)"
\&\f(CW$channel\fR is a channel that has been opened with \f(CW\*(C`channel_open\*(C'\fR.
.Sp
\&\f(CW$exchange\fR is the name of the exchange to be instantiated.
.Sp
\&\f(CW$options\fR is an optional hash respecting the following keys:
.Sp
.Vb 6
\&     {
\&       exchange_type => $type,  #default \*(Aqdirect\*(Aq
\&       passive => $boolean,     #default 0
\&       durable => $boolean,     #default 0
\&       auto_delete => $boolean, #default 1
\&     }
.Ve
.ie n .IP "exchange_delete($channel, $exchange, $options)" 4
.el .IP "exchange_delete($channel, \f(CW$exchange\fR, \f(CW$options\fR)" 4
.IX Item "exchange_delete($channel, $exchange, $options)"
\&\f(CW$channel\fR is a channel that has been opened with \f(CW\*(C`channel_open\*(C'\fR.
.Sp
\&\f(CW$exchange\fR is the name of the exchange to be deleted.
.Sp
\&\f(CW$options\fR is an optional hash respecting the following keys:
.Sp
.Vb 4
\&     {
\&       if_unused => $boolean,   #default 1
\&       nowait => $boolean,      #default 0
\&     }
.Ve
.ie n .IP "queue_declare($channel, $queuename, $options, $arguments)" 4
.el .IP "queue_declare($channel, \f(CW$queuename\fR, \f(CW$options\fR, \f(CW$arguments\fR)" 4
.IX Item "queue_declare($channel, $queuename, $options, $arguments)"
\&\f(CW$channel\fR is a channel that has been opened with \f(CW\*(C`channel_open\*(C'\fR.
.Sp
\&\f(CW$queuename\fR is the name of the queuename to be instantiated.  If
\&\f(CW$queuename\fR is undef or an empty string, then an auto generated
queuename will be used.
.Sp
\&\f(CW$options\fR is an optional hash respecting the following keys:
.Sp
.Vb 6
\&     {
\&       passive => $boolean,     #default 0
\&       durable => $boolean,     #default 0
\&       exclusive => $boolean,   #default 0
\&       auto_delete => $boolean, #default 1
\&     }
.Ve
.Sp
\&\f(CW$arguments\fR is an optional hash which will be passed to the server
when the queue is created.  This can be used for creating mirrored
queues by using the x\-ha-policy header.
.Sp
In scalar context, this method returns the queuename delcared
(important for retrieving the autogenerated queuename in the
event that one was requested).
.Sp
In array context, this method returns three items: queuename,
the number of message waiting on the queue, and the number
of consumers bound to the queue.
.ie n .IP "queue_bind($channel, $queuename, $exchange, $routing_key, $arguments)" 4
.el .IP "queue_bind($channel, \f(CW$queuename\fR, \f(CW$exchange\fR, \f(CW$routing_key\fR, \f(CW$arguments\fR)" 4
.IX Item "queue_bind($channel, $queuename, $exchange, $routing_key, $arguments)"
\&\f(CW$channel\fR is a channel that has been opened with \f(CW\*(C`channel_open\*(C'\fR.
.Sp
\&\f(CW$queuename\fR is a previously declared queue, \f(CW$exchange\fR is a
previously declared exchange, and \f(CW$routing_key\fR is the routing
key that will bind the specified queue to the specified exchange.
.Sp
\&\f(CW$arguments\fR is an optional hash which will be passed to the server.  When
binding to an exchange of type \f(CW\*(C`headers\*(C'\fR, this can be used to only receive
messages with the supplied header values.
.ie n .IP "queue_unbind($channel, $queuename, $exchange, $routing_key, $arguments)" 4
.el .IP "queue_unbind($channel, \f(CW$queuename\fR, \f(CW$exchange\fR, \f(CW$routing_key\fR, \f(CW$arguments\fR)" 4
.IX Item "queue_unbind($channel, $queuename, $exchange, $routing_key, $arguments)"
This is like the \f(CW\*(C`queue_bind\*(C'\fR with respect to arguments.  This command unbinds
the queue from the exchange.  The \f(CW$routing_key\fR and \f(CW$arguments\fR must match
the values supplied when the binding was created.
.ie n .IP "publish($channel, $routing_key, $body, $options, $props)" 4
.el .IP "publish($channel, \f(CW$routing_key\fR, \f(CW$body\fR, \f(CW$options\fR, \f(CW$props\fR)" 4
.IX Item "publish($channel, $routing_key, $body, $options, $props)"
\&\f(CW$channel\fR is a channel that has been opened with \f(CW\*(C`channel_open\*(C'\fR.
.Sp
\&\f(CW$routing_key\fR is the name of the routing key for this message.
.Sp
\&\f(CW$body\fR is the payload to enqueue.
.Sp
\&\f(CW$options\fR is an optional hash respecting the following keys:
.Sp
.Vb 5
\&     {
\&       exchange => $exchange,   #default \*(Aqamq.direct\*(Aq
\&       mandatory => $boolean,   #default 0
\&       immediate => $boolean,   #default 0
\&     }
.Ve
.Sp
\&\f(CW$props\fR is an optional hash (the \s-1AMQP\s0 'props') respecting the following keys:
     {
       content_type => \f(CW$string\fR,
       content_encoding => \f(CW$string\fR,
       correlation_id => \f(CW$string\fR,
       reply_to => \f(CW$string\fR,
       expiration => \f(CW$string\fR,
       message_id => \f(CW$string\fR,
       type => \f(CW$string\fR,
       user_id => \f(CW$string\fR,
       app_id => \f(CW$string\fR,
       delivery_mode => \f(CW$integer\fR,
       priority => \f(CW$integer\fR,
       timestamp => \f(CW$integer\fR,
     }
.ie n .IP "consume($channel, $queuename, $options)" 4
.el .IP "consume($channel, \f(CW$queuename\fR, \f(CW$options\fR)" 4
.IX Item "consume($channel, $queuename, $options)"
\&\f(CW$channel\fR is a channel that has been opened with \f(CW\*(C`channel_open\*(C'\fR.
.Sp
\&\f(CW$queuename\fR is the name of the queue from which we'd like to consume.
.Sp
\&\f(CW$options\fR is an optional hash respecting the following keys:
.Sp
.Vb 6
\&     {
\&       consumer_tag => $tag,    #absent by default
\&       no_local => $boolean,    #default 0
\&       no_ack => $boolean,      #default 1
\&       exclusive => $boolean,   #default 0
\&     }
.Ve
.Sp
The consumer_tag is returned.  This command does \fBnot\fR return \s-1AMQP\s0
frames, it simply notifies RabbitMQ that messages for this queue should
be delivered down the specified channel.
.IP "\fBrecv()\fR" 4
.IX Item "recv()"
This command receives and reconstructs \s-1AMQP\s0 frames and returns a hash
containing the following information:
.Sp
.Vb 8
\&     {
\&       body => \*(AqMagic Transient Payload\*(Aq, # the reconstructed body
\&       routing_key => \*(Aqnr_test_q\*(Aq,        # route the message took
\&       exchange => \*(Aqnr_test_x\*(Aq,           # exchange used
\&       delivery_tag => 1,                 # (used for acks)
\&       consumer_tag => \*(Aqc_tag\*(Aq,           # tag from consume()
\&       props => $props,                   # hashref sent in
\&     }
.Ve
.Sp
\&\f(CW$props\fR is the hash sent by \fBpublish()\fR  respecting the following keys:
     {
       content_type => \f(CW$string\fR,
       content_encoding => \f(CW$string\fR,
       correlation_id => \f(CW$string\fR,
       reply_to => \f(CW$string\fR,
       expiration => \f(CW$string\fR,
       message_id => \f(CW$string\fR,
       type => \f(CW$string\fR,
       user_id => \f(CW$string\fR,
       app_id => \f(CW$string\fR,
       delivery_mode => \f(CW$integer\fR,
       priority => \f(CW$integer\fR,
       timestamp => \f(CW$integer\fR,
     }
.ie n .IP "get($channel, $queuename, $options)" 4
.el .IP "get($channel, \f(CW$queuename\fR, \f(CW$options\fR)" 4
.IX Item "get($channel, $queuename, $options)"
\&\f(CW$channel\fR is a channel that has been opened with \f(CW\*(C`channel_open\*(C'\fR.
.Sp
\&\f(CW$queuename\fR is the name of the queue from which we'd like to consume.
.Sp
\&\f(CW$options\fR is an optional hash respecting the following keys:
.Sp
This command runs an amqp_basic_get which returns undef immediately
if no messages are available on the queue and returns a has as follows
if a message is available.
.Sp
.Vb 9
\&     {
\&       body => \*(AqMagic Transient Payload\*(Aq, # the reconstructed body
\&       routing_key => \*(Aqnr_test_q\*(Aq,        # route the message took
\&       exchange => \*(Aqnr_test_x\*(Aq,           # exchange used
\&       content_type => \*(Aqfoo\*(Aq,             # (only if specified)
\&       delivery_tag => 1,                 # (used for acks)
\&       redelivered => 0,                  # if message is redelivered
\&       message_count => 0,                # message count
\&     }
.Ve
.ie n .IP "ack($channel, $delivery_tag, $multiple = 0)" 4
.el .IP "ack($channel, \f(CW$delivery_tag\fR, \f(CW$multiple\fR = 0)" 4
.IX Item "ack($channel, $delivery_tag, $multiple = 0)"
\&\f(CW$channel\fR is a channel that has been opened with \f(CW\*(C`channel_open\*(C'\fR.
.Sp
\&\f(CW$delivery_tag\fR the delivery tag seen from a returned frame from the
\&\f(CW\*(C`recv\*(C'\fR method.
.Sp
\&\f(CW$multiple\fR specifies if multiple are to be acknowledged at once.
.ie n .IP "purge($channel, $queuename, $no_wait = 0)" 4
.el .IP "purge($channel, \f(CW$queuename\fR, \f(CW$no_wait\fR = 0)" 4
.IX Item "purge($channel, $queuename, $no_wait = 0)"
\&\f(CW$channel\fR is a channel that has been opened with \f(CW\*(C`channel_open\*(C'\fR.
.Sp
\&\f(CW$queuename\fR is the queue to be purged.
.Sp
\&\f(CW$no_wait\fR a boolean specifying if the call should not wait for
the server to acknowledge the acknowledgement.
.ie n .IP "reject($channel, $delivery_tag, $requeue = 0)" 4
.el .IP "reject($channel, \f(CW$delivery_tag\fR, \f(CW$requeue\fR = 0)" 4
.IX Item "reject($channel, $delivery_tag, $requeue = 0)"
\&\f(CW$channel\fR is a channel that has been opened with \f(CW\*(C`channel_open\*(C'\fR.
.Sp
\&\f(CW$delivery_tag\fR the delivery tag seen from a returned frame from the
\&\f(CW\*(C`recv\*(C'\fR method.
.Sp
\&\f(CW$requeue\fR specifies if the message should be requeued.
.IP "tx_select($channel)" 4
.IX Item "tx_select($channel)"
\&\f(CW$channel\fR is a channel that has been opened with \f(CW\*(C`channel_open\*(C'\fR.
.Sp
Start a server-side (tx) transaction over \f(CW$channel\fR.
.IP "tx_commit($channel)" 4
.IX Item "tx_commit($channel)"
\&\f(CW$channel\fR is a channel that has been opened with \f(CW\*(C`channel_open\*(C'\fR.
.Sp
Commit a server-side (tx) transaction over \f(CW$channel\fR.
.IP "tx_rollback($channel)" 4
.IX Item "tx_rollback($channel)"
\&\f(CW$channel\fR is a channel that has been opened with \f(CW\*(C`channel_open\*(C'\fR.
.Sp
Rollback a server-side (tx) transaction over \f(CW$channel\fR.
.ie n .IP "basic_qos($channel, $options)" 4
.el .IP "basic_qos($channel, \f(CW$options\fR)" 4
.IX Item "basic_qos($channel, $options)"
\&\f(CW$channel\fR is a channel that has been opened with \f(CW\*(C`channel_open\*(C'\fR.
.Sp
\&\f(CW$options\fR is an optional hash respecting the following keys:
.Sp
.Vb 5
\&     {
\&       prefetch_count => $cnt,  #default 0
\&       prefetch_size  => $size, #default 0
\&       global         => $bool, #default 0
\&     }
.Ve
.Sp
Set quality of service flags on the current \f(CW$channel\fR.
.IP "\fBhearbeat()\fR" 4
.IX Item "hearbeat()"
Send a hearbeat frame.  If you've connected with a heartbeat parameter,
you must send a heartbeat periodically matching connection parameter or
the server may snip the connection.
.IP "basic_return($subroutine)" 4
.IX Item "basic_return($subroutine)"
\&\f(CW$subroutine\fR is a perl coderef that takes two arguments:
.Sp
.Vb 1
\&     $channel is the channel on which the message is returned.
\&
\&     $m the message which is a hash ref containing reply_code,
\&     reply_text, exchange, and routing_key.
.Ve
