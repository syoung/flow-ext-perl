.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "ActivePerl::PPM::Client 3"
.TH ActivePerl::PPM::Client 3 "2017-06-23" "perl v5.26.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ActivePerl::PPM::Client \- Client class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  my $ppm = ActivePerl::PPM::Client\->new;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`ActivePerl::PPM::Client\*(C'\fR object ties together a set of install
areas and repositories and allow the installed packages to be managed.
The install areas are deducted from the values of \f(CW@INC\fR when the
object is constructed.
.PP
The following methods are provided:
.ie n .IP "$client = ActivePerl::PPM::Client\->new" 4
.el .IP "\f(CW$client\fR = ActivePerl::PPM::Client\->new" 4
.IX Item "$client = ActivePerl::PPM::Client->new"
.PD 0
.ie n .IP "$client = ActivePerl::PPM::Client\->new( $home_dir )" 4
.el .IP "\f(CW$client\fR = ActivePerl::PPM::Client\->new( \f(CW$home_dir\fR )" 4
.IX Item "$client = ActivePerl::PPM::Client->new( $home_dir )"
.ie n .IP "$client = ActivePerl::PPM::Client\->new( %opt )" 4
.el .IP "\f(CW$client\fR = ActivePerl::PPM::Client\->new( \f(CW%opt\fR )" 4
.IX Item "$client = ActivePerl::PPM::Client->new( %opt )"
.PD
The constructor creates a new client based on the configuration found
in \f(CW$home_dir\fR which defaults to \fI\f(CI$ENV\fI{\s-1HOME\s0}/.ActivePerl\fR directory of the
current user.  If no such directory is found it is created.
.Sp
Alternatively, key/value pairs to configure the client is passed in.  The following options are recognized:
.RS 4
.ie n .IP "home => $home_dir" 4
.el .IP "home => \f(CW$home_dir\fR" 4
.IX Item "home => $home_dir"
Directory where the client configuration database lives.
.IP "inc => \e@array" 4
.IX Item "inc => @array"
Override the list of locations to initialize install areas from.
.ie n .IP "arch => $arch" 4
.el .IP "arch => \f(CW$arch\fR" 4
.IX Item "arch => $arch"
Allow to override the architecture identification string used.  Mainly
userful for debugging.
.RE
.RS 4
.RE
.ie n .IP "$client\->arch" 4
.el .IP "\f(CW$client\fR\->arch" 4
.IX Item "$client->arch"
A string that identifies the architecture for the current perl.  This
must match the \s-1ARCHITECTURE/NAME\s0 attribute of PPDs for them to match.
.ie n .IP "$client\->area( $name )" 4
.el .IP "\f(CW$client\fR\->area( \f(CW$name\fR )" 4
.IX Item "$client->area( $name )"
Returns an object representing the given named install area.  The
method will croak if no install area with the given \f(CW$name\fR is known.
The \f(CW\*(C`perl\*(C'\fR and \f(CW\*(C`site\*(C'\fR areas will always be available.  See
ActivePerl::PPM::InstallArea for methods available on the returned
object.
.ie n .IP "$client\->areas" 4
.el .IP "\f(CW$client\fR\->areas" 4
.IX Item "$client->areas"
Return list of available install area names.  The list is ordered to
match the corresponding entries in \f(CW@INC\fR.
.ie n .IP "$client\->default_install_area" 4
.el .IP "\f(CW$client\fR\->default_install_area" 4
.IX Item "$client->default_install_area"
Return the name of the area where installations should normally go.
Might return \f(CW\*(C`undef\*(C'\fR if there is no appropriate default.
.ie n .IP "$value = $client\->config_get( $key )" 4
.el .IP "\f(CW$value\fR = \f(CW$client\fR\->config_get( \f(CW$key\fR )" 4
.IX Item "$value = $client->config_get( $key )"
.PD 0
.ie n .IP "($value1, $value2, ...) = $client\->config_get( $key1, $key2, ...)" 4
.el .IP "($value1, \f(CW$value2\fR, ...) = \f(CW$client\fR\->config_get( \f(CW$key1\fR, \f(CW$key2\fR, ...)" 4
.IX Item "($value1, $value2, ...) = $client->config_get( $key1, $key2, ...)"
.PD
Read back one or more configuration values previosly saved.
.ie n .IP "($key, $value, ...) = $client\->config_list" 4
.el .IP "($key, \f(CW$value\fR, ...) = \f(CW$client\fR\->config_list" 4
.IX Item "($key, $value, ...) = $client->config_list"
.PD 0
.ie n .IP "($key, $value, ...) = $client\->config_list( $glob_pattern )" 4
.el .IP "($key, \f(CW$value\fR, ...) = \f(CW$client\fR\->config_list( \f(CW$glob_pattern\fR )" 4
.IX Item "($key, $value, ...) = $client->config_list( $glob_pattern )"
.PD
Return all key/value pairs where \f(CW$key\fR match the given \f(CW$glob_pattern\fR.
If \f(CW$glob_pattern\fR is missing return all key/value pairs.
.ie n .IP "$client\->config_save( $key => $value )" 4
.el .IP "\f(CW$client\fR\->config_save( \f(CW$key\fR => \f(CW$value\fR )" 4
.IX Item "$client->config_save( $key => $value )"
.PD 0
.ie n .IP "$client\->config_save( %pairs )" 4
.el .IP "\f(CW$client\fR\->config_save( \f(CW%pairs\fR )" 4
.IX Item "$client->config_save( %pairs )"
.PD
Will persistently store the given key/value pairs.  The values can be
extracted again with \f(CW$client\fR\->\fBconfig_get()\fR.
.ie n .IP "$client\->repo( $repo_id )" 4
.el .IP "\f(CW$client\fR\->repo( \f(CW$repo_id\fR )" 4
.IX Item "$client->repo( $repo_id )"
Returns a reference to a hash describing the repo with the given
identifier.  The interesting fields of this hash are:
.RS 4
.IP "name" 4
.IX Item "name"
The full (user friendly) name of the repository.  Can be modified by
\&\f(CW$repo\fR\->\fBrepo_set_name()\fR.
.IP "enabled" 4
.IX Item "enabled"
A boolean that indicated if the repo is enabled or not.  Can be
modified by \f(CW$repo\fR\->\fBrepo_enable()\fR.
.IP "pkgs" 4
.IX Item "pkgs"
The number of packages provided by this repository.
.IP "packlist_uri" 4
.IX Item "packlist_uri"
The \s-1URI\s0 that the \s-1PPM\s0 client will monitor for changes to the
repository.  This \s-1URI\s0 can denote a \fIpacklist.xml\fR, \fIpacklist.lst\fR
file or an \s-1HTML\s0 document with links to \s-1PPD\s0 files (typically a server
generated directory listing).  The \s-1URI\s0 can use any scheme that \s-1LWP\s0
supports and can embed a username and password for \s-1HTTP\s0 using this syntax: \f(CW\*(C`http://user:pass@ppm.example.com/\*(C'\fR.
.IP "packlist_last_status" 4
.IX Item "packlist_last_status"
The \s-1HTTP\s0 status code reported last time the \s-1PPM\s0 client tried to access
\&\f(CW\*(C`packlist_uri\*(C'\fR document.
.IP "packlist_last_access" 4
.IX Item "packlist_last_access"
When did we last try to to access the \f(CW\*(C`packlist_uri\*(C'\fR document.  The
value is seconds from epoch as for perl's \fBtime()\fR function.
.IP "packlist_fresh_until" 4
.IX Item "packlist_fresh_until"
When do we need to refetch the \f(CW\*(C`packlist_uri\*(C'\fR document. The
value is seconds from epoch as for perl's \fBtime()\fR function.
.RE
.RS 4
.RE
.ie n .IP "$client\->repos" 4
.el .IP "\f(CW$client\fR\->repos" 4
.IX Item "$client->repos"
Returns list of available repo identifiers.
.ie n .IP "$client\->repo_add( name => $name, packlist_uri => $uri )" 4
.el .IP "\f(CW$client\fR\->repo_add( name => \f(CW$name\fR, packlist_uri => \f(CW$uri\fR )" 4
.IX Item "$client->repo_add( name => $name, packlist_uri => $uri )"
Will add a new repository with the given attributes.  The method will
croak if a repository with the same \f(CW\*(C`packlist_uri\*(C'\fR already exists.
The return value is the \f(CW$repo_id\fR of the new repository.
.ie n .IP "$client\->repo_delete( $repo_id )" 4
.el .IP "\f(CW$client\fR\->repo_delete( \f(CW$repo_id\fR )" 4
.IX Item "$client->repo_delete( $repo_id )"
Will make the client forget about the given repository.
.ie n .IP "$client\->repo_enable( $repo_id )" 4
.el .IP "\f(CW$client\fR\->repo_enable( \f(CW$repo_id\fR )" 4
.IX Item "$client->repo_enable( $repo_id )"
.PD 0
.ie n .IP "$client\->repo_enable( $repo_id, $bool )" 4
.el .IP "\f(CW$client\fR\->repo_enable( \f(CW$repo_id\fR, \f(CW$bool\fR )" 4
.IX Item "$client->repo_enable( $repo_id, $bool )"
.PD
Makes it possible to enable and disable the given reposiory.  If \f(CW$bool\fR
is provided and is \s-1FALSE,\s0 then the repository is disabled.  The return
value is \s-1TRUE\s0 if the given repository was enabled.
.ie n .IP "$client\->repo_set_name( $repo_id, $name )" 4
.el .IP "\f(CW$client\fR\->repo_set_name( \f(CW$repo_id\fR, \f(CW$name\fR )" 4
.IX Item "$client->repo_set_name( $repo_id, $name )"
Will update the name by which the given repo is known.
.ie n .IP "$client\->repo_set_packlist_uri( $repo_id, $uri )" 4
.el .IP "\f(CW$client\fR\->repo_set_packlist_uri( \f(CW$repo_id\fR, \f(CW$uri\fR )" 4
.IX Item "$client->repo_set_packlist_uri( $repo_id, $uri )"
Will update the address of the packlist to monitor for the given
repository.  Will croak if the \f(CW$uri\fR is already used by some other
repo.
.Sp
Updating the \s-1URI\s0 will loose all cached information about the repo.  A
new 'repo_sync' is needed to update this information.
.ie n .IP "$client\->repo_sync( %args )" 4
.el .IP "\f(CW$client\fR\->repo_sync( \f(CW%args\fR )" 4
.IX Item "$client->repo_sync( %args )"
Will sync the local cache of packages from the enabled repositories.
Remote repositories are not contacted if the cache is not considered
stale yet.  The following options are recognized:
.RS 4
.ie n .IP "force => $bool" 4
.el .IP "force => \f(CW$bool\fR" 4
.IX Item "force => $bool"
If \s-1TRUE\s0 force state to be transfered again from remote repositories.
Make requests unconditional.
.ie n .IP "validate => $bool" 4
.el .IP "validate => \f(CW$bool\fR" 4
.IX Item "validate => $bool"
If \s-1TRUE\s0 validate state from remote repositories even if state still
believed to be fresh.  Will still send conditional requests.
.ie n .IP "max_ppd => $num" 4
.el .IP "max_ppd => \f(CW$num\fR" 4
.IX Item "max_ppd => $num"
If repository is an \s-1HTML\s0 document set limit for how many \s-1PPD\s0 links it
might contain.  The default is 100.
.ie n .IP "repo => $repo_id" 4
.el .IP "repo => \f(CW$repo_id\fR" 4
.IX Item "repo => $repo_id"
Pass \f(CW\*(C`repo\*(C'\fR with an identifier to only sync the given repo.
.RE
.RS 4
.RE
.ie n .IP "$client\->search( $pattern )" 4
.el .IP "\f(CW$client\fR\->search( \f(CW$pattern\fR )" 4
.IX Item "$client->search( $pattern )"
.PD 0
.ie n .IP "$client\->search( $pattern, $field,... )" 4
.el .IP "\f(CW$client\fR\->search( \f(CW$pattern\fR, \f(CW$field\fR,... )" 4
.IX Item "$client->search( $pattern, $field,... )"
.PD
Will search for packages matching the given glob style \f(CW$pattern\fR.
Without further arguments this will return a list of package names.
With \f(CW$field\fR arguments it will return a list of array references, each
one filled in with the corresponding values for maching packages.
.Sp
The supported field names are:
.Sp
.Vb 12
\&    id
\&    name
\&    version
\&    release_date
\&    author
\&    abstract
\&    ppd_uri
\&    ppd_etag
\&    ppd_fresh_until
\&    codebase
\&    repo_id
\&    cannot_install
.Ve
.Sp
See ActivePerl::PPM::RepoPackage (and ActivePerl::PPM::Package) for a
description of these fields.  The \f(CW\*(C`cannot_install\*(C'\fR field is a boolean that
is \s-1TRUE\s0 for packages that can't be installed for some reason.
.ie n .IP "$client\->search_lookup( $num )" 4
.el .IP "\f(CW$client\fR\->search_lookup( \f(CW$num\fR )" 4
.IX Item "$client->search_lookup( $num )"
Will look up the given package from the last \fBsearch()\fR result, where
\&\f(CW$num\fR matches the 1\-based index into the list returned by the last
search.  This will return an ActivePerl::PPM::RepoPackage object.
.ie n .IP "$client\->packages" 4
.el .IP "\f(CW$client\fR\->packages" 4
.IX Item "$client->packages"
.PD 0
.ie n .IP "$client\->packages( $field,... )" 4
.el .IP "\f(CW$client\fR\->packages( \f(CW$field\fR,... )" 4
.IX Item "$client->packages( $field,... )"
.PD
Without arguments returns the ids of packages available.  In scalar
context returns the number of packages.
.Sp
With arguments return a list of array references each one representing
one package.  The elements of each array are the fields requested.
For the list of field names that can be used see the description of
the \*(L"search\*(R" method above.
.ie n .IP "$client\->package( $id )" 4
.el .IP "\f(CW$client\fR\->package( \f(CW$id\fR )" 4
.IX Item "$client->package( $id )"
.PD 0
.ie n .IP "$client\->package( $name, $version )" 4
.el .IP "\f(CW$client\fR\->package( \f(CW$name\fR, \f(CW$version\fR )" 4
.IX Item "$client->package( $name, $version )"
.PD
Returns the ActivePerl::PPM::RepoPackage object matching the
arguments or \f(CW\*(C`undef\*(C'\fR if none match.  If \f(CW$version\fR is passed as \f(CW\*(C`undef\*(C'\fR,
the package needs to be versionless to be returned.
.ie n .IP "$client\->feature_best( $feature )" 4
.el .IP "\f(CW$client\fR\->feature_best( \f(CW$feature\fR )" 4
.IX Item "$client->feature_best( $feature )"
Returns the highest version number provided for the given feature by
the packages found in all enabled repositories.  The method return
\&\f(CW\*(C`undef\*(C'\fR if no package provide this feature.
.ie n .IP "$client\->package_best( $feature, $version )" 4
.el .IP "\f(CW$client\fR\->package_best( \f(CW$feature\fR, \f(CW$version\fR )" 4
.IX Item "$client->package_best( $feature, $version )"
Returns the best package of all enabled repositories that provide the
given feature at or better than the given version.
.ie n .IP "$client\->feature_have( $feature )" 4
.el .IP "\f(CW$client\fR\->feature_have( \f(CW$feature\fR )" 4
.IX Item "$client->feature_have( $feature )"
.PD 0
.ie n .IP "$client\->feature_have( $feature, @areas )" 4
.el .IP "\f(CW$client\fR\->feature_have( \f(CW$feature\fR, \f(CW@areas\fR )" 4
.IX Item "$client->feature_have( $feature, @areas )"
.PD
Returns the installed version number of the given feature.  Returns
\&\f(CW\*(C`undef\*(C'\fR if none of the installed packages provide this feature.
.Sp
If one or more \f(CW@areas\fR are provided, only look in the areas given by
these names.
.ie n .IP "$client\->packages_depending_on( $pkg, $area )" 4
.el .IP "\f(CW$client\fR\->packages_depending_on( \f(CW$pkg\fR, \f(CW$area\fR )" 4
.IX Item "$client->packages_depending_on( $pkg, $area )"
Returns the packages (as \f(CW\*(C`ActivePerl::PPM::Package\*(C'\fR objects) that
would \*(L"break\*(R" if the given package was uninstalled.  This means that
the returned packages are those that depend on features that the given
package provide.  In scalar context return number of packages.
.Sp
The \f(CW$pkg\fR argument can be either a package name or a package object.
.ie n .IP "$client\->packages_missing( %args )" 4
.el .IP "\f(CW$client\fR\->packages_missing( \f(CW%args\fR )" 4
.IX Item "$client->packages_missing( %args )"
Returns the list of packages to install in order to obtain the
requested features.  The returned list consist of
ActivePerl::PPM::RepoPackage objects.  The attribute \f(CW\*(C`_wanted\*(C'\fR
will be \s-1TRUE\s0 if a package was requested directly.  The attribute
\&\f(CW\*(C`_needed_by\*(C'\fR will be an array reference of package names listing
packages having resolved dependencies on this package.  These
attributes do not exclude each other.
.Sp
The returned list will be empty if all the requested features are
already installed.
.Sp
The method will croak if nothing provides the requested features, if
dependencies can't be resolved or if the packages selected have
conflicting dependencies.
.Sp
The arguments to the function are passed as key/value pairs:
.RS 4
.IP "want => \e@features" 4
.IX Item "want => @features"
This is the list of features to resolve.  The elements can be plain
strings denoting feature names, or references to arrays containing a
\&\f(CW$name\fR, \f(CW$version\fR pair.  If \f(CW$version\fR is provided as \f(CW\*(C`undef\*(C'\fR then this
is taken as an upgrade request and the function will try to find the
packages that provide the best possible version of this feature.
.IP "have => \e@pkgs" 4
.IX Item "have => @pkgs"
List of packages you already have decided to install.  The function
will check if any of these packages provide needed features before
looking anywhere else.
.IP "want_deps => \e@pkgs" 4
.IX Item "want_deps => @pkgs"
Resolve any dependencies for the given packages.
.IP "area => \e@areas" 4
.IX Item "area => @areas"
List of names of install areas to consider when determining if
requested features or dependencies are already installed or not.
.ie n .IP "force => $bool" 4
.el .IP "force => \f(CW$bool\fR" 4
.IX Item "force => $bool"
If \s-1TRUE\s0 then return packages that provide the given features even if
they are already installed.  Will also disable check for downgrades.
.ie n .IP "follow_deps => $str" 4
.el .IP "follow_deps => \f(CW$str\fR" 4
.IX Item "follow_deps => $str"
In what way should packages dependencies be resolved.  The provided
\&\f(CW$str\fR can take the values \f(CW\*(C`all\*(C'\fR, \f(CW\*(C`missing\*(C'\fR, or \f(CW\*(C`none\*(C'\fR.  The default
is \f(CW\*(C`missing\*(C'\fR.  If \f(CW$str\fR is \f(CW\*(C`all\*(C'\fR then dependent packages are returned
even if they are already installed.  If \f(CW$str\fR is \f(CW\*(C`missing\*(C'\fR then only
missing dependencies are returned.  If \f(CW$str\fR is \f(CW\*(C`none\*(C'\fR then
dependencies are ignored.
.IP "error_handler => \e&callback" 4
.IX Item "error_handler => &callback"
Call the given error handler instead of croaking in the case of
trouble.  Error messages are provided as argument.  There can be more
than one.
.Sp
Providing an error_handler allow the function to return missing
packages for working dependencies even if not all dependencies worked
out.
.RE
.RS 4
.RE
.ie n .IP "$client\->install( %args )" 4
.el .IP "\f(CW$client\fR\->install( \f(CW%args\fR )" 4
.IX Item "$client->install( %args )"
Will download, unpack and install the given packages.  The function
will raise an exception of it gets into trouble, otherwise it will
return
.Sp
The arguments to the function are passed as key/value pairs:
.RS 4
.IP "packages => \e@pkgs" 4
.IX Item "packages => @pkgs"
Mandatory argument that provide the packages to install.  The array
passed should contain \f(CW\*(C`ActivePerl::PPM::Package\*(C'\fR objects.
.ie n .IP "area => $area" 4
.el .IP "area => \f(CW$area\fR" 4
.IX Item "area => $area"
What install area to install into.  If not provided, then
\&\f(CW$client\fR\->default_install_area is used.
.IP "run_cb => \e&func" 4
.IX Item "run_cb => &func"
A callback function that should behave like &ActivePerl::Run::run
which will be called to execute the commands of the post install
script.  If not provided, then &ActivePerl::Run::run will be used.
.RE
.RS 4
.RE
.ie n .IP "$client\->profile_xml" 4
.el .IP "\f(CW$client\fR\->profile_xml" 4
.IX Item "$client->profile_xml"
Returns an \s-1XML\s0 document that describes the configured repositories and
the installed packages.
.ie n .IP "$client\->profile_xml_restore( $profile_xml, %opt )" 4
.el .IP "\f(CW$client\fR\->profile_xml_restore( \f(CW$profile_xml\fR, \f(CW%opt\fR )" 4
.IX Item "$client->profile_xml_restore( $profile_xml, %opt )"
Will try to restore the repositories and packages described by the
passed in \s-1XML\s0 document.  The document should be one generated by the
profile_xml method.  The following options are recognized:
.RS 4
.ie n .IP "restore_repo => $bool" 4
.el .IP "restore_repo => \f(CW$bool\fR" 4
.IX Item "restore_repo => $bool"
Pass a \s-1FALSE\s0 value to suppress adding the repositories found in the
profile document.
.ie n .IP "restore_pkgs => $bool" 4
.el .IP "restore_pkgs => \f(CW$bool\fR" 4
.IX Item "restore_pkgs => $bool"
Pass a \s-1FALSE\s0 value to suppress installation of the packages listed in
the profile document that are missing.
.ie n .IP "verbose => $bool" 4
.el .IP "verbose => \f(CW$bool\fR" 4
.IX Item "verbose => $bool"
Log extra information about the steps taken when \s-1TRUE.\s0
.ie n .IP "area => $area_name" 4
.el .IP "area => \f(CW$area_name\fR" 4
.IX Item "area => $area_name"
Which install area to install into.  If not provided, then
\&\f(CW$client\fR\->default_install_area is used.
.RE
.RS 4
.RE
.SH "BUGS"
.IX Header "BUGS"
none.
