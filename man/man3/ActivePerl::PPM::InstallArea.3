.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "ActivePerl::PPM::InstallArea 3"
.TH ActivePerl::PPM::InstallArea 3 "2017-06-23" "perl v5.26.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ActivePerl::PPM::InstallArea \- Perl installation area
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  my $area = ActivePerl::PPM::InstallArea\->new("site");
\&  # or
\&  my $area = ActivePerl::PPM::InstallArea\->new(prefix => "$ENV{HOME}/perl");
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An \f(CW\*(C`ActivePerl::PPM::InstallArea\*(C'\fR object provide an interface to a
Perl install area.  Different install areas might have different
protection policies and each contain a set of installed packages and
modules.  The concept is the same as \f(CW\*(C`INSTALLDIRS\*(C'\fR provided by
ExtUtils::MakeMaker.
.PP
An install area is divided into the following directories:
.IP "lib" 8
.IX Item "lib"
This is where architecture neutral modules go.  Packages that
are implemented in pure perl are installed here.
.IP "archlib" 8
.IX Item "archlib"
This is where architecture specific modules go.  Packages that are
implemented using \s-1XS\s0 code are installed here.  For ActivePerl this
will normally be the same as \f(CW\*(C`lib\*(C'\fR.
.IP "script" 8
.IX Item "script"
This is where architecture neutral programs go.
.IP "bin" 8
.IX Item "bin"
This is where architecture specific programs go.  For ActivePerl this
will normally be the same as \f(CW\*(C`script\*(C'\fR.
.IP "etc" 8
.IX Item "etc"
This is where configuration files go.
.IP "man1" 8
.IX Item "man1"
This is where Unix style manual pages describing programs go.
.IP "man3" 8
.IX Item "man3"
This is where Unix style manual pages describing modules go.
.IP "html" 8
.IX Item "html"
This is where \s-1HTML\s0 files go.
.IP "prefix" 8
.IX Item "prefix"
This just provide a prefix for the install area as a whole.  All paths
above should be at or below \f(CW\*(C`prefix\*(C'\fR.
.PP
The following methods are provided:
.ie n .IP "$area = ActivePerl::PPM::InstallArea\->new( $name )" 4
.el .IP "\f(CW$area\fR = ActivePerl::PPM::InstallArea\->new( \f(CW$name\fR )" 4
.IX Item "$area = ActivePerl::PPM::InstallArea->new( $name )"
.PD 0
.ie n .IP "$area = ActivePerl::PPM::InstallArea\->new( %opts )" 4
.el .IP "\f(CW$area\fR = ActivePerl::PPM::InstallArea\->new( \f(CW%opts\fR )" 4
.IX Item "$area = ActivePerl::PPM::InstallArea->new( %opts )"
.PD
Constructs a new \f(CW\*(C`ActivePerl::PPM::InstallArea\*(C'\fR object.  If constructed
based on \f(CW$name\fR, then the constructor might croak if no
install area with the given name is known.  The \*(L"perl\*(R" and \*(L"site\*(R" install areas
are always available.  Some perls might also have a \*(L"vendor\*(R" install area.
.Sp
Alternatively the directories to use can be specified directly by
passing them as key/value pair \f(CW%opts\fR.  Only \f(CW\*(C`prefix\*(C'\fR is mandatory.
All other directories are derived from this, except for the \f(CW\*(C`man*\*(C'\fR
directories will only set up if specified explicitly.
.Sp
The option \f(CW\*(C`autoinit\*(C'\fR will if \s-1TRUE\s0 make the install area call
\&\f(CW$self\fR\->initialize automatically when some method need access to the
database.
.ie n .IP "$area\->name" 4
.el .IP "\f(CW$area\fR\->name" 4
.IX Item "$area->name"
Returns the name.  This returns the empty string for nameless \fIInstallArea\fR.
.ie n .IP "$area\->prefix" 4
.el .IP "\f(CW$area\fR\->prefix" 4
.IX Item "$area->prefix"
.PD 0
.ie n .IP "$area\->archlib" 4
.el .IP "\f(CW$area\fR\->archlib" 4
.IX Item "$area->archlib"
.ie n .IP "$area\->lib" 4
.el .IP "\f(CW$area\fR\->lib" 4
.IX Item "$area->lib"
.ie n .IP "$area\->bin" 4
.el .IP "\f(CW$area\fR\->bin" 4
.IX Item "$area->bin"
.ie n .IP "$area\->script" 4
.el .IP "\f(CW$area\fR\->script" 4
.IX Item "$area->script"
.ie n .IP "$area\->man1" 4
.el .IP "\f(CW$area\fR\->man1" 4
.IX Item "$area->man1"
.ie n .IP "$area\->man3" 4
.el .IP "\f(CW$area\fR\->man3" 4
.IX Item "$area->man3"
.ie n .IP "$area\->html" 4
.el .IP "\f(CW$area\fR\->html" 4
.IX Item "$area->html"
.ie n .IP "$area\->etc" 4
.el .IP "\f(CW$area\fR\->etc" 4
.IX Item "$area->etc"
.PD
Returns the corresponding path.
.ie n .IP "$area\->inc" 4
.el .IP "\f(CW$area\fR\->inc" 4
.IX Item "$area->inc"
Returns the list of directories to be pushed onto perl's \f(CW@INC\fR for the
current install area.
.ie n .IP "$area\->initialized" 4
.el .IP "\f(CW$area\fR\->initialized" 4
.IX Item "$area->initialized"
Returns \s-1TRUE\s0 if this area has been initialized.  If \f(CW\*(C`autoinit\*(C'\fR was
specified for the constructor, then this method might have the side
effect of actually initializing the database, in which case this
returns \s-1TRUE.\s0
.ie n .IP "$area\->initialize" 4
.el .IP "\f(CW$area\fR\->initialize" 4
.IX Item "$area->initialize"
Set up the database used to track packages for the install area if not
already set up.  This invokes \fBsync_db()\fR if the database was created.
.Sp
Most methods will croak unless the install area has been initialized.
Exceptions are \fBname()\fR, \fBreadonly()\fR, \fBinitialized()\fR, \fBpackages()\fR and the
directory accessors (like \fBlib()\fR, \fBscript()\fR,...).
.Sp
The \f(CW\*(C`autoinit\*(C'\fR option can be specified for the constructor to make
the database be automatically set up during the first method call
that needs it.
.ie n .IP "$area\->readonly" 4
.el .IP "\f(CW$area\fR\->readonly" 4
.IX Item "$area->readonly"
Returns \s-1TRUE\s0 if it is not possible to install or remove packages from
the area.  This is usually caused by the user not having permission
to modify the files of the area.
.Sp
This also returns \s-1TRUE\s0 for unintialized install areas.
.ie n .IP "$area\->install( packages => [\e%pkg1, \e%pkg2, ...] )" 4
.el .IP "\f(CW$area\fR\->install( packages => [\e%pkg1, \e%pkg2, ...] )" 4
.IX Item "$area->install( packages => [%pkg1, %pkg2, ...] )"
Install the given list of packages as one atomic operation.  The
function returns \s-1TRUE\s0 if all packages installed or \s-1FALSE\s0 if
installation failed.
.Sp
Each package to be installed is described by a hash reference (or an
ActivePerl::PPM::Package object) with the following elements:
.RS 4
.ie n .IP "name => $name" 4
.el .IP "name => \f(CW$name\fR" 4
.IX Item "name => $name"
The name of the package.  If a package with the given name is already
installed, then it will replaced with the new package.  This is the
only mandatory attribute.
.ie n .IP "version => $version" 4
.el .IP "version => \f(CW$version\fR" 4
.IX Item "version => $version"
The version identifier for the given package.
.ie n .IP "author => $string" 4
.el .IP "author => \f(CW$string\fR" 4
.IX Item "author => $string"
Who the current maintainer of the package is.  Should normally be on
the form \*(L"Givenname Lastname <user@example.com>\*(R".
.ie n .IP "abstract => $string" 4
.el .IP "abstract => \f(CW$string\fR" 4
.IX Item "abstract => $string"
A short sentence describing the purpose of the package.
.ie n .IP "blib => $path" 4
.el .IP "blib => \f(CW$path\fR" 4
.IX Item "blib => $path"
Pick up files to install from the given \fIblib\fR style directory.  The
codebase directory of \s-1PPD\s0 packages is usually a tarball of this stuff.
.IP "files => \e%hash" 4
.IX Item "files => %hash"
A hash describing files and directories to install.  The keys are
where to copy files from and the values are install locations.  The
install locations selects what type of directory to install into by
prefixing them with an dir identifier followed by a colon.  Example:
.Sp
.Vb 4
\&   files => {
\&      Foo => "archlib:Foo",
\&      "Bar.pm" => "lib:Bar.pm"
\&   }
.Ve
.Sp
This will install the \*(L"Foo\*(R" directory into the archlib area and the
\&\*(L"Bar.pm\*(R" module into the lib area.
.RE
.RS 4
.RE
.ie n .IP "$area\->uninstall( $name )" 4
.el .IP "\f(CW$area\fR\->uninstall( \f(CW$name\fR )" 4
.IX Item "$area->uninstall( $name )"
Removes the given package and its installed files.  Croaks if no such
package was installed in the first place.  Uninstalling a package
might break other packages that depended on features this package
provided.
.ie n .IP "$area\->verify( %opts )" 4
.el .IP "\f(CW$area\fR\->verify( \f(CW%opts\fR )" 4
.IX Item "$area->verify( %opts )"
Verify that the files of the installed packages are still present and
unmodified.
.Sp
In scalar context returns \s-1TRUE\s0 if all files where still found good.
In array context return key/value pairs suitable for assignment to a
hash.  The \f(CW\*(C`verified\*(C'\fR value is the number of files checked.  The
\&\f(CW\*(C`missing\*(C'\fR, \f(CW\*(C`modified\*(C'\fR, \f(CW\*(C`wrong_mode\*(C'\fR tally the files found to be
missing, modified or chmoded.
.Sp
The following options are recognized:
.RS 4
.ie n .IP "package => $name" 4
.el .IP "package => \f(CW$name\fR" 4
.IX Item "package => $name"
Only verify the given package.
.IP "file_cb => \e&sub" 4
.IX Item "file_cb => &sub"
Function called back for each file visited.  The function is called
with 3 arguments; the file name, expected md5 checksum and expected
file mode.
.IP "badfile_cb => \e&sub" 4
.IX Item "badfile_cb => &sub"
Function called back each time a bad file is found.  The first
argument is what kind of badness (same as the status keys in the
return value), the second is the file name and the addtional info
varies depending on kind.
.RE
.RS 4
.RE
.ie n .IP "$area\->packages( @fields )" 4
.el .IP "\f(CW$area\fR\->packages( \f(CW@fields\fR )" 4
.IX Item "$area->packages( @fields )"
Without arguments returns the sorted list of names of packages
currently installed.  In scalar context returns the number of packages
installed, or \f(CW\*(C`undef\*(C'\fR if database has not been initialized.
.Sp
With arguments return a list of array references each one representing
an installed package.  The elements of each array are the fields
requested.  The list will be sorted by package name.  See
ActivePerl::PPM::Package for what field names are available.
.ie n .IP "$area\->package( $id )" 4
.el .IP "\f(CW$area\fR\->package( \f(CW$id\fR )" 4
.IX Item "$area->package( $id )"
.PD 0
.ie n .IP "$area\->package( $name )" 4
.el .IP "\f(CW$area\fR\->package( \f(CW$name\fR )" 4
.IX Item "$area->package( $name )"
.ie n .IP "$area\->package( $name, sloppy => 1 )" 4
.el .IP "\f(CW$area\fR\->package( \f(CW$name\fR, sloppy => 1 )" 4
.IX Item "$area->package( $name, sloppy => 1 )"
.PD
Return an package object (see ActivePerl::PPM::Package) for the
given package.  Returns \f(CW\*(C`undef\*(C'\fR if no such package is installed.
.Sp
If no package match the specified name exactly and \f(CW\*(C`sloppy\*(C'\fR is
specified then search again ignoring case and even search for features
provided that match name.  The method will croak if this extended
search end up matching multiple packages.
.ie n .IP "$area\->package_id( $name )" 4
.el .IP "\f(CW$area\fR\->package_id( \f(CW$name\fR )" 4
.IX Item "$area->package_id( $name )"
Returns the internal identifier for the given package.  The package
name much match exactly; case matters.  Returns \f(CW\*(C`undef\*(C'\fR if no such
package is installed.  This is the cheapest way to check if a package
is installed.
.ie n .IP "$area\->package_id( $name, sloppy => 1 )" 4
.el .IP "\f(CW$area\fR\->package_id( \f(CW$name\fR, sloppy => 1 )" 4
.IX Item "$area->package_id( $name, sloppy => 1 )"
Find package even if the name does not match exactly.  The package
will be found if the name match without regard to case or if it
provide the given name as a feature.  Will croak if multiple packages
match.
.ie n .IP "$area\->package_have( $name, $version )" 4
.el .IP "\f(CW$area\fR\->package_have( \f(CW$name\fR, \f(CW$version\fR )" 4
.IX Item "$area->package_have( $name, $version )"
Returns \s-1TRUE\s0 if the package with the given name and version number
is installed.
.ie n .IP "$area\->feature_have( $feature )" 4
.el .IP "\f(CW$area\fR\->feature_have( \f(CW$feature\fR )" 4
.IX Item "$area->feature_have( $feature )"
If one of the installed packages provide the given feature, then the
feature version number is returned.  The method returns \f(CW\*(C`undef\*(C'\fR if no
package provide the given feature.
.ie n .IP "$area\->package_files( $id )" 4
.el .IP "\f(CW$area\fR\->package_files( \f(CW$id\fR )" 4
.IX Item "$area->package_files( $id )"
Returns the list of names for the files that belong to the given
package.  In scalar context return the number of files.
.ie n .IP "$area\->file_owner( $path )" 4
.el .IP "\f(CW$area\fR\->file_owner( \f(CW$path\fR )" 4
.IX Item "$area->file_owner( $path )"
Return the \f(CW$id\fR if the package that owns the given file, or \f(CW\*(C`undef\*(C'\fR if
the file is not tracked by this install area.
.ie n .IP "$area\->package_packlist( $id )" 4
.el .IP "\f(CW$area\fR\->package_packlist( \f(CW$id\fR )" 4
.IX Item "$area->package_packlist( $id )"
Returns the \fI.packlist\fR file for the given package.  See
ExtUtils::Packlist.
.ie n .IP "$area\->packlists" 4
.el .IP "\f(CW$area\fR\->packlists" 4
.IX Item "$area->packlists"
Returns the list of packages that have \fI.packlist\fR files installed.
In scalar context return a hash reference; the keys are package names
and the values are full paths to the corresponding \fI.packlist\fR file.
This will also pick up packages installed by other means that by \s-1PPM.\s0
See ExtUtils::Packlist for more information about these files.  \s-1PPM\s0
does not use \fI.packlist\fR files to track the files installed by the
packages it manage, but it keeps them in sync for other tools that
manage modules.
.ie n .IP "$area\->sync_db( %opt )" 4
.el .IP "\f(CW$area\fR\->sync_db( \f(CW%opt\fR )" 4
.IX Item "$area->sync_db( %opt )"
Synchronize the state of the \s-1PPM\s0 database with what modules seems to
be installed in the directories of the current install area.  Packages
where all files are gone will also be deleted from the \s-1PPM\s0 database.
.Sp
The following options are recognized:
.RS 4
.ie n .IP """keep_package_version"" => $bool" 4
.el .IP "\f(CWkeep_package_version\fR => \f(CW$bool\fR" 4
.IX Item "keep_package_version => $bool"
If \s-1TRUE\s0 don't try to update the package version from the version
number of the module with the same name as the pacakge.
.RE
.RS 4
.RE
.SH "SEE ALSO"
.IX Header "SEE ALSO"
ActivePerl::PPM::Package, ExtUtils::Packlist.
.SH "BUGS"
.IX Header "BUGS"
none.
