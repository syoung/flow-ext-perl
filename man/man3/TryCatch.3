.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "TryCatch 3"
.TH TryCatch 3 "2013-03-22" "perl v5.26.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
TryCatch \- first class try catch semantics for Perl, without source filters.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module aims to provide a nicer syntax and method to catch errors in Perl,
similar to what is found in other languages (such as Java, Python or \*(C+).  The
standard method of using \f(CW\*(C`eval {}; if ($@) {}\*(C'\fR is often prone to subtle
bugs, primarily that its far too easy to stomp on the error in error handlers.
And also eval/if isn't the nicest idiom.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use TryCatch;
\&
\& sub foo {
\&   my ($self) = @_;
\&
\&   try {
\&     die Some::Class\->new(code => 404 ) if $self\->not_found;
\&     return "return value from foo";
\&   }
\&   catch (Some::Class $e where { $_\->code > 100 } ) {
\&   }
\& }
.Ve
.SH "SYNTAX"
.IX Header "SYNTAX"
This module aims to give first class exception handling to perl via 'try' and
\&'catch' keywords. The basic syntax this module provides is \f(CW\*(C`try { # block }\*(C'\fR
followed by zero or more catch blocks. Each catch block has an optional type
constraint on it the resembles Perl6's method signatures.
.PP
Also worth noting is that the error variable (\f(CW$@\fR) is localised to the
try/catch blocks and will not leak outside the scope, or stomp on a previous
value of \f(CW$@\fR.
.PP
The simplest case of a catch block is just
.PP
.Vb 1
\& catch { ... }
.Ve
.PP
where upon the error is available in the standard \f(CW$@\fR variable and no type
checking is performed. The exception can instead be accessed via a named
lexical variable by providing a simple signature to the catch block as follows:
.PP
.Vb 1
\& catch ($err) { ... }
.Ve
.PP
Type checking of the exception can be performed by specifing a type constraint
or where clauses in the signature as follows:
.PP
.Vb 2
\& catch (TypeFoo $e) { ... }
\& catch (Dict[code => Int, message => Str] $err) { ... }
.Ve
.PP
As shown in the above example, complex Moose types can be used, including
MooseX::Types style of type constraints
.PP
In addition to type checking via Moose type constraints, you can also use where
clauses to only match a certain sub-condition on an error. For example,
assuming that \f(CW\*(C`HTTPError\*(C'\fR is a suitably defined \s-1TC:\s0
.PP
.Vb 6
\& catch (HTTPError $e where { $_\->code >= 400 && $_\->code <= 499 } ) {
\&   return "4XX error";
\& }
\& catch (HTTPError $e) {
\&   return "other http code";
\& }
.Ve
.PP
would return \*(L"4XX error\*(R" in the case of a 404 error, and \*(L"other http code\*(R" in
the case of a 302.
.PP
In the case where multiple catch blocks are present, the first one that matches
the type constraints (if any) will executed.
.SH "BENEFITS"
.IX Header "BENEFITS"
\&\fBreturn\fR. You can put a return in a try block, and it would do the right thing
\&\- namely return a value from the subroutine you are in, instead of just from
the eval block.
.PP
\&\fBType Checking\fR. This is nothing you couldn't do manually yourself, it does it
for you using Moose type constraints.
.SH "TODO"
.IX Header "TODO"
.IP "\(bu" 4
Decide on \f(CW\*(C`finally\*(C'\fR semantics w.r.t return values.
.IP "\(bu" 4
Write some more documentation
.IP "\(bu" 4
Split out the dependancy on Moose
.SH "SEE ALSO"
.IX Header "SEE ALSO"
MooseX::Types, Moose::Util::TypeConstraints, Parse::Method::Signatures.
.SH "AUTHOR"
.IX Header "AUTHOR"
Ash Berlin <ash@cpan.org>
.SH "THANKS"
.IX Header "THANKS"
Thanks to Matt S Trout and Florian Ragwitz for work on Devel::Declare and
various B::Hooks modules
.PP
Vincent Pit for Scope::Upper that makes the return from block possible.
.PP
Zefram for providing support and \s-1XS\s0 guidance.
.PP
Xavier Bergade for the impetus to finally fix this module in 5.12.
.SH "LICENSE"
.IX Header "LICENSE"
Licensed under the same terms as Perl itself.
