.\" Automatically generated by Pod::Man 4.10 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\" ========================================================================
.\"
.IX Title "ActivePerl::PPM::Package 3"
.TH ActivePerl::PPM::Package 3 "2017-06-23" "perl v5.26.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ActivePerl::PPM::Package \- Package class
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&  my $pkg = ActivePerl::PPM::Package\->new(name => \*(AqFoo\*(Aq,...);
\&  # or
\&  my $pkg = ActivePerl::PPM::Package\->new(\e%hash);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \f(CW\*(C`ActivePerl::PPM::Package\*(C'\fR class wraps hashes that describes
packages; the unit that the \s-1PPM\s0 system manages.
.SS "Constructors"
.IX Subsection "Constructors"
The following constructor methods are provided:
.ie n .IP "$pkg = ActivePerl::PPM::Package\->new( %opt );" 4
.el .IP "\f(CW$pkg\fR = ActivePerl::PPM::Package\->new( \f(CW%opt\fR );" 4
.IX Item "$pkg = ActivePerl::PPM::Package->new( %opt );"
.PD 0
.ie n .IP "$pkg = ActivePerl::PPM::Package\->new( \e%self );" 4
.el .IP "\f(CW$pkg\fR = ActivePerl::PPM::Package\->new( \e%self );" 4
.IX Item "$pkg = ActivePerl::PPM::Package->new( %self );"
.PD
The constructor either take key/value pairs or a hash reference as
argument.  The only mandatory field is \f(CW\*(C`name\*(C'\fR.  If a hash reference
is passed then it is turned into an \f(CW\*(C`ActivePerl::PPM::Package\*(C'\fR object
and returned; which basically pass ownership of the hash.
.ie n .IP "$copy = $pkg\->clone" 4
.el .IP "\f(CW$copy\fR = \f(CW$pkg\fR\->clone" 4
.IX Item "$copy = $pkg->clone"
Returns a copy of the current package object.  The attributes of the
clone can be modified without changing the original.
.ie n .IP "ActivePerl::PPM::Package\->new_dbi($dbh, $id);" 4
.el .IP "ActivePerl::PPM::Package\->new_dbi($dbh, \f(CW$id\fR);" 4
.IX Item "ActivePerl::PPM::Package->new_dbi($dbh, $id);"
.PD 0
.ie n .IP "ActivePerl::PPM::Package\->new_dbi($dbh, $name, $version);" 4
.el .IP "ActivePerl::PPM::Package\->new_dbi($dbh, \f(CW$name\fR, \f(CW$version\fR);" 4
.IX Item "ActivePerl::PPM::Package->new_dbi($dbh, $name, $version);"
.PD
Read object from a database and return it.  Returns \f(CW\*(C`undef\*(C'\fR if no
package with the given key is found.
.ie n .IP "$pkg\->dbi_store( $dbh )" 4
.el .IP "\f(CW$pkg\fR\->dbi_store( \f(CW$dbh\fR )" 4
.IX Item "$pkg->dbi_store( $dbh )"
Writes the current package to a database.  If \f(CW$pkg\fR was constructed by
\&\f(CW\*(C`new_dbi\*(C'\fR then this updates the package, otherwise this creates a new
package object in the database.
.Sp
Returns the \f(CW$id\fR of the object stored if successful, otherwise \f(CW\*(C`undef\*(C'\fR.
.SS "Attributes"
.IX Subsection "Attributes"
The attributes of a package can be accessed directly using hash syntax
or by accesor methods.  The most common attributes are described
below, but the set of attributes is extensible.
.ie n .IP "$str = $pkg\->id" 4
.el .IP "\f(CW$str\fR = \f(CW$pkg\fR\->id" 4
.IX Item "$str = $pkg->id"
Returns the database id of package.  This attribute is set if the
object exists in a database.
.ie n .IP "$str = $pkg\->name" 4
.el .IP "\f(CW$str\fR = \f(CW$pkg\fR\->name" 4
.IX Item "$str = $pkg->name"
Returns the name of the package.
.ie n .IP "$str = $pkg\->version" 4
.el .IP "\f(CW$str\fR = \f(CW$pkg\fR\->version" 4
.IX Item "$str = $pkg->version"
Returns the version identifier for the package.  This string
can be anything and there is no reliable way to order packages based
on these version strings.
.ie n .IP "$str = $pkg\->name_version" 4
.el .IP "\f(CW$str\fR = \f(CW$pkg\fR\->name_version" 4
.IX Item "$str = $pkg->name_version"
Returns the name and version concatenated together.  This form might
be handy for display, but there is no reliable way to parse back what
is the name and what is the version identifier.
.ie n .IP "$str = $pkg\->release_date" 4
.el .IP "\f(CW$str\fR = \f(CW$pkg\fR\->release_date" 4
.IX Item "$str = $pkg->release_date"
Returns the date the package was released on as an \s-1ISO 8601\s0 date
(YYYY\-MM\-DDThh:mm:ss).  For \s-1CPAN\s0 packages this is the date the package
was uploaded to \s-1CPAN.\s0
.ie n .IP "$str = $pkg\->author" 4
.el .IP "\f(CW$str\fR = \f(CW$pkg\fR\->author" 4
.IX Item "$str = $pkg->author"
The name and email address of the current maintainer of the package.
.ie n .IP "$str = $pkg\->abstract" 4
.el .IP "\f(CW$str\fR = \f(CW$pkg\fR\->abstract" 4
.IX Item "$str = $pkg->abstract"
A short sentence describing the purpose of the package.
.ie n .IP "$url = $pkg\->ppd_uri" 4
.el .IP "\f(CW$url\fR = \f(CW$pkg\fR\->ppd_uri" 4
.IX Item "$url = $pkg->ppd_uri"
This is the \s-1URI\s0 for the \s-1PPD\s0 file itself.
.ie n .IP "$str = $pkg\->ppd_etag" 4
.el .IP "\f(CW$str\fR = \f(CW$pkg\fR\->ppd_etag" 4
.IX Item "$str = $pkg->ppd_etag"
This is the \f(CW\*(C`ETag\*(C'\fR that the server reported for the \s-1PPD\s0 last time.
.ie n .IP "$str = $pkg\->ppd_lastmod" 4
.el .IP "\f(CW$str\fR = \f(CW$pkg\fR\->ppd_lastmod" 4
.IX Item "$str = $pkg->ppd_lastmod"
This is the \f(CW\*(C`Last\-Modified\*(C'\fR field that the server reported for the
\&\s-1PPD\s0 last time.
.ie n .IP "$url = $pkg\->codebase" 4
.el .IP "\f(CW$url\fR = \f(CW$pkg\fR\->codebase" 4
.IX Item "$url = $pkg->codebase"
Returns the \s-1URL\s0 to implementation; a blib tarball.
Interpret this \s-1URL\s0 relative to \fIppd_uri\fR.
.ie n .IP "$url = $pkg\->codebase_abs" 4
.el .IP "\f(CW$url\fR = \f(CW$pkg\fR\->codebase_abs" 4
.IX Item "$url = $pkg->codebase_abs"
Returns the absolute \s-1URL\s0 to the 'codebase'
.ie n .IP "%features = $pkg\->provides" 4
.el .IP "\f(CW%features\fR = \f(CW$pkg\fR\->provides" 4
.IX Item "%features = $pkg->provides"
Returns a list of (feature, version) pairs describing what features
this package provide.  A feature name with a double colon in it
represent a perl module.  A package always provide its own name as a
feature.
.ie n .IP "%features = $pkg\->requires" 4
.el .IP "\f(CW%features\fR = \f(CW$pkg\fR\->requires" 4
.IX Item "%features = $pkg->requires"
Returns a list of (feature, version) pairs describing what features
this package require to be installed for it to work properly.  A
feature name with a double colon in it represent a perl module.
.SS "Comparators"
.IX Subsection "Comparators"
The following functions/methods can be used to order packages.
.ie n .IP "$pkg\->compare( $other )" 4
.el .IP "\f(CW$pkg\fR\->compare( \f(CW$other\fR )" 4
.IX Item "$pkg->compare( $other )"
Returns \-1, 0, 1 like perl's builtin \f(CW\*(C`cmp\*(C'\fR.  Return \f(CW\*(C`undef\*(C'\fR if no order is defined.
.ie n .IP "$pkg\->better_than( $other )" 4
.el .IP "\f(CW$pkg\fR\->better_than( \f(CW$other\fR )" 4
.IX Item "$pkg->better_than( $other )"
Returns \s-1TRUE\s0 if this package is better than the package passed as
argument.  This method will croak if no order is defined.
.ie n .IP "$pkg\->best( @others )" 4
.el .IP "\f(CW$pkg\fR\->best( \f(CW@others\fR )" 4
.IX Item "$pkg->best( @others )"
.PD 0
.ie n .IP "ActivePerl::PPM::Package::best( @pkgs )" 4
.el .IP "ActivePerl::PPM::Package::best( \f(CW@pkgs\fR )" 4
.IX Item "ActivePerl::PPM::Package::best( @pkgs )"
.PD
Returns the best package.  Might croak if no order is defined among
the packages passed in.
.SS "Misc methods"
.IX Subsection "Misc methods"
.IP "ActivePerl::PPM::Package\->sql_create_tables" 4
.IX Item "ActivePerl::PPM::Package->sql_create_tables"
This returns \s-1SQL\s0 \f(CW\*(C`CREATE TABLE\*(C'\fR statements used to initialize the
database that the \f(CW\*(C`new_dbi\*(C'\fR and \f(CW\*(C`dbi_store\*(C'\fR methods depend on.
.ie n .IP "$bool = $pkg\->features_declared" 4
.el .IP "\f(CW$bool\fR = \f(CW$pkg\fR\->features_declared" 4
.IX Item "$bool = $pkg->features_declared"
Returns \s-1TRUE\s0 if this package declare what features it provide.  \s-1PPM4\s0
style packages should declare what modules and other features they
provide, but packages from older repositories might not.
.ie n .IP "$pkg\->has_script( $kind )" 4
.el .IP "\f(CW$pkg\fR\->has_script( \f(CW$kind\fR )" 4
.IX Item "$pkg->has_script( $kind )"
Return \s-1TRUE\s0 if the package has the given \f(CW$kind\fR of script attached.
The \f(CW$kind\fR argument should be either \*(L"install\*(R" or \*(L"uninstall\*(R".
.ie n .IP "$pkg\->run_script( $kind, $area, $tmpdir, \e%pkg_info )" 4
.el .IP "\f(CW$pkg\fR\->run_script( \f(CW$kind\fR, \f(CW$area\fR, \f(CW$tmpdir\fR, \e%pkg_info )" 4
.IX Item "$pkg->run_script( $kind, $area, $tmpdir, %pkg_info )"
Execute the given kind of script for the package.  The \f(CW$kind\fR argument
should be either \*(L"install\*(R" or \*(L"uninstall\*(R".  The \f(CW$kind\fR and \f(CW$area\fR
argument must be provided.
.SH "BUGS"
.IX Header "BUGS"
none.
